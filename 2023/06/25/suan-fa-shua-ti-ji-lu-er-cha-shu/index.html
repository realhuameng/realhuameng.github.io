<!DOCTYPE html>
<html lang="zh-CN">
    <head prefix="og: https://ogp.me/ns#">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="color-scheme" content="light dark">
  
  <title>算法刷题记录—二叉树 - Hexo</title>
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    <link rel='manifest' href='/manifest.json'>
  

  
  
  
  <meta property="og:title" content="算法刷题记录—二叉树 - Hexo" />
  
  <meta property="og:type" content="article" />
  
  <meta property="og:url" content="http://realhuameng.github.io/2023/06/25/suan-fa-shua-ti-ji-lu-er-cha-shu/index.html" />
  
  <meta property="og:image" content="/favicon.png" />
  
  <meta property="og:article:published_time" content="2023-06-25T00:51:41.550Z" />
  
  <meta property="og:article:author" content="John Doe" />
  
  

  
<link rel="stylesheet" href="/css/var.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<link rel="stylesheet" href="/css/typography.css">

  
<link rel="stylesheet" href="/css/code-highlighting.css">

  
<link rel="stylesheet" href="/css/components.css">

  
<link rel="stylesheet" href="/css/nav.css">

  
<link rel="stylesheet" href="/css/paginator.css">

  
<link rel="stylesheet" href="/css/footer.css">

  
<link rel="stylesheet" href="/css/post-list.css">

  
  
<link rel="stylesheet" href="/css/rainbow-banner.css">

  
  
  
<link rel="stylesheet" href="/css/toc.css">

  
  
  
  
  
<link rel="stylesheet" href="/css/post.css">

  
  
  
  
  

  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>
    <body
        data-color-scheme="auto"
        data-uppercase-categories="true"
        
        data-rainbow-banner="true"
        data-rainbow-banner-shown="auto"
        data-rainbow-banner-month="6"
        data-rainbow-banner-colors="#e50000,#ff8d00,#ffee00,#008121,#004cff,#760188"
        
        data-config-root="/"
        
        data-toc="true"
        data-toc-max-depth="2"
        
        
    >
        <nav id="theme-nav">
    <div class="inner">
        <a class="title" href="/">Blog</a>
        <div class="nav-arrow"></div>
        <div class="nav-items">
            <a class="nav-item nav-item-home" href="/">Home</a>
            
            
            <a class="nav-item" href="/archives">Archives</a>
            
            
            
            <a class="nav-item" href="/friends">Friends</a>
            
            
            
            <a class="nav-item" href="/projects">Projects</a>
            
            
            
            <a class="nav-item" href="/about">About</a>
            
            
            
            <a class="nav-item nav-item-github nav-item-icon" href="https://github.com/realhuameng" target="_blank" aria-label="GitHub">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-search nav-item-icon" href="/search" target="_blank" aria-label="Search">&nbsp;</a>
            
            
        </div>
    </div>
</nav>
        
<article class="post">
    <div class="meta">
        

        
        <div class="date" id="date">
            <span>June</span>
            <span>25,</span>
            <span>2023</span>
        </div>
        

        <h2 class="title">算法刷题记录—二叉树</h2>
    </div>

    <div class="divider"></div>

    <div class="content">
        <h3 id="二叉树理论基础"><a href="#二叉树理论基础" class="headerlink" title="二叉树理论基础"></a>二叉树理论基础</h3><h4 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h4><p>满二叉树：深度为k，有2^k-1个节点</p>
<p>完全二叉树：除最底层节点可能没填满外，其余每层节点数都达到最大值</p>
<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>二叉搜索树是一个有序树</p>
<p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值</p>
<p>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</p>
<p>它的左右子树也分别为二叉排序树</p>
<h4 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h4><p>AVL树</p>
<p>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</p>
<p>c++中map、set、multimap、multiset的底层实现都是平衡二叉搜索树</p>
<h4 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h4><p>二叉树既可以链式存储，也可以顺序存储</p>
<p>链式存储方式就用指针，顺序存储的方式就是用数组</p>
<p>遍历数组存储的二叉树：左孩子是i * 2+1，右孩子是i * 2+2</p>
<h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h4><p>1.深度优先遍历</p>
<p>前序遍历（递归法，迭代法）</p>
<p>中序遍历（递归法，迭代法）</p>
<p>后序遍历（递归法，迭代法）</p>
<p>2.广度优先遍历</p>
<p>层次遍历（迭代法）</p>
<h4 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h4><p>链式存储</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct TreeNode&#123;
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x),left(NULL),right(NULL)&#123;&#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;前序遍历
class Solution&#123;
public:
    void traverval(TreeNode* cur, vector&lt;int&gt;&amp; vec)
    &#123;
        if(cur &#x3D;&#x3D; NULL) return;
        vec.push_back(cur-&gt;val);
        traverval(cur-&gt;left, vec);
        traverval(cur-&gt;right, vec);
    &#125;
    vector&lt;int&gt; preorderTraverval(TreeNode* root)
    &#123;
        vector&lt;int&gt; result;
        traverval(root, result);
        return result;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;中序遍历
void traverval(TreeNode* cur, vector&lt;int&gt;&amp; vec)     
&#123;         
    if(cur &#x3D;&#x3D; NULL) return;                  
    traverval(cur-&gt;left, vec); 
    vec.push_back(cur-&gt;val);
    traverval(cur-&gt;right, vec);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;后序遍历
void traverval(TreeNode* cur, vector&lt;int&gt;&amp; vec)     
&#123;         
    if(cur &#x3D;&#x3D; NULL) return;                  
    traverval(cur-&gt;left, vec); 
    traverval(cur-&gt;right, vec);
    vec.push_back(cur-&gt;val);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;
public:
    vector&lt;int&gt; preorderTraverval(TreeNode* root)
    &#123;
        stack&lt;TreeNode*&gt; st;
        vector&lt;int&gt; result;
        if(root &#x3D;&#x3D; NULL) return result;
        st.push(root);
        while(!st.empty)
        &#123;
            TreeNode* node &#x3D; st.top();
            st.pop();
            result.push_back(node-&gt;val);
            if(node-&gt;right) st.push-&gt;back(node-&gt;right);
            if(node-&gt;left) st.push_back(node-&gt;left);
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p><strong>借助指针访问结点，借助栈处理元素</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;
public:
    vector&lt;int&gt; inorderTraverval(TreeNode* root)
    &#123;
        vector&lt;int&gt; result;
        stack&lt;int&gt; st;
        TreeNode* cur &#x3D; root;
        while(cur !&#x3D; NULL || !st.empty())
        &#123;
            if(cur !&#x3D; NULL)
            &#123;
                st.push(cur);
                cur &#x3D; cur-&gt;left;
            &#125;
            else&#123;
                cur &#x3D; st.top();
                st.pop();
                result.push_back(cur-&gt;val);
                cur &#x3D; cur-&gt;right;
            &#125;
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;
public:
    vector postorderTraverval(TreeNode* root)
    &#123;
        vector&lt;int&gt; result;
        stack&lt;int&gt; st;
        if(root &#x3D;&#x3D; NULL) return result;
       st.push(root);
        while(!st.empty())
        &#123;
            TreeNode* node &#x3D; st.top();
            st.pop();
            result.push_back(node-&gt;val);
            if(node-&gt;left) st.push_back(node-&gt;val);
            if(node-&gt;right) st.push_back(node-&gt;val);
        &#125;
        reverese(result.begin(), result.end());
        return result;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="二叉树的统一迭代法"><a href="#二叉树的统一迭代法" class="headerlink" title="二叉树的统一迭代法"></a>二叉树的统一迭代法</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;
public:
    vector&lt;int&gt; inorderTraverval(TreeNode* root)
    &#123;
        vector&lt;int&gt; result;
        stack&lt;TreeNode*&gt; st;
        if(root &#x3D;&#x3D; NULL) return result;
        st.push(root);
        while(!st.empty())
        &#123;
            TreeNode* node &#x3D; st.top();
            if(node !&#x3D; NULL)
            &#123;
                st.pop();
                if(node-&gt;right) st.push(node-&gt;right);&#x2F;&#x2F;右结点入栈
                
                st.push(node);&#x2F;&#x2F;下一个要访问的结点入栈
                st.push(NULL);
                
                if(node-&gt;left) st.push(node-&gt;left);&#x2F;&#x2F;左结点入栈
                
                
            &#125;
            else&#123; &#x2F;&#x2F;当遇到空结点时
                st.pop(); &#x2F;&#x2F;弹出空结点
                node &#x3D; st.pop(); &#x2F;&#x2F;保存当前结点
                st.pop();
                result.push_back(node-&gt;val); &#x2F;&#x2F;空结点后的结点值加入结果集
            &#125;
            return result;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>前序遍历和后序遍历仅需改变三行代码的顺序即可实现</p>
<h3 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h3><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root)
    &#123;
        queue&lt;TreeNode*&gt; que;
        vector&lt;vector&lt;int&gt;&gt; result;
        if(node &#x3D;&#x3D; NULL) return result;
        que.push(root);
        while(!que.empty())
        &#123;
            int size &#x3D; que.size(); &#x2F;&#x2F;使用固定大小的size
            vector&lt;int&gt; vec;
            for(int i&#x3D;0;i &lt; size;i++)
            &#123;
                TreeNode* node &#x3D; que.front();
                que.pop();
                vec.push_back(node-&gt;val);
                if(node-&gt;left) que.push(node-&gt;left);
                if(node-&gt;right) que.push(node-&gt;right);
            &#125;
            result.push_back(vec);
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;递归法
class Solution&#123;
public:
    void order(TreeNode* cur, vector&lt;int&gt;&lt;int&gt;&amp; result, int depth)
    &#123;
        if(cur &#x3D;&#x3D; NULL) return;
        if(result.size()&#x3D;&#x3D;depth) result.push_back(vector&lt;int&gt;());
        result[depth].push_back(cur-&gt;val);
        order(cur-&gt;left, result, depth+1);
        order(cur-&gt;right, result, depth+1);
    &#125;
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root)
    &#123;
        vector&lt;vector&lt;int&gt;&gt; result;
        int depth &#x3D; 0;
        order(root, result, depth);
        return result;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="107-二叉树的层次遍历II"><a href="#107-二叉树的层次遍历II" class="headerlink" title="107.二叉树的层次遍历II"></a>107.二叉树的层次遍历II</h3><p> 在层次遍历的基础上将result反转</p>
<h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199.二叉树的右视图"></a>199.二叉树的右视图</h3><p>当每层遍历到结尾时，将结点的值放入结果集中</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;
public:
    vector&lt;int&gt; rightsideView(TreeNode* root)
    &#123;
        queue&lt;TreeNode*&gt; que;
        vector&lt;int&gt; result;
        if(root &#x3D;&#x3D; NULL) return result;
        que.push(root);
        while(!que.empty())
        &#123;
            int size &#x3D; que.size();
            for(int i&#x3D;0;i &lt; size;i++)
            &#123;
                TreeNode* node &#x3D; que.front();
                que.pop();
                if(i &#x3D;&#x3D; size - 1) result.push_back(node-&gt;val);
                if(node-&gt;left) que.push(node-&gt;left);
                if(node-&gt;right) que.push(node-&gt;right);
            &#125;
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637.二叉树的层平均值"></a>637.二叉树的层平均值</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;
public:
    vector&lt;double&gt; averageOfLevel(TreeNode* root)
    &#123;
        queue&lt;TreeNode*&gt; que;
        vector&lt;double&gt; result;
        if(root &#x3D;&#x3D; NULL) return result;
        que.push(root);
        while(!que.empty())
        &#123;
            int size &#x3D; que.size();
            double sum &#x3D; 0;
            for(int i&#x3D;0;i&lt;size;i++)
            &#123;
                TreeNode* node &#x3D; que.front();
                que.pop();
                sum +&#x3D; node-&gt;val;
                if(node-&gt;left) que.push(node-&gt;left);
                if(node-&gt;right) que.push(node-&gt;right);
            &#125;
            result.push_back(sum&#x2F;size);
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429.N叉树的层序遍历"></a>429.N叉树的层序遍历</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution
&#123;
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root)
    &#123;
        queue&lt;Node*&gt; que;
        vector&lt;vector&lt;int&gt;&gt; result;
        if(root !&#x3D; NULL)( que.push(root);
        while(!que.empty())
                         &#123;
                             int size &#x3D; que.size();
                             vector&lt;int&gt; vec;
                             for(int i&#x3D;0;i&lt;size;i++)
                             &#123;
                                 Node* node &#x3D; que.front();
                                 que.pop();
                                 vec.push_back(node-&gt;val);
                                 for(int i&#x3D;0;i&lt;node-&gt;children.size();i++)
                                 &#123;
                                     if(node-&gt;childrem[i]) que.push(node-&gt;children[i]);
                                 &#125;
                                 
                             &#125;
                             result.push_back(vec);
                         &#125;
                         return result;
    &#125;
                         
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515.在每个树行中找最大值"></a>515.在每个树行中找最大值</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution
&#123;
public:
    vector&lt;int&gt; largestValue(TreeNode* root)
    &#123;
        vector&lt;int&gt; result;
        queue&lt;int&gt; que;
        int maxx &#x3D; INT_MIN;
        if(root !&#x3D; NULL) que.push(root);
        while(!que.empty())
        &#123;
            int size &#x3D; que.size();
            for(int i&#x3D;0;i &lt; size;i++)
            &#123;
                TreeNode* node &#x3D; que.front();
                que.pop();
                max &#x3D; mode-&gt;val &gt; max ? max : val;
                if(node-&gt;right) que.push(node-&gt;right);
                if(node-&gt;left) que.push(node-&gt;left);
                
            &#125;
            result.push_back(max);
        &#125;
        return result;
        
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116.填充每个节点的下一个右侧节点指针"></a>116.填充每个节点的下一个右侧节点指针</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution
&#123;
public:
    Node* connect(Node* root)
    &#123;
        queue&lt;Node*&gt; que;
        if(root !&#x3D; NULL) que.push(root);
        Node* nodepre;
        Node* node;
        while(!que.empty())
        &#123;
            int size &#x3D; que.size();
            for(int i&#x3D;0;i &lt; size;i++)
            &#123;
                if(i &#x3D;&#x3D; 0)
                &#123;
                    nodepre &#x3D; que.front();
                    que.pop();
                    node &#x3D; nodepre;
                &#125;
                else
                &#123;
                    node &#x3D; que.front();
                    que.pop();
                    nodepre-&gt;next &#x3D; node;
                    nodepre &#x3D; nodepre-&gt;next;
                &#125;
                if(node-&gt;right) que.push(node-&gt;right);
                if(node-&gt;left) que.push(node-&gt;left);
            &#125;
            nodepre-&gt;next &#x3D; NULL;
        &#125;
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="117-填充每个节点的下一个右侧节点指针Ⅱ"><a href="#117-填充每个节点的下一个右侧节点指针Ⅱ" class="headerlink" title="117.填充每个节点的下一个右侧节点指针Ⅱ"></a>117.填充每个节点的下一个右侧节点指针Ⅱ</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    Node* connect(Node* root) &#123;
        queue&lt;Node*&gt; que;
        if (root !&#x3D; NULL) que.push(root);
        while (!que.empty()) &#123;
            int size &#x3D; que.size();
           
            Node* nodePre;
            Node* node;
            for (int i &#x3D; 0; i &lt; size; i++) &#123;
                if (i &#x3D;&#x3D; 0) &#123;
                    nodePre &#x3D; que.front(); &#x2F;&#x2F; 取出一层的头结点
                    que.pop();
                    node &#x3D; nodePre;
                &#125; else &#123;
                    node &#x3D; que.front();
                    que.pop();
                    nodePre-&gt;next &#x3D; node; &#x2F;&#x2F; 本层前一个节点next指向本节点
                    nodePre &#x3D; nodePre-&gt;next;
                &#125;
                if (node-&gt;left) que.push(node-&gt;left);
                if (node-&gt;right) que.push(node-&gt;right);
            &#125;
            nodePre-&gt;next &#x3D; NULL; &#x2F;&#x2F; 本层最后一个节点指向NULL
        &#125;
        return root;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="104-二叉树最大深度"><a href="#104-二叉树最大深度" class="headerlink" title="104.二叉树最大深度"></a>104.二叉树最大深度</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution
&#123;
public:
    int maxDepth(TreeNode* root)
    &#123;
        queue&lt;TreeNode*&gt; que;
        int depth &#x3D; 0;
        if(root !&#x3D; NULL) que.push(root);
        while(!que.empty())
        &#123;
            int size &#x3D; que.size();
            depth++;
            for(int i&#x3D;0;i &lt; size;i++)
            &#123;
                TreeNode* node &#x3D; que.front();
                que.pop();
                if(node-&gt;right) que.push(node-&gt;right);
                if(node-&gt;left) que.push(node-&gt;left);
            &#125;
            
        &#125;
        return depth;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minDepth(TreeNode* root) &#123;
        queue&lt;TreeNode*&gt; que;
        int depth &#x3D; 0;
        if(root !&#x3D; NULL) que.push(root);
        while(!que.empty())
        &#123;
            int size &#x3D; que.size();
            depth++;
            for(int i&#x3D;0;i &lt; size;i++)
            &#123;
                TreeNode* node &#x3D; que.front();
                que.pop();
                if(!node-&gt;right &amp;&amp; !node-&gt;left) return depth;
                if(node-&gt;right) que.push(node-&gt;right);
                if(node-&gt;left) que.push(node-&gt;left);
            &#125;
        &#125;
        return depth;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="226-反转二叉树"><a href="#226-反转二叉树" class="headerlink" title="226.反转二叉树"></a>226.反转二叉树</h3><p><strong>递归法</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;
public:
    TreeNode* invertTree(TreeNode* root)&#123;
        if(root &#x3D;&#x3D; NULL) return root;
        swap(root-&gt;left, root-&gt;right);
        invertTree(root-&gt;right);
        invertTree(root-&gt;left);
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>迭代法</strong></p>
<p><strong>深度优先遍历</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;
public:
    TreeNode* invertTree(TreeNode* root)
    &#123;
        if(root &#x3D;&#x3D; NULL) return root;
        stack&lt;TreeNode*&gt; st;
        st.push(root);
        while(!st.empty())
        &#123;
            TreeNode* node &#x3D; st.top();
            st.pop();
            swap(node-&gt;left, node-&gt;right);
            if(node-&gt;right) st.push(node-&gt;right);
            if(node-&gt;left) st.push(node-&gt;left);
            
        &#125;
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>广度优先遍历</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;
public:
    TreeNode* invertTree(TreeNode* root)
    &#123;
        queue&lt;TreeNode*&gt; que;
        if(root !&#x3D; NULL) que.push(root);
        while(!que.empty())
        &#123;
            int size &#x3D; que.size();
            for(int i&#x3D;0;i &lt; size;i++)
            &#123;
                TreeNode* node &#x3D; que.front();
                que.pop();
                swap(node-&gt;left, node-&gt;right);
                if(node-&gt;left) que.push(node-&gt;left);
                if(node-&gt;right) que.push(node-&gt;right);
            &#125;
        &#125;
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h3><p>递归法</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;
public:
    bool compare(TreeNode* left, TreeNode* right)
    &#123;
        if(left !&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL) return false;
        else if(left &#x3D;&#x3D; NULL &amp;&amp; right !&#x3D; NULL) return false;
        else if(left &#x3D;&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL) return true;
        else if(left-&gt;val !&#x3D; right-&gt;val) return false;
        
        bool outside &#x3D; compare(left-&gt;left, right-&gt;right);
        bool inside &#x3D; compare(left-&gt;right, right-&gt;left);
        bool isSame &#x3D; outside &amp;&amp; inside;
        return isSame;
    &#125;
    bool isSysmmetric(TreeNode* root)
    &#123;
        if(root &#x3D;&#x3D; NULL) return true;
        return compare(root-&gt;left, root-&gt;right);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


    </div>

    
    <div class="about">
        <h1>About this Post</h1>
        <div class="details">
            <p>This post is written by John Doe, licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0">CC BY-NC 4.0</a>.</p>
        </div>
        
    </div>
    

    <div class="container post-prev-next">
        
        <a href="/2023/06/25/suan-fa-shua-ti-ji-lu-shuang-zhi-zhen-fa/" class="next">
            <div>
                <div class="text">
                    <p class="label">Next</p>
                    <h3 class="title">算法刷题记录—双指针法</h3>
                </div>
            </div>
        </a>
        
        
        <a href="/2023/06/25/suan-fa-shua-ti-ji-lu-ha-xi-biao/" class="prev">
            <div>
                <div class="text">
                    <p class="label">Previous</p>
                    <h3 class="title">算法刷题记录-哈希表</>
                </div>
            </div>
        </a>
        
    </div>

    
        
        
    
</article>

        <footer>
    <div class="inner">
        <div class="links">
            
            <div class="group">
                <h2 class="title">Blog</h2>
                
                <a href="/" class="item">Blog</a>
                
                <a href="/archives" class="item">Archives</a>
                
                <a href="/tags" class="item">Tags</a>
                
                <a href="/categories" class="item">Categories</a>
                
                <a href="/search" class="item">Search</a>
                
                <a href="/friends" class="item">Friends</a>
                
                <a href="/projects" class="item">Projects</a>
                
                <a href="/resume" class="item">Resume</a>
                
                <a href="/about" class="item">About</a>
                
                <a href="/atom.xml" class="item">RSS</a>
                
            </div>
            
            <div class="group">
                <h2 class="title">Projects</h2>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom/hexo-theme-cupertino" class="item">Hexo Theme Cupertino</a>
                
            </div>
            
            <div class="group">
                <h2 class="title">Me</h2>
                
                <a target="_blank" rel="noopener" href="https://github.com/realhuameng" class="item">GitHub</a>
                
                <a href="1263313190@qq.com" class="item">Email</a>
                
            </div>
            
        </div>
        <span>&copy; 2023 John Doe<br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> </span>
        
        
            <br>
            <div class="color-scheme-toggle" role="radiogroup" id="theme-color-scheme-toggle">
                <label>
                    <input type="radio" value="light">
                    <span>Light</span>
                </label>
                <label>
                    <input type="radio" value="dark">
                    <span>Dark</span>
                </label>
                <label>
                    <input type="radio" value="auto">
                    <span>Auto</span>
                </label>
            </div>
        
    </div>
</footer>


        
<script src="/js/main.js"></script>

        
        
        

        
        <script src="https://unpkg.com/scrollreveal"></script>
        <script>
            window.addEventListener('load', () => {
                ScrollReveal({ delay: 250, reset: true, easing: 'cubic-bezier(0, 0, 0, 1)' })
                ScrollReveal().reveal('.post-list-item .cover-img img')
                ScrollReveal().reveal('.post-list-item, .card, .content p img, .content .block-large img', { distance: '60px', origin: 'bottom', duration: 800 })
            })
        </script>
        
    </body>
</html>