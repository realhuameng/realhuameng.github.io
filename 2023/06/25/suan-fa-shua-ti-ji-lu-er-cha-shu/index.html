<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Hua Meng,1263313190@qq.com"><title>算法刷题记录—二叉树 · Realhuameng</title><meta name="description" content="二叉树理论基础二叉树的种类满二叉树：深度为k，有2^k-1个节点
完全二叉树：除最底层节点可能没填满外，其余每层节点数都达到最大值
二叉搜索树二叉搜索树是一个有序树
若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值
若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
它的左右子"><meta name="keywords" content="C++,Linux,Java,Go"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Realhuameng</a></h3><div class="description"><p>Fake it till you make it.</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="http://github.com/realhuameng"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首頁</a></li><li><a href="/about">關於</a></li><li><a href="/archives">歸檔</a></li><li><a href="/links">連結</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/favicon.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>算法刷题记录—二叉树</a></h3></div><div class="post-content"><h3 id="二叉树理论基础"><a href="#二叉树理论基础" class="headerlink" title="二叉树理论基础"></a>二叉树理论基础</h3><h4 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h4><p>满二叉树：深度为k，有2^k-1个节点</p>
<p>完全二叉树：除最底层节点可能没填满外，其余每层节点数都达到最大值</p>
<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>二叉搜索树是一个有序树</p>
<p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值</p>
<p>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</p>
<p>它的左右子树也分别为二叉排序树</p>
<h4 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h4><p>AVL树</p>
<p>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</p>
<p>c++中map、set、multimap、multiset的底层实现都是平衡二叉搜索树</p>
<h4 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h4><p>二叉树既可以链式存储，也可以顺序存储</p>
<p>链式存储方式就用指针，顺序存储的方式就是用数组</p>
<p>遍历数组存储的二叉树：左孩子是i * 2+1，右孩子是i * 2+2</p>
<h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h4><p>1.深度优先遍历</p>
<p>前序遍历（递归法，迭代法）</p>
<p>中序遍历（递归法，迭代法）</p>
<p>后序遍历（递归法，迭代法）</p>
<p>2.广度优先遍历</p>
<p>层次遍历（迭代法）</p>
<h4 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h4><p>链式存储</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct TreeNode&#123;
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x),left(NULL),right(NULL)&#123;&#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;前序遍历
class Solution&#123;
public:
    void traverval(TreeNode* cur, vector&lt;int&gt;&amp; vec)
    &#123;
        if(cur &#x3D;&#x3D; NULL) return;
        vec.push_back(cur-&gt;val);
        traverval(cur-&gt;left, vec);
        traverval(cur-&gt;right, vec);
    &#125;
    vector&lt;int&gt; preorderTraverval(TreeNode* root)
    &#123;
        vector&lt;int&gt; result;
        traverval(root, result);
        return result;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;中序遍历
void traverval(TreeNode* cur, vector&lt;int&gt;&amp; vec)     
&#123;         
    if(cur &#x3D;&#x3D; NULL) return;                  
    traverval(cur-&gt;left, vec); 
    vec.push_back(cur-&gt;val);
    traverval(cur-&gt;right, vec);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;后序遍历
void traverval(TreeNode* cur, vector&lt;int&gt;&amp; vec)     
&#123;         
    if(cur &#x3D;&#x3D; NULL) return;                  
    traverval(cur-&gt;left, vec); 
    traverval(cur-&gt;right, vec);
    vec.push_back(cur-&gt;val);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;
public:
    vector&lt;int&gt; preorderTraverval(TreeNode* root)
    &#123;
        stack&lt;TreeNode*&gt; st;
        vector&lt;int&gt; result;
        if(root &#x3D;&#x3D; NULL) return result;
        st.push(root);
        while(!st.empty)
        &#123;
            TreeNode* node &#x3D; st.top();
            st.pop();
            result.push_back(node-&gt;val);
            if(node-&gt;right) st.push-&gt;back(node-&gt;right);
            if(node-&gt;left) st.push_back(node-&gt;left);
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p><strong>借助指针访问结点，借助栈处理元素</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;
public:
    vector&lt;int&gt; inorderTraverval(TreeNode* root)
    &#123;
        vector&lt;int&gt; result;
        stack&lt;int&gt; st;
        TreeNode* cur &#x3D; root;
        while(cur !&#x3D; NULL || !st.empty())
        &#123;
            if(cur !&#x3D; NULL)
            &#123;
                st.push(cur);
                cur &#x3D; cur-&gt;left;
            &#125;
            else&#123;
                cur &#x3D; st.top();
                st.pop();
                result.push_back(cur-&gt;val);
                cur &#x3D; cur-&gt;right;
            &#125;
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;
public:
    vector postorderTraverval(TreeNode* root)
    &#123;
        vector&lt;int&gt; result;
        stack&lt;int&gt; st;
        if(root &#x3D;&#x3D; NULL) return result;
       st.push(root);
        while(!st.empty())
        &#123;
            TreeNode* node &#x3D; st.top();
            st.pop();
            result.push_back(node-&gt;val);
            if(node-&gt;left) st.push_back(node-&gt;val);
            if(node-&gt;right) st.push_back(node-&gt;val);
        &#125;
        reverese(result.begin(), result.end());
        return result;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="二叉树的统一迭代法"><a href="#二叉树的统一迭代法" class="headerlink" title="二叉树的统一迭代法"></a>二叉树的统一迭代法</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;
public:
    vector&lt;int&gt; inorderTraverval(TreeNode* root)
    &#123;
        vector&lt;int&gt; result;
        stack&lt;TreeNode*&gt; st;
        if(root &#x3D;&#x3D; NULL) return result;
        st.push(root);
        while(!st.empty())
        &#123;
            TreeNode* node &#x3D; st.top();
            if(node !&#x3D; NULL)
            &#123;
                st.pop();
                if(node-&gt;right) st.push(node-&gt;right);&#x2F;&#x2F;右结点入栈
                
                st.push(node);&#x2F;&#x2F;下一个要访问的结点入栈
                st.push(NULL);
                
                if(node-&gt;left) st.push(node-&gt;left);&#x2F;&#x2F;左结点入栈
                
                
            &#125;
            else&#123; &#x2F;&#x2F;当遇到空结点时
                st.pop(); &#x2F;&#x2F;弹出空结点
                node &#x3D; st.pop(); &#x2F;&#x2F;保存当前结点
                st.pop();
                result.push_back(node-&gt;val); &#x2F;&#x2F;空结点后的结点值加入结果集
            &#125;
            return result;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>前序遍历和后序遍历仅需改变三行代码的顺序即可实现</p>
<h3 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h3><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root)
    &#123;
        queue&lt;TreeNode*&gt; que;
        vector&lt;vector&lt;int&gt;&gt; result;
        if(node &#x3D;&#x3D; NULL) return result;
        que.push(root);
        while(!que.empty())
        &#123;
            int size &#x3D; que.size(); &#x2F;&#x2F;使用固定大小的size
            vector&lt;int&gt; vec;
            for(int i&#x3D;0;i &lt; size;i++)
            &#123;
                TreeNode* node &#x3D; que.front();
                que.pop();
                vec.push_back(node-&gt;val);
                if(node-&gt;left) que.push(node-&gt;left);
                if(node-&gt;right) que.push(node-&gt;right);
            &#125;
            result.push_back(vec);
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;递归法
class Solution&#123;
public:
    void order(TreeNode* cur, vector&lt;int&gt;&lt;int&gt;&amp; result, int depth)
    &#123;
        if(cur &#x3D;&#x3D; NULL) return;
        if(result.size()&#x3D;&#x3D;depth) result.push_back(vector&lt;int&gt;());
        result[depth].push_back(cur-&gt;val);
        order(cur-&gt;left, result, depth+1);
        order(cur-&gt;right, result, depth+1);
    &#125;
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root)
    &#123;
        vector&lt;vector&lt;int&gt;&gt; result;
        int depth &#x3D; 0;
        order(root, result, depth);
        return result;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="107-二叉树的层次遍历II"><a href="#107-二叉树的层次遍历II" class="headerlink" title="107.二叉树的层次遍历II"></a>107.二叉树的层次遍历II</h3><p> 在层次遍历的基础上将result反转</p>
<h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199.二叉树的右视图"></a>199.二叉树的右视图</h3><p>当每层遍历到结尾时，将结点的值放入结果集中</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;
public:
    vector&lt;int&gt; rightsideView(TreeNode* root)
    &#123;
        queue&lt;TreeNode*&gt; que;
        vector&lt;int&gt; result;
        if(root &#x3D;&#x3D; NULL) return result;
        que.push(root);
        while(!que.empty())
        &#123;
            int size &#x3D; que.size();
            for(int i&#x3D;0;i &lt; size;i++)
            &#123;
                TreeNode* node &#x3D; que.front();
                que.pop();
                if(i &#x3D;&#x3D; size - 1) result.push_back(node-&gt;val);
                if(node-&gt;left) que.push(node-&gt;left);
                if(node-&gt;right) que.push(node-&gt;right);
            &#125;
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637.二叉树的层平均值"></a>637.二叉树的层平均值</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;
public:
    vector&lt;double&gt; averageOfLevel(TreeNode* root)
    &#123;
        queue&lt;TreeNode*&gt; que;
        vector&lt;double&gt; result;
        if(root &#x3D;&#x3D; NULL) return result;
        que.push(root);
        while(!que.empty())
        &#123;
            int size &#x3D; que.size();
            double sum &#x3D; 0;
            for(int i&#x3D;0;i&lt;size;i++)
            &#123;
                TreeNode* node &#x3D; que.front();
                que.pop();
                sum +&#x3D; node-&gt;val;
                if(node-&gt;left) que.push(node-&gt;left);
                if(node-&gt;right) que.push(node-&gt;right);
            &#125;
            result.push_back(sum&#x2F;size);
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429.N叉树的层序遍历"></a>429.N叉树的层序遍历</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution
&#123;
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root)
    &#123;
        queue&lt;Node*&gt; que;
        vector&lt;vector&lt;int&gt;&gt; result;
        if(root !&#x3D; NULL)( que.push(root);
        while(!que.empty())
                         &#123;
                             int size &#x3D; que.size();
                             vector&lt;int&gt; vec;
                             for(int i&#x3D;0;i&lt;size;i++)
                             &#123;
                                 Node* node &#x3D; que.front();
                                 que.pop();
                                 vec.push_back(node-&gt;val);
                                 for(int i&#x3D;0;i&lt;node-&gt;children.size();i++)
                                 &#123;
                                     if(node-&gt;childrem[i]) que.push(node-&gt;children[i]);
                                 &#125;
                                 
                             &#125;
                             result.push_back(vec);
                         &#125;
                         return result;
    &#125;
                         
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515.在每个树行中找最大值"></a>515.在每个树行中找最大值</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution
&#123;
public:
    vector&lt;int&gt; largestValue(TreeNode* root)
    &#123;
        vector&lt;int&gt; result;
        queue&lt;int&gt; que;
        int maxx &#x3D; INT_MIN;
        if(root !&#x3D; NULL) que.push(root);
        while(!que.empty())
        &#123;
            int size &#x3D; que.size();
            for(int i&#x3D;0;i &lt; size;i++)
            &#123;
                TreeNode* node &#x3D; que.front();
                que.pop();
                max &#x3D; mode-&gt;val &gt; max ? max : val;
                if(node-&gt;right) que.push(node-&gt;right);
                if(node-&gt;left) que.push(node-&gt;left);
                
            &#125;
            result.push_back(max);
        &#125;
        return result;
        
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116.填充每个节点的下一个右侧节点指针"></a>116.填充每个节点的下一个右侧节点指针</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution
&#123;
public:
    Node* connect(Node* root)
    &#123;
        queue&lt;Node*&gt; que;
        if(root !&#x3D; NULL) que.push(root);
        Node* nodepre;
        Node* node;
        while(!que.empty())
        &#123;
            int size &#x3D; que.size();
            for(int i&#x3D;0;i &lt; size;i++)
            &#123;
                if(i &#x3D;&#x3D; 0)
                &#123;
                    nodepre &#x3D; que.front();
                    que.pop();
                    node &#x3D; nodepre;
                &#125;
                else
                &#123;
                    node &#x3D; que.front();
                    que.pop();
                    nodepre-&gt;next &#x3D; node;
                    nodepre &#x3D; nodepre-&gt;next;
                &#125;
                if(node-&gt;right) que.push(node-&gt;right);
                if(node-&gt;left) que.push(node-&gt;left);
            &#125;
            nodepre-&gt;next &#x3D; NULL;
        &#125;
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="117-填充每个节点的下一个右侧节点指针Ⅱ"><a href="#117-填充每个节点的下一个右侧节点指针Ⅱ" class="headerlink" title="117.填充每个节点的下一个右侧节点指针Ⅱ"></a>117.填充每个节点的下一个右侧节点指针Ⅱ</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    Node* connect(Node* root) &#123;
        queue&lt;Node*&gt; que;
        if (root !&#x3D; NULL) que.push(root);
        while (!que.empty()) &#123;
            int size &#x3D; que.size();
           
            Node* nodePre;
            Node* node;
            for (int i &#x3D; 0; i &lt; size; i++) &#123;
                if (i &#x3D;&#x3D; 0) &#123;
                    nodePre &#x3D; que.front(); &#x2F;&#x2F; 取出一层的头结点
                    que.pop();
                    node &#x3D; nodePre;
                &#125; else &#123;
                    node &#x3D; que.front();
                    que.pop();
                    nodePre-&gt;next &#x3D; node; &#x2F;&#x2F; 本层前一个节点next指向本节点
                    nodePre &#x3D; nodePre-&gt;next;
                &#125;
                if (node-&gt;left) que.push(node-&gt;left);
                if (node-&gt;right) que.push(node-&gt;right);
            &#125;
            nodePre-&gt;next &#x3D; NULL; &#x2F;&#x2F; 本层最后一个节点指向NULL
        &#125;
        return root;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="104-二叉树最大深度"><a href="#104-二叉树最大深度" class="headerlink" title="104.二叉树最大深度"></a>104.二叉树最大深度</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution
&#123;
public:
    int maxDepth(TreeNode* root)
    &#123;
        queue&lt;TreeNode*&gt; que;
        int depth &#x3D; 0;
        if(root !&#x3D; NULL) que.push(root);
        while(!que.empty())
        &#123;
            int size &#x3D; que.size();
            depth++;
            for(int i&#x3D;0;i &lt; size;i++)
            &#123;
                TreeNode* node &#x3D; que.front();
                que.pop();
                if(node-&gt;right) que.push(node-&gt;right);
                if(node-&gt;left) que.push(node-&gt;left);
            &#125;
            
        &#125;
        return depth;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minDepth(TreeNode* root) &#123;
        queue&lt;TreeNode*&gt; que;
        int depth &#x3D; 0;
        if(root !&#x3D; NULL) que.push(root);
        while(!que.empty())
        &#123;
            int size &#x3D; que.size();
            depth++;
            for(int i&#x3D;0;i &lt; size;i++)
            &#123;
                TreeNode* node &#x3D; que.front();
                que.pop();
                if(!node-&gt;right &amp;&amp; !node-&gt;left) return depth;
                if(node-&gt;right) que.push(node-&gt;right);
                if(node-&gt;left) que.push(node-&gt;left);
            &#125;
        &#125;
        return depth;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="226-反转二叉树"><a href="#226-反转二叉树" class="headerlink" title="226.反转二叉树"></a>226.反转二叉树</h3><p><strong>递归法</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;
public:
    TreeNode* invertTree(TreeNode* root)&#123;
        if(root &#x3D;&#x3D; NULL) return root;
        swap(root-&gt;left, root-&gt;right);
        invertTree(root-&gt;right);
        invertTree(root-&gt;left);
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>迭代法</strong></p>
<p><strong>深度优先遍历</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;
public:
    TreeNode* invertTree(TreeNode* root)
    &#123;
        if(root &#x3D;&#x3D; NULL) return root;
        stack&lt;TreeNode*&gt; st;
        st.push(root);
        while(!st.empty())
        &#123;
            TreeNode* node &#x3D; st.top();
            st.pop();
            swap(node-&gt;left, node-&gt;right);
            if(node-&gt;right) st.push(node-&gt;right);
            if(node-&gt;left) st.push(node-&gt;left);
            
        &#125;
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>广度优先遍历</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;
public:
    TreeNode* invertTree(TreeNode* root)
    &#123;
        queue&lt;TreeNode*&gt; que;
        if(root !&#x3D; NULL) que.push(root);
        while(!que.empty())
        &#123;
            int size &#x3D; que.size();
            for(int i&#x3D;0;i &lt; size;i++)
            &#123;
                TreeNode* node &#x3D; que.front();
                que.pop();
                swap(node-&gt;left, node-&gt;right);
                if(node-&gt;left) que.push(node-&gt;left);
                if(node-&gt;right) que.push(node-&gt;right);
            &#125;
        &#125;
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h3><p>递归法</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;
public:
    bool compare(TreeNode* left, TreeNode* right)
    &#123;
        if(left !&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL) return false;
        else if(left &#x3D;&#x3D; NULL &amp;&amp; right !&#x3D; NULL) return false;
        else if(left &#x3D;&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL) return true;
        else if(left-&gt;val !&#x3D; right-&gt;val) return false;
        
        bool outside &#x3D; compare(left-&gt;left, right-&gt;right);
        bool inside &#x3D; compare(left-&gt;right, right-&gt;left);
        bool isSame &#x3D; outside &amp;&amp; inside;
        return isSame;
    &#125;
    bool isSysmmetric(TreeNode* root)
    &#123;
        if(root &#x3D;&#x3D; NULL) return true;
        return compare(root-&gt;left, root-&gt;right);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-06-25</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://realhuameng.github.io/2023/06/25/suan-fa-shua-ti-ji-lu-er-cha-shu/,Realhuameng,算法刷题记录—二叉树,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2023/06/25/suan-fa-shua-ti-ji-lu-shuang-zhi-zhen-fa/" title="算法刷题记录—双指针法">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2023/06/25/suan-fa-shua-ti-ji-lu-ha-xi-biao/" title="算法刷题记录-哈希表">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>