<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Hua Meng,1263313190@qq.com"><title>算法刷题记录-动态规划 · Realhuameng</title><meta name="description" content="理论基础什么是动态规划（Dynamic Programming）动态规划用于解决有很多子问题的问题
动态规划中每一个状态一定是由上一个状态推导出来的
解题步骤1.确定dp数组以及下标的含义
2.确定递推公式
3.dp数组如何初始化
4.确定遍历顺序
5.举例推导dp数组
509.斐波那契数动态规划
"><meta name="keywords" content="C++,Linux,Java,Go"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Realhuameng</a></h3><div class="description"><p>Fake it till you make it.</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="http://github.com/realhuameng"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首頁</a></li><li><a href="/about">關於</a></li><li><a href="/archives">歸檔</a></li><li><a href="/links">連結</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/favicon.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>算法刷题记录-动态规划</a></h3></div><div class="post-content"><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><h4 id="什么是动态规划（Dynamic-Programming）"><a href="#什么是动态规划（Dynamic-Programming）" class="headerlink" title="什么是动态规划（Dynamic Programming）"></a>什么是动态规划（Dynamic Programming）</h4><p>动态规划用于解决有很多子问题的问题</p>
<p>动态规划中每一个状态一定是由上一个状态推导出来的</p>
<h4 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h4><p>1.确定dp数组以及下标的含义</p>
<p>2.确定递推公式</p>
<p>3.dp数组如何初始化</p>
<p>4.确定遍历顺序</p>
<p>5.举例推导dp数组</p>
<h3 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509.斐波那契数"></a>509.斐波那契数</h3><p><strong>动态规划</strong></p>
<p>1.确定dp数组以及下标的含义</p>
<p>dp[i]的定义是：第i个数的斐波那契数值是dp[i]</p>
<p>2.确定递推公式</p>
<p><strong>状态转移方程 dp[i] &#x3D; dp[i-1] + dp[i-2]</strong></p>
<p>3.dp数组如何初始化</p>
<p>本题初始化条件 dp[0]&#x3D;0, dp[1]&#x3D;1</p>
<p>4.确定遍历顺序</p>
<p>dp[i]依赖dp[i-1], dp[i-2]</p>
<p>那么遍历的顺序一定是从前向后遍历的</p>
<p>5.举例推导dp数组</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int fib(int n)
&#123;
    if(n&lt;&#x3D;1) return n;
    vector&lt;int&gt; dp(n+1);
    dp[0]&#x3D;0; dp[1]&#x3D;1;
    for(int i&#x3D;1;i&lt;&#x3D;n;i++)
    &#123;
        dp[i] &#x3D; dp[i-1]+dp[i-2];
    &#125;
    return dp[n];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h3><p>1.确定dp数组以及下标的含义</p>
<p>dp[i]:爬到第i层楼梯由dp[i]种方法</p>
<p>2.确定递推公式</p>
<p>若要上到第i阶台阶，最后一步一定是从第i-1阶或第i-2阶上到第i阶</p>
<p>那么可知</p>
<p>递推公式为dp[i] &#x3D; dp[i-1] dp[i-2]</p>
<p>3.dp数组如何初始化</p>
<p>dp[1] &#x3D; 1</p>
<p>dp[2] &#x3D; 2</p>
<p>4.确定遍历顺序</p>
<p>从前向后</p>
<p>5.举例推导dp数组</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int climbStairs(int n)&#123;
    if(n &lt;&#x3D; 1) return n;
    vector&lt;int&gt; dp(n+1);
    dp[1] &#x3D; 1;
    dp[2] &#x3D; 2;
    for(int i&#x3D;3;i&lt;&#x3D;n;i++)
    &#123;
        dp[i] &#x3D; dp[i-1] - dp[i-2];
    &#125;
    return dp[n];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746.使用最小花费爬楼梯"></a>746.使用最小花费爬楼梯</h3><p>1.确定dp数组以及下标的含义</p>
<p>到达第i台阶所花费最少体力为dp[i]</p>
<p>2.确定递推公式</p>
<p>dp[i] &#x3D; min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])</p>
<p>3.dp数组初始化</p>
<p>dp[0] &#x3D; 0</p>
<p>dp[1] &#x3D; 0</p>
<p>4.确定遍历顺序</p>
<p>5.举例推导dp数组</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int minCostClimbingStairs(vecror&lt;int&gt;&amp; cost)
&#123;
    vector&lt;int&gt; dp(cost,size());
    dp[0] &#x3D; 0;
    dp[1] &#x3D; 0;
    for(int i&#x3D;2;i&lt;cost.size();i++)
    &#123;
        dp[i] &#x3D; min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]);
    &#125;
    return dp[cost.size()];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h3><p>1.确定dp数组以及下标含义</p>
<p>从（0，0）出发，到（i，j）的路径数</p>
<p>2.确定递推公式</p>
<p>dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]</p>
<p>3.dp数组初始化</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i&#x3D;0;i&lt;m;i++) dp[i][0] &#x3D; 1;
for(int j&#x3D;0;j&lt;n;j++) dp[0][j] &#x3D; 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>4.确定遍历顺序</p>
<p>从左至右一层一层遍历</p>
<p>5.举例推导</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int uniquePath(int m, int n)&#123;
    vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n, 0));
    for(int i&#x3D;0;i&lt;m;i++) dp[i][0] &#x3D; 1;
    for(int j&#x3D;0;j&lt;n;j++) dp[0][j] &#x3D; 1;
    for(int i&#x3D;1;i&lt;m;i++)
    &#123;
        for(int j&#x3D;1;j&lt;n;j++)
        &#123;
            dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];
        &#125;
        return dp[m-1][n-1];
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="63-不同路径Ⅱ"><a href="#63-不同路径Ⅱ" class="headerlink" title="63.不同路径Ⅱ"></a>63.不同路径Ⅱ</h3><p>1.确定dp数组以及下标含义</p>
<p>含义与上一题相同</p>
<p>2.确定递推公式</p>
<p>如果有障碍，路径数应为0</p>
<p>3.dp数组初始化</p>
<p>与上一题类似，障碍前的路径数都为1，障碍后的都为0</p>
<p>4.确定遍历顺序</p>
<p>从左到右一层一层遍历</p>
<p>5.举例推导dp数组</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid)
&#123;
    int m &#x3D; obstacleGrid.size();
    int n &#x3D; obstacleGrid[0].size();
    if (obstacleGrid[m - 1][n - 1] &#x3D;&#x3D; 1 || obstacleGrid[0][0] &#x3D;&#x3D; 1) &#x2F;&#x2F;如果在起点或终点出现了障碍，直接返回0            
    return 0;
    
    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n,0));
    for(int i&#x3D;0;i&lt;m &amp;&amp; obstacleGrid[i][0]&#x3D;&#x3D;0;i++) dp[i][0] &#x3D; 1;
    for(int j&#x3D;0lj&lt;n &amp;&amp; obstacleGrid[0][j]&#x3D;&#x3D;0;j++) dp[0][j] &#x3D; 1;
    for(int i&#x3D;1;i&lt;m;i++)
    &#123;
        for(int j&#x3D;1;j&lt;n;j++)
        &#123;
            if(obstacleGrid[i][j]&#x3D;&#x3D;1) contine;
            dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];
        &#125;
    &#125;
    return dp[m-1][n-1];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343.整数拆分"></a>343.整数拆分</h3><ol>
<li></li>
</ol>
<p>2.确定递推公式</p>
<p>从1遍历j，有两种渠道得到dp[i]</p>
<p>一个是j*(i-j)直接相乘</p>
<p>一个是j*dp[i-j],相当于拆分(i-j)</p>
<p>3.dp初始化</p>
<p>dp[2] &#x3D; 1</p>
<p>4.确定遍历顺序</p>
<p>从前向后</p>
<p>5.举例推导</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int integerBreak(int n)
&#123;
    vector&lt;int&gt; dp(n+1);
    dp[2] &#x3D; 1;
    for(int i&#x3D;3;i&lt;&#x3D;n;i++)
    &#123;
        for(int j&#x3D;1;j&lt;&#x3D;i&#x2F;2;j++)
        &#123;
            dp[i]&#x3D;max(dp[i],max((i-j)*j, dp[i-j]*j));
&#125;
    &#125;
    return dp[n];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="01背包理论基础"><a href="#01背包理论基础" class="headerlink" title="01背包理论基础"></a>01背包理论基础</h3><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p>有n件物品和一个最多能背重量为w的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。每件物品只能使用一次，求解将哪些物品装入背包里价值总和最大。</p>
<h4 id="二维dp数组01背包"><a href="#二维dp数组01背包" class="headerlink" title="二维dp数组01背包"></a>二维dp数组01背包</h4><p>1.确定dp数组以及下标含义</p>
<p><strong>dp[i] [j]表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong></p>
<p>2.确定递推公式</p>
<p>可以有两个方向推出dp[i] [j]</p>
<p><strong>不放物品i：</strong>由dp[i-1] [j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i] [j]就是dp[i-1] [j]。</p>
<p><strong>放物品i：</strong>由dp[i-1] [j-weight[i]]推出，**dp[i-1] [j-weight[i]]<strong>为背包容量为</strong>j-weight[i]<strong>的时候不放物品i的最大价值，那么</strong>dp[i-1] [j-weight[i]+value[i]]**，就是背包放物品i得到的最大价值。</p>
<p>所以递推公式为</p>
<p><strong>dp[i] [j] &#x3D; max(dp[i-1] [j], dp[i-1] [j-weight[i]]+value[i])</strong></p>
<p>3.dp数组如何初始化</p>
<p>背包容量j为0的话，即dp[i] [0]，无论选取哪些物品，背包价值总和一定为0</p>
<p>当i为零时</p>
<p>j&lt;weight[0]时，dp[0] [j]应该是0</p>
<p>当j &gt;&#x3D; weight[0]时，dp[0] [j]应该是value[0]</p>
<p>4.确定遍历顺序</p>
<p>先遍历物品或者先遍历背包都可以</p>
<p>先遍历物品的代码</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i&#x3D;1;i&lt;weight.size();i++)
&#123;
    for(int j&#x3D;0;j &lt;&#x3D; bagweight;j++)
    &#123;
        if(j&lt;weight)
            dp[i][j] &#x3D; dp[i-1][j];
        
        else
            dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i]);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>先遍历背包的代码</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int j&#x3D;0;j &lt;&#x3D; bagweight;j++)
&#123;
    for(int i&#x3D;1;i &lt; weight.size();i++)
    &#123;
        if(j &lt; weight[i])
            dp[i][j] &#x3D; dp[i-1][j];
        else
            dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i]);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>完整代码</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void bag01()
&#123;
    vector&lt;int&gt; weight &#x3D; &#123;1,3,4&#125;;
    vector&lt;int&gt; value &#x3D; &#123;15,20,30&#125;;
    int bagweight &#x3D;  4;
    
    vector&lt;vector&lt;int&gt;&gt; dp(weight.size(), vector&lt;int&gt;(bagweight + 1, 0));
    
    for(int j &#x3D; weight[0];j &lt;&#x3D; bagweight;j++)
    &#123;
        dp[0][j] &#x3D; value[0];
    &#125;
    
    for(int i&#x3D;1;i&lt;weight.size();i++)
    &#123;
        for(int j&#x3D;0;j&lt;&#x3D;bagweight;j++)
        &#123;
         	if(j &lt; weight[i])   
                dp[i][j] &#x3D; dp[i-1][j];
            else
                dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i]);
        &#125;
    &#125;
    cout&lt;&lt;dp[weight.size() - 1][bagweight]&lt;&lt;endl;
&#125;
int main()
&#123;
    bag01();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="01背包理论基础（滚动数组）"><a href="#01背包理论基础（滚动数组）" class="headerlink" title="01背包理论基础（滚动数组）"></a>01背包理论基础（滚动数组）</h3><h4 id="一维dp数组（滚动数组）"><a href="#一维dp数组（滚动数组）" class="headerlink" title="一维dp数组（滚动数组）"></a>一维dp数组（滚动数组）</h4><p> 如果把dp[i-1]那一层拷贝到dp[i]上，表达式可以是：dp[i] [j] &#x3D; max(dp[i] [j], dp[i] [j - weight[i]] + value[i])</p>
<p>可以直接改为一个一维数组</p>
<p>1.确定dp数组的定义 </p>
<p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p>
<p>2.一维数组的递推公式</p>
<p>dp[j]为容量为j的背包所背的最大价值</p>
<p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值</p>
<p>dp[j - weight[i]] + value[i]表示容量为j - 物品i重量的背包 + 物品i的价值</p>
<p>即 容量为j的背包，放入了物品i了之后的价值即：dp[j]</p>
<p>此时，dp[j]有两个选择，</p>
<p>一个是 不放物品i，值取自己，相当于dp[i-1] [j]</p>
<p>一个是 放入物品i，值取dp[j - weight[i]] + value[i]</p>
<p>递推公式为</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>3.一维dp数组如何初始化</p>
<p>dp[0] &#x3D; 0</p>
<p>dp数组在推导的时候一定是取价值最大的数，要比题目给的价值小，这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖</p>
<p>4.一维dp数组遍历顺序</p>
<p><strong>一维dp遍历背包应该从大到小遍历（倒序遍历）</strong></p>
<p>在二维数组中，右下角的值依赖上一层左上角的值，因此需要保证左边的值仍是上一层的，从右向左覆盖</p>
<p><strong>倒序遍历保证物品i只被放入一次</strong></p>
<p><strong>必须先遍历物品再遍历背包容量</strong></p>
<p>如果背包遍历放在上一层，那么每个dp[j]就只会放入一个物品</p>
<p>5.举例推导</p>
<p>完整代码</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void bag01_Onedimensional()
&#123;
    vector&lt;int&gt; weight &#x3D; &#123;1,3,4&#125;;
    vector&lt;int&gt; value - &#123;15,20,30&#125;;
    int bagweight &#x3D; 4;
    
    vector&lt;int&gt; dp(bagweight +1,0);
    for(int i&#x3D;0;i &lt; weight.size();i++)
    &#123;
        for(int j&#x3D;bagweight;j &gt;&#x3D; weight[i];j--)
        &#123;
            dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);
        &#125;
    &#125;
    cout&lt;&lt;dp[bagweight]&lt;&lt;endl;
&#125;
int main()
&#123;
    baag01_Onedimensional();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-06-25</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://realhuameng.github.io/2023/06/25/suan-fa-shua-ti-ji-lu-dong-tai-gui-hua/,Realhuameng,算法刷题记录-动态规划,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2023/06/25/suan-fa-shua-ti-ji-lu-ha-xi-biao/" title="算法刷题记录-哈希表">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-di-si-zhang/" title="汇编语言（第三版）王爽—第四章">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>