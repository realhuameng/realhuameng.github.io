<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java学习</title>
      <link href="/2023/10/11/java-xue-xi/"/>
      <url>/2023/10/11/java-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>此篇笔记只记录部分细节和重要内容</p><h3 id="Java文档注释"><a href="#Java文档注释" class="headerlink" title="Java文档注释"></a>Java文档注释</h3><p>注释内容可以被JDK提供的工具javadoc所解析</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">javadoc <span class="token parameter variable">-d</span> 文件夹名 <span class="token parameter variable">-xx</span> <span class="token parameter variable">-yy</span> Demo.java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>一些可使用的javadoc标签：</p><p>@author：标识一个类的作者</p><p>@deprecated：指明一个过期的类成员</p><p>@docRoot：指明当前文档根目录的路径</p><p>@exception：标志一个类抛出的异常</p><p>@inheritDoc：从父类继承的注释</p><p>@link：插入到另一个主题的链接</p><p>@param：说明一个方法的参数</p><p>……</p></blockquote><h3 id="Java代码规范"><a href="#Java代码规范" class="headerlink" title="Java代码规范"></a>Java代码规范</h3><ul><li>对于类、方法的注释，用javadoc来写</li><li>&#x3D;&#x3D;shift+tab：整体右移&#x3D;&#x3D;</li></ul><p>……</p><h3 id="Java可变参数"><a href="#Java可变参数" class="headerlink" title="Java可变参数"></a>Java可变参数</h3><p>Java允许将同一个类中的多个同名同功能的但是参数个数不同的方法，封装成一个方法</p><p><strong>基本语法</strong></p><p>访问修饰符 返回类型 方法名（数据类型… 形参名）{</p><p>}</p><blockquote><p>可变参数的实参可以为0个或任意多个</p><p>可变参数的实参可以为数组</p><p>可变参数的本质就是数组</p><p>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后</p><p>一个形参列表中只能出现一个可变参数</p></blockquote><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>主要作用：完成新对象的初始化</p><p>[修饰符] 方法名(形参列表)</p><p>​方法体；</p><p><em>构造方法没有返回值</em></p><p><em>方法名必须与类名相同</em></p><p><em>可以重载</em></p><p><em>默认构造器被覆盖后不能继续使用</em></p><p><strong>对象的初始化顺序</strong></p><p>1.默认初始化</p><p>2.显式初始化</p><p>3.构造方法初始化</p><h3 id="Javap"><a href="#Javap" class="headerlink" title="Javap"></a>Javap</h3><p>对指定的class文件进行反编译</p><p><strong>使用格式</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">javap <span class="token operator">&lt;</span>options<span class="token operator">></span> <span class="token operator">&lt;</span>classes<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>常用命令</p><p>-c：对代码进行反汇编</p><p>-v -verbose：输出附加信息</p><p>-p -private：显示所有类和成员</p></blockquote><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>this关键字可以用来访问本类的属性、方法、构造器</p><p>this用于区分当前类的属性和局部变量</p><p>语法：this(参数列表)，只在构造器中使用（<strong>必须放在第一条语句</strong>）</p><p>只能在类定义的方法中使用</p><h3 id="常用包"><a href="#常用包" class="headerlink" title="常用包"></a>常用包</h3><p>java.lang：默认引入</p><p>java.util：工具包</p><p>java.net：网络包</p><p>java.awt：界面开发GUI</p><h3 id="面向对象编程—封装"><a href="#面向对象编程—封装" class="headerlink" title="面向对象编程—封装"></a>面向对象编程—封装</h3><p>（1）将属性进行私有化</p><p>（2）提供一个公共的set方法，用于对属性判断并赋值</p><p>（3）提供一个公共的get方法用于获取属性的值</p><p><em>可以将构造器与setXxx结合来实现对属性的控制</em></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>&#x3D;&#x3D;ctrl+H快速查看继承关系&#x3D;&#x3D;</p><p>&#x3D;&#x3D;ctrl+B快速定位&#x3D;&#x3D;</p><blockquote><p>1.子类必须调用父类的构造器，完成父类的初始化</p><p>2.创建子类对象时，不管使用子类的哪个构造器，默认调用父类的午餐&#x3D;&#x3D;无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作</p><p>3.super在使用时必须放下在构造器的第一行且只能在构造器中使用</p><p>4.super和this都只能放在构造器中的第一行</p><p>5.java所有类都是Object类的子类</p><p>6.父类构造器的调用不限于直接父类</p><p>7.Java中是单继承机制</p></blockquote><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>super代表父类的引用，用于访问父类属性的方法、属性、构造器</p><blockquote><p>super.属性名</p><p>访问父类的属性，但不能访问私有属性</p><p>super.方法名</p><p>访问父类的方法，但不能访问私有方法</p><p>super(参数列表)</p><p>访问父类的构造器，只能放在第一句，只能出现一句</p><p>super的访问不限于父类，遵循就近原则</p></blockquote><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ol><li><p>方法的重写和重载</p></li><li><p>一个对象的编译类型和运行类型可以不一致</p><p>父类引用指向子类对象</p></li><li><p>编译类型是确定的，运行类型可以改变</p></li><li><p>编译类型看&#x3D;左边，运行类型看&#x3D;右边</p></li><li><p>向上转型</p></li><li><p>向下转型</p><p>子类类型 引用名&#x3D;（子类类型）父类引用</p><p>只能强转父类引用</p><p>要求父类引用必须指向的是当前目标类型的对象</p><p>可以调用子类类型中的所有成员</p></li><li><p>属性不能重写，直接看编译类型</p></li><li><p>instanceOf比较操作符，用于判断对象的类型是否是某类型或为某类型的子类型</p></li></ol><h3 id="Java的动态绑定机制"><a href="#Java的动态绑定机制" class="headerlink" title="Java的动态绑定机制"></a>Java的动态绑定机制</h3><ol><li>当&#x3D;&#x3D;调用对象方法&#x3D;&#x3D;的时候，该方法会和该对象的内存地址&#x2F;运行类型绑定</li><li>当&#x3D;&#x3D;调用对象属性&#x3D;&#x3D;时，&#x3D;&#x3D;没有动态绑定机制&#x3D;&#x3D;，哪里声明，哪里使用</li></ol><h3 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a>多态数组</h3><p>数组的定义类型为父类类型，数组内保存的元素实际为子类类型</p><p>当需要调用子类的特有方法时，要先将父类类型向下转型为子类类型后再进行调用</p><h3 id="多态参数"><a href="#多态参数" class="headerlink" title="多态参数"></a>多态参数</h3><p>方法定义的形参类型为父类类型，实参类型允许为子类类型</p><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>&#x3D;&#x3D;equals方法&#x3D;&#x3D;</p><p>默认判断的是地址是否相等，子类中往往重写该方法，用于判断&#x3D;&#x3D;内容&#x3D;&#x3D;是否相等</p><blockquote><p>&#x3D;&#x3D;与equals的对比：</p><p>&#x3D;&#x3D;既可以判断基本类型也可以判断引用类型</p><p>equals是object的方法，只能判断引用类型</p></blockquote><p>由于person并没有重写equals方法，所以最后一条语句返回False</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-25%20140624.png"></p><p>&#x3D;&#x3D;hashcode&#x3D;&#x3D;</p><ul><li>提高哈希结构容器的效率</li><li>两个指向同一对象的引用，哈希值相同</li><li>集合中也可以重写hashcode方法</li></ul><p>&#x3D;&#x3D;toString&#x3D;&#x3D;</p><p>返回对象的字符串表示</p><p>默认返回：全类名( getclass()+getname() 包名+类名 )+@+哈希值的十六进制( Integer.toHexString(hashCode()) )</p><p>子类往往重写toString方法，用于返回对象的信息</p><p><strong>使用快捷键alt+insert-&gt;toString</strong></p><p>直接输出一个对象时，会默认调用toString方法</p><p>&#x3D;&#x3D;finalize&#x3D;&#x3D;</p><p>当垃圾回收器不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法</p><p>子类可以重写该方法来做一些释放资源的操作</p><p>垃圾回收机制的调用是由系统来决定，也可以通过System.gc()主动触发垃圾回收机制</p><p>finalize方法也可快捷键直接生成</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Acwing算法基础课</title>
      <link href="/2023/09/20/acwing-suan-fa-ji-chu-ke/"/>
      <url>/2023/09/20/acwing-suan-fa-ji-chu-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p><a href="https://www.acwing.com/activity/content/problem/content/819/">题目链接：785.快速排序</a></p><p>快排算法基于<strong>分治策略</strong></p><ol><li><p>确定分界点x</p><p>取左边界、右边界、中间值、随机值都可以</p></li><li><p>调整区间</p><p>划分为两个区间（<strong>分界点不一定是x</strong>）</p><p>小于等于x的数在左区间</p><p>大于等于x的数在右区间</p></li><li><p>递归的处理左右两区间</p></li></ol><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void quick_sort(int q[], int l,int r)&#123;    int i &#x3D; l - 1, j &#x3D; r + 1;    int x &#x3D; q[l];    while(i &lt; j)    &#123;        do i++; while(q[i] &lt; x);        do j--; while(q[j] &gt; x);        if(i &lt; j) swap(q[i], q[j]);    &#125;    quick_sort(q, l, j);    quick_sort(q, j + 1;r);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><a href="https://www.acwing.com/activity/content/problem/content/821/">题目链接：787.归并排序</a><br>$$<br>O(nlogn)<br>$$</p><p>归并排序算法也是基于<strong>分治策略</strong></p><ol><li>以中间为分界点 <em>mid &#x3D; (l+r)&#x2F;2</em></li><li>递归排序左区间右区间</li><li>归并两个有序区间</li></ol><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void merge_sort(int q[], int l, int r)&#123;    if(l &gt;&#x3D; r) return;    int mid &#x3D; l + r &gt;&gt; 1;    merge_sort(q, l, mid);    merge_sort(q, mid + 1, r);        int k &#x3D; 0, i &#x3D; l, j &#x3D; mid + 1;    while(i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)        if(q[i] &lt;&#x3D; q[j]) tmp[k++] &#x3D; q[i++];    else tmp[k++] &#x3D; q[j++];    while(i &lt;&#x3D; mid) tmp[k++] &#x3D; q[i++];    while(j &lt;&#x3D; r) tmp[k++] &#x3D; q[j++];        for(i &#x3D; l, j &#x3D; 0;i &lt;&#x3D; r;i++, j++)        q[i] &#x3D; tmp[j];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>快排是不稳定的，归并是稳定的</p><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p><a href="https://www.acwing.com/activity/content/problem/content/823/">题目链接：789.数的范围</a></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-22%20183215.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int bsearch_1(int l, int r)&#123;    while(l &lt; r)    &#123;        int mid &#x3D; l+r &gt;&gt; 1;        if(check(mid)) r &#x3D; mid;        else l &#x3D; mid + 1;            &#125;    return 1;&#125;int bsearch_2(int l, int r)&#123;    while(l &lt; r)    &#123;        int mid &#x3D; l + r + 1 &gt;&gt;1;        if(check(mid)) l &#x3D; mid;        else r &#x3D; mid -1;    &#125;    return 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><a href="https://www.acwing.com/activity/content/problem/content/824/">题目链接：790.数的三次方根</a></p><p>浮点数二分无需处理边界</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double bsearch_3(int l, int r)&#123;    const double eps &#x3D; 1e-6; &#x2F;&#x2F;精度要求    while(r-1&gt;eps)    &#123;        double mid &#x3D; (l+r)&#x2F;2;        if(check(mid)) r &#x3D; mid;        else l&#x3D;mid;    &#125;    return 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><p>用数组存储大整数，个位先存，即存储在数组下标为0的位置，十位存在1，以此类推</p><h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;    int t;    for(int i&#x3D;0;i&lt;A.size() || i&lt;B.size();i++)    &#123;        if(i&lt;A.size()) t+&#x3D;A[i];        if(i&lt;B.size()) t+&#x3D;B[i];        C.push_back(t%10);        t&#x2F;&#x3D;10;    &#125;    if(t) C.push_back(1);    return C;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-24%20155127.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt;  sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;    for(int i&#x3D;0,t&#x3D;0;i&lt;A.size();i++)    &#123;        t &#x3D; A[i]-t;        if(i&lt;B.size()) t-&#x3D;B[i];        C.push_back((t+10)%10);        if(t&lt;0) t&#x3D;1;        else t&#x3D;0;    &#125;    while(C.size()&gt;1 &amp;&amp; C.back()&#x3D;&#x3D;0) C.pop_back();    return C;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)&#123;    vector&lt;int&gt; C;    int t&#x3D;0;    for(int i&#x3D;0;i&lt;A.size() || t;i++)    &#123;        if(i &lt; A.size()) t+&#x3D;A[i]*b;        C.push_back(t%10);        t&#x2F;&#x3D;10;    &#125;    return C;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123;    vector&lt;int&gt; C;    r&#x3D;0;    for(int i&#x3D;0;i&#x3D;A.size()-1;i--)    &#123;        r &#x3D; r*10 + A[i];        C.push_back(r &#x2F; b);        r%&#x3D;b;    &#125;    reverse(C.begin(), C.end());    while(C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();    return C;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h2><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-24%20164847.png"></p><h3 id="子矩阵的和"><a href="#子矩阵的和" class="headerlink" title="子矩阵的和"></a>子矩阵的和</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-24%20181723.png"></p><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p>一维差分</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-25%20200510.png"></p><p>注意此处代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i&#x3D;1;i&lt;&#x3D;n;i++) insert(i, i, a[i]);&#x2F;&#x2F;假定a数组最开始都是0，那么b数组初始时就是a数组的差分数组&#x2F;&#x2F;对于每一个a[i]，相当于插入了一个数，可以直接调用insert函数即可<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="差分矩阵"><a href="#差分矩阵" class="headerlink" title="差分矩阵"></a>差分矩阵</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-25%20210003.png"></p><h3 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h3><h4 id="利用i与j的单调关系来降低时间复杂度"><a href="#利用i与j的单调关系来降低时间复杂度" class="headerlink" title="利用i与j的单调关系来降低时间复杂度"></a>利用i与j的单调关系来降低时间复杂度</h4><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-16%20133432.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-16%20134034.png"></p><h4 id="最长连续不重复子序列问题"><a href="#最长连续不重复子序列问题" class="headerlink" title="最长连续不重复子序列问题"></a>最长连续不重复子序列问题</h4><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-16%20143727.png"></p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h4 id="n的二进制表示中，第k位是几"><a href="#n的二进制表示中，第k位是几" class="headerlink" title="n的二进制表示中，第k位是几"></a>n的二进制表示中，第k位是几</h4><ol><li>先把第k位移到最后一位 x&gt;&gt;K</li><li>看个位是几 x&amp;1</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()&#123;    int n&#x3D;10;    for(int k&#x3D;3;k&gt;&#x3D;0;k--) cout&lt;&lt;(n &gt;&gt; k &amp; 1); &#x2F;&#x2F;输出1010&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="lowbit-x-：返回x的最后一位"><a href="#lowbit-x-：返回x的最后一位" class="headerlink" title="**lowbit(x)**：返回x的最后一位"></a>**lowbit(x)**：返回x的最后一位</h4><p><strong>原理：x&amp;-x &#x3D; x&amp;(~x+1)</strong></p><p>x&#x3D;1010 </p><p><em>lowbit</em>(x)&#x3D;10</p><p>x&#x3D;101000</p><p><em>lowbit</em>(x)&#x3D;1000</p><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>只用到大量数据之间的相对关系</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-16%20161646.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-16%20161640.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; alls; &#x2F;&#x2F;存储所有待离散化的值sort(alls.begins(), alls.end());alls.erase(unique(alls.begin(), alls.end()), alls.end()); &#x2F;&#x2F;去重&#x2F;&#x2F;二分求出x对应的离散化的值int find(int x)&#123;    int l&#x3D;0, i&#x3D;alls.size()-1;    while(l&lt;r)    &#123;        int mid &#x3D; l + r &gt;&gt; 1;        if(alls[mid]&gt;&#x3D;x) r&#x3D;mid;        else l &#x3D; mid + 1;    &#125;    return r + 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-16%20171937.png"></p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="1-链表与邻接表"><a href="#1-链表与邻接表" class="headerlink" title="1.链表与邻接表"></a>1.链表与邻接表</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>邻接表：存储图和树</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-25%20163719.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;定义：head：头节点下标，e：节点i的值，ne：next指针，idx：当前节点int head, e[N], ne[N], idx; &#x2F;&#x2F;初始化void init()&#123;    head &#x3D; -1;    idx &#x3D; 0;&#125;&#x2F;&#x2F;插入头节点后void add_to_head(int x)&#123;    e[idx] &#x3D; x;    ne[idx] &#x3D; head;    head &#x3D; idx;    idx++;&#125;&#x2F;&#x2F;插入到下标为k的节点后void add(int k, int x)&#123;    e[idx] &#x3D; x;    ne[idx] &#x3D; ne[k];    ne[k] &#x3D; idx;    idx++;&#125;&#x2F;&#x2F;删除下标为k节点后的节点void remove(int x)&#123;    ne[k] &#x3D; ne[ne[k]];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>优化某些问题</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【MIT6.S081】-Lab3</title>
      <link href="/2023/09/19/mit6.s081-lab3/"/>
      <url>/2023/09/19/mit6.s081-lab3/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-page-tables"><a href="#Lab-page-tables" class="headerlink" title="Lab: page tables"></a>Lab: page tables</h1><p>在本实验中，您将探索页表并修改它们以简化将数据从用户空间复制到内核空间的功能。</p><blockquote><p>在开始编码之前，请阅读xv6书的第3章以及相关文件：</p><ul><li>kern&#x2F;memlayout.h，它描述了内存的布局。 </li><li>kern&#x2F;vm.c，其中包含大部分虚拟内存（VM）代码。 </li><li>kernel&#x2F;kalloc.c，其中包含用于分配和释放物理内存的代码。</li></ul></blockquote><p>切换到pgtbl分支来开始实验</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> fetch$ <span class="token function">git</span> checkout pgtbl$ <span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h3><p>帮助你学习RISC-V页表，并可能帮助未来的调试，你的第一个任务是编写一个打印页表内容的函数。</p><blockquote><p>定义一个名为vmprint()的函数。它应该接受一个pagetable_t参数，并以下面描述的格式打印该pagetable。</p><p>在exec.c中，在return argc之前插入if(p-&gt;pid&#x3D;&#x3D;1) vmprint(p-&gt;pagetable)，以打印第一个进程的页表。如果您通过make grade的pte打印测试，则获得此任务的全部学分。</p></blockquote><p>现在当您启动xv6时，它应该打印出类似于这样的输出，描述了第一个进程的页表，此时它刚刚完成了exec()ing init的过程：</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-19%20162439.png"></p><p>第一行显示了vmprint的参数。之后，每个PTE都有一行，包括引用树中更深层次的页表页的PTE。每个PTE行都以一些” ..”缩进，表示其在树中的深度。每个PTE行显示其页表页中的PTE索引、pte位和从PTE中提取的物理地址。不要打印无效的PTE。在上面的示例中，顶层页表页具有条目0和255的映射。下一级的条目0只有索引0被映射，而该索引0的底层具有条目0、1和2的映射。</p><p>您的代码可能会产生与上面显示的物理地址不同的地址。 条目数和虚拟地址应该是相同的。</p><blockquote><p>一些提示：  </p><ul><li>您可以将vmprint()放在kernel&#x2F;vm.c中。 </li><li>使用文件kernel&#x2F;riscv.h末尾的宏。 </li><li>函数freewalk可能会给您灵感。 </li><li>在kernel&#x2F;defs.h中定义vmprint的原型，以便您可以从exec.c中调用它。 </li><li>在printf调用中使用%p来打印出完整的64位十六进制PTEs和地址，如示例所示。</li></ul></blockquote><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-19%20164406.png" alt="freewalk函数"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-20%20201144.png" alt="risv.h"></p><p>在exec.c中添加语句</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-20%20204236.png"></p><p>在def.h中定义函数原型</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-20%20204221.png"></p><p>具体的函数实现如下</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-20%20204203.png"></p><p>运行qemu后</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-09%20203948.png"></p><h3 id="A-kernel-page-table-per-process"><a href="#A-kernel-page-table-per-process" class="headerlink" title="A kernel page table per process"></a>A kernel page table per process</h3><p>Xv6 有一个内核页表，每当它在内核中执行时就会使用该页表。 </p><p>内核页表是到物理地址的直接映射，这样内核虚拟地址x就映射到物理地址x。</p><p> Xv6 还为每个进程的用户地址空间提供一个单独的页表，仅包含该进程的用户内存的映射，从虚拟地址零开始。 由于内核页表不包含这些映射，因此用户地址在内核中无效。 </p><p>因此，当内核需要使用系统调用中传递的用户指针（例如传递给 write() 的缓冲区指针）时，内核必须首先将指针转换为物理地址。 本节和下一节的目标是允许内核直接取消引用用户指针。</p><blockquote><p>您的第一项工作是修改内核，以便每个进程在内核中执行时都使用自己的内核页表副本。 修改struct proc为每个进程维护一个内核页表，修改调度器在切换进程时切换内核页表。 对于此步骤，每个进程内核页表应与现有的全局内核页表相同。 如果 usertests 正确运行，您就可以通过这部分实验。</p></blockquote><p>阅读本作业开始时提到的书籍章节和代码； 了解虚拟内存的工作原理后，可以更轻松地正确修改虚拟内存代码。 页表设置中的错误可能会因缺少映射而导致陷阱，可能导致加载和存储影响意外的物理内存页面，并可能导致从不正确的内存页面执行指令。</p><blockquote><p>一些建议：  </p><ul><li>为进程的内核页表添加一个字段。 </li><li>为了为新进程生成一个内核页表，一种合理的方法是实现一个修改过的kvminit版本，该版本生成一个新的页表，而不是修改kernel_pagetable。您将希望从allocproc中调用此函数。 </li><li>确保每个进程的内核页表都有一个映射到该进程的内核堆栈的条目。在未修改的xv6中，所有的内核堆栈都在procinit中设置。您需要将某些或所有这些功能移动到allocproc中。 </li><li>修改scheduler()函数，将进程的内核页表加载到核心的satp寄存器中（参见kvminithart以获取灵感）。不要忘记在调用w_satp()之后调用sfence_vma()。 </li><li>当没有进程运行时，scheduler()函数应使用kernel_pagetable。 </li><li>在freeproc中释放进程的内核页表。 </li><li>您需要一种方法来释放页表，而不会同时释放叶子物理内存页。 vmprint可能对调试页表很有用。</li><li>可以修改xv6函数或添加新函数；您可能需要在至少kernel&#x2F;vm.c和kernel&#x2F;proc.c中进行修改。 （但是，请不要修改kernel&#x2F;vmcopyin.c、kernel&#x2F;stats.c、user&#x2F;usertests.c和user&#x2F;stats.c。） </li><li>缺少的页表映射可能会导致内核遇到页错误。它将打印一个包含sepc&#x3D;0x00000000XXXXXXXX的错误。您可以通过在kernel&#x2F;kernel.asm中搜索XXXXXXXX来找出故障发生的位置。</li></ul></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【MIT6.S081】-Lab2</title>
      <link href="/2023/08/23/mit6.s081-lab2/"/>
      <url>/2023/08/23/mit6.s081-lab2/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-system-calls"><a href="#Lab-system-calls" class="headerlink" title="Lab: system calls"></a>Lab: system calls</h1><p>在本实验中，您将向 xv6 添加一些新的系统调用，这将帮助您了解它们的工作原理，并向您展示 xv6 内核的一些内部结构</p><p>您将在后面的实验中添加更多系统调用</p><blockquote><p>准备：</p><p>阅读xv6 book的chapter 2，以及section 4.3，chapter 4的4.4</p><p>阅读以下源文件</p><ul><li>系统调用的用户空间代码（位于 user&#x2F;user.h 和 user&#x2F;usys.pl 中）</li><li>内核空间代码（kernel&#x2F;syscall.h、kernel&#x2F;syscall.c）</li><li>进程相关的代码（kernel&#x2F;proc.h和kernel&#x2F;proc.c）</li></ul></blockquote><p>要开始实验，请切换到系统调用分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> fetch$ <span class="token function">git</span> checkout syscall$ <span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此处出现的问题：</p><p>切换分支时出现下面这种情况</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-23%20164349.png"></p><p>解决方法：</p><p>输入git stash</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-23%20164449.png"></p><p>成功切换分支</p><h2 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h2><blockquote><p>在此作业中，您将添加系统调用跟踪功能，该功能可以在调试后续实验时为您提供帮助。您将创建一个新的跟踪系统调用来控制跟踪。它应该采用一个参数，一个整数“掩码”，其位指定要跟踪哪些系统调用。例如，要跟踪 fork 系统调用，程序调用trace(1 &lt;&lt; SYS_fork)，其中 SYS_fork 是来自 kernel&#x2F;syscall.h 的系统调用号。如果掩码中设置了系统调用的编号，则必须修改 xv6 内核，以便在每个系统调用即将返回时打印一行。该行应包含进程 ID、系统调用名称和返回值；您不需要打印系统调用参数。跟踪系统调用应该启用对调用它的进程及其随后派生的任何子进程的跟踪，但不应影响其他进程。</p></blockquote><p>我们提供了一个跟踪用户级程序，它运行另一个启用了跟踪的程序（请参阅 user&#x2F;trace.c）。完成后，您应该看到如下输出：</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-23%20165631.png"></p><p>在上面的第一个示例中，trace 仅调用 read 系统调用 grep 跟踪。 32 是 1&lt;&lt;SYS_read。在第二个示例中，trace 在跟踪所有系统调用的同时运行 grep； 2147583647 已设置所有 31 个低位。在第三个示例中，未跟踪程序，因此不会打印跟踪输出。在第四个示例中，正在跟踪 usertests 中 forkforkfork 测试的所有后代的 fork 系统调用。如果您的程序的行为如上所示（尽管进程 ID 可能不同），则您的解决方案是正确的。</p><blockquote><p>在Makefile中添加$U_trace</p><p>运行 make qemu ，您将看到编译器无法编译 user&#x2F;trace.c，因为系统调用的用户空间存根尚不存在：将系统调用的原型添加到 user&#x2F;user.h，将存根添加到 user&#x2F;usys.pl，并将系统调用号添加到 kernel&#x2F;syscall.h。Makefile 调用 perl 脚本 user&#x2F;usys.pl，该脚本生成 user&#x2F;usys.S，即实际的系统调用存根，它使用 RISC-V ecall 指令转换到内核。修复编译问题后，运行trace 32 grep hello README;它会失败，因为你还没有在内核中实现系统调用。</p><p>在 kernel&#x2F;sysproc.c 中添加 sys_trace() 函数，该函数通过在 proc 结构中的新变量中记住其参数来实现新的系统调用（请参阅 kernel&#x2F;proc.h）。从用户空间检索系统调用参数的函数位于 kernel&#x2F;syscall.c 中，您可以在 kernel&#x2F;sysproc.c 中查看它们的使用示例。</p><p>修改 fork() （参见 kernel&#x2F;proc.c）以将跟踪掩码从父进程复制到子进程</p><p>修改 kernel&#x2F;syscall.c 中的 syscall() 函数以打印跟踪输出。您将需要添加要索引的系统调用名称数组。</p></blockquote><p>1.在结构体proc(kernel&#x2F;proc.h)中加入一个用于进程追踪的掩码</p><p>此处在proc结构体中添加int mask</p><p>见结构体的最后一行</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-23%20172610.png"></p><p>2.在sysproc.c中实现sys_trace</p><blockquote><p>xv6book中提到，函数argint,argaddr,argstr等可以从trapframe中将用户态传递的参数读取到内核态</p><p>查看.kernel&#x2F;syscall.c文件可知</p><p>argraw从对应的trapframe中返回a0~a7寄存器</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-23%20173240.png"></p></blockquote><p>将用户态传递来的掩码存入当前进程的mask中</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-23%20173806.png"></p><p>3.为了能够追踪当前进程的子进程，进程在调用fork时，子进程应当复制mask的值，所以还要修改.kernel&#x2F;proc.c中fork函数的内容</p><p>如图第278行</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-23%20174503.png"></p><p>4.修改函数syscall(.kernel&#x2F;syscall.c)</p><p>如图第143行</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-23%20175520.png"></p><p>5.在syscall.c中加入系统调用号到名称的映射表</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-23%20181053.png"></p><p><strong>此处若将表加入到syscall.h中则会出现错误，所以务必加入到syscall.c中</strong></p><h4 id="测试输出结果如下："><a href="#测试输出结果如下：" class="headerlink" title="测试输出结果如下："></a>测试输出结果如下：</h4><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-26%20195125.png"></p><h2 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h2><blockquote><p>在此作业中，您将添加一个系统调用 sysinfo，用于收集有关正在运行的系统的信息。系统调用采用一个参数：指向 struct sysinfo 的指针（参见 kernel&#x2F;sysinfo.h）。内核应填写此结构体的字段：freemem 字段应设置为可用内存的字节数，nproc 字段应设置为状态不是 UNUSED 的进程数。我们提供了一个测试程序sysinfotest；如果打印出“sysinfotest: OK”，则说明您通过了此作业。</p></blockquote><blockquote><p>将 $U&#x2F;_sysinfotest 添加到 Makefile 中的 UPROGS</p><p>运行 make qemu，user&#x2F;sysinfotest.c 将无法编译。添加系统调用 sysinfo，遵循与之前作业相同的步骤。要在 user&#x2F;user.h 中声明 sysinfo() 的原型，您需要预先声明 struct sysinfo 的存在：</p><pre class="line-numbers language-none"><code class="language-none">struct sysinfo;   int sysinfo(struct sysinfo *);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>修复编译问题后，运行 sysinfotest；它会失败，因为你还没有在内核中实现系统调用。</p><p>sysinfo需要将struct sysinfo复制回用户空间；有关如何使用 copyout() 执行此操作的示例，请参阅 sys_fstat() (kernel&#x2F;sysfile.c) 和 filestat() (kernel&#x2F;file.c)。</p><p>要收集可用内存量，请向 kernel&#x2F;kalloc.c 添加一个函数</p><p>要收集进程数，请在 kernel&#x2F;proc.c 中添加一个函数</p></blockquote><p>1.在makefile的UPROGS中添加$U&#x2F;_sysinfotest</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20164644.png"></p><p>2.将系统调用原型添加到user&#x2F;user.h头文件中</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20164814.png"></p><p>3.将存根添加到user&#x2F;usys.pl</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20164910.png"></p><p>4.将系统调用编号添加到kernel&#x2F;syscall.h中</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20165030.png"></p><p>5.查看copyout()的用法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20170303.png" alt="kernel/file.c"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20170406.png" alt="kernel/sysfile.c"></p><p>6.添加收集可用内存量的函数</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20171620.png"></p><p>7.添加获取进程数的函数</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20172354.png"></p><p>8.在kernel&#x2F;defs.h中添加函数声明</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20173504.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20173551.png"></p><p>9.实现sys_sysinfo函数</p><p><strong>通过argaddr系统调用，将用户传进来的指向结构体的指针读入dstaddr来记录这个地址</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20175438.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go_review</title>
      <link href="/2023/08/12/go-review/"/>
      <url>/2023/08/12/go-review/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是CodeReview"><a href="#什么是CodeReview" class="headerlink" title="什么是CodeReview"></a>什么是CodeReview</h1><p>Code Review（CR）即代码评审，又名代码走查，是一种通过复查代码来提高代码质量的过程，一般体现在一个团队的开发过程中。CR要求团队成员有意识地、系统地检查彼此的代码，从而验证需求、发现错误，同时指出其中不合规范的“低质量”代码，从而提高整个团队的代码质量。</p><p>一次 CR 可以是一次 Commit，也可以是一次 Merge Request。因此，实践课系统支持团队内部的 MR 评审以及 Commit 评审，供大家学习和交流</p><h1 id="Go-Code-Review-Comments"><a href="#Go-Code-Review-Comments" class="headerlink" title="Go Code Review Comments"></a>Go Code Review Comments</h1><h2 id="Comment-Sentence"><a href="#Comment-Sentence" class="headerlink" title="Comment Sentence"></a>Comment Sentence</h2><p>注释应以所描述事物的名称开头并以句点结束</p><p>这种方法使得它们在提取到 godoc 文档时格式良好</p><h2 id="Contexts"><a href="#Contexts" class="headerlink" title="Contexts"></a>Contexts</h2><p>context是Go语言独有的功能，用于上下文控制，可以在goroutine中进行传递</p><p>context.Context 类型的值携带跨 API 和进程边界的安全凭证、跟踪信息、截止日期和取消信号</p><p>Go 程序沿着从传入 RPC 和 HTTP 请求到传出请求的整个函数调用链显式传递上下文</p><p>大多数使用 Context 的函数都应该接受它作为第一个参数：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">F</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> <span class="token comment">/* other arguments */</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>默认情况是传递一个Context；仅当您有充分的理由说明替代方法是错误时，才直接使用 context.Background() </p><p>不要将 Context 成员添加到结构类型；相反，向需要传递该类型的每个方法添加一个 ctx 参数</p><p>一个例外是其签名必须与标准库或第三方库中的接口匹配的方法</p><p>不要创建自定义 Context 类型或在函数签名中使用 Context 以外的接口</p><p>如果您有要传递的应用程序数据，请将其放入参数、接收器、全局变量中，或者，如果它确实属于那里，则放在 Context 值中</p><p>上下文是不可变的，因此可以将相同的 ctx 传递给共享相同截止日期、取消信号、凭证、父跟踪等的多个调用</p><h2 id="Copying"><a href="#Copying" class="headerlink" title="Copying"></a>Copying</h2><p>为了避免意外的别名，从另一个包复制结构时要小心</p><p>Buffer类型包含一个[]byte切片。如果复制 Buffer，副本中的切片可能会别名化原始数组中的数组，从而导致后续方法调用产生令人惊讶的效果</p><p>通常，如果 T 类型的方法与指针类型 *T 关联，则不要复制该值</p><h2 id="Crypto-Rand"><a href="#Crypto-Rand" class="headerlink" title="Crypto Rand"></a>Crypto Rand</h2><p>不要使用 math&#x2F;rand 包来生成密钥，即使是一次性的密钥。没有种子，生成器是完全可预测的</p><p>用 time.Nanoseconds() 作为种子，只有一些熵</p><p>相反，请使用 crypto&#x2F;rand 的 Reader，如果您需要文本，请打印为十六进制或 base64：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"crypto/rand"</span><span class="token comment">// "encoding/base64"</span><span class="token comment">// "encoding/hex"</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">Key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>buf <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> rand<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>  <span class="token comment">// out of randomness, should never happen</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%x"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token comment">// or hex.EncodeToString(buf)</span><span class="token comment">// or base64.StdEncoding.EncodeToString(buf)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Declaring-Empty-Slices"><a href="#Declaring-Empty-Slices" class="headerlink" title="Declaring Empty Slices"></a>Declaring Empty Slices</h2><p>声明切片时，建议用下面这种形式</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> t <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而不是</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">t <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>前者声明一个 nil 切片值，而后者非 nil 但长度为零</p><p>它们在功能上是等效的，它们的 len 和 cap 都为零，但 nil 切片是首选样式</p><p>请注意，在有限的情况下，首选非 nil 但零长度的切片</p><p>例如在编码 JSON 对象时（nil 切片编码为 null，而 []string{} 编码为 JSON 数组 []）</p><h2 id="Doc-Comments"><a href="#Doc-Comments" class="headerlink" title="Doc Comments"></a>Doc Comments</h2><p>所有top-level导出名称都应具有文档注释，重要的未导出类型或函数声明也应具有文档注释</p><h2 id="Don’t-Panic"><a href="#Don’t-Panic" class="headerlink" title="Don’t Panic"></a>Don’t Panic</h2><p>不要使用panic来进行正常的错误处理</p><p>使用error和多个返回值。</p><h2 id="Error-Strings"><a href="#Error-Strings" class="headerlink" title="Error Strings"></a>Error Strings</h2><p>错误字符串不应大写（除非以专有名词或首字母缩略词开头）或以标点符号结尾，因为它们通常是在其他上下文之后打印的</p><p>也就是说，使用 </p><p>fmt.Errorf(“something bad”) </p><p>而不是 </p><p>fmt.Errorf(“Something bad”)</p><p>以便 log.Printf(“Reading %s: %v”, filename, err) 格式没有虚假的大写字母 mid -信息</p><p>这不适用于日志记录，日志记录是隐式面向行的并且不会组合在其他消息中</p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p>添加新包时，请包含预期用途的示例：可运行的示例，或演示完整调用序列的简单测试。</p><h2 id="Goroutinue-Lifetimes"><a href="#Goroutinue-Lifetimes" class="headerlink" title="Goroutinue Lifetimes"></a>Goroutinue Lifetimes</h2><p>当生成 goroutine 时，请明确它们何时退出或是否退出</p><p>Goroutine 可能会因阻塞通道发送或接收而发生泄漏：即使阻塞的通道无法访问，垃圾收集器也不会终止 Goroutine</p><p>在关闭的通道上发送panic</p><p> “在不需要结果之后”修改仍在使用的输入仍然可能导致数据争用。</p><p>尝试使并发代码足够简单，以便 goroutine 生命周期显而易见。如果这不可行，请记录 goroutine 退出的时间和原因</p><h2 id="Handle-Errors"><a href="#Handle-Errors" class="headerlink" title="Handle Errors"></a>Handle Errors</h2><p>不要使用 _ 变量丢弃错误。如果函数返回错误，请检查它以确保函数成功运行</p><p>处理error，返回error，或者，panic。</p><h2 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h2><p>避免重命名导入，除非是为了避免名称冲突</p><p>如果发生冲突，最好重命名最本地或特定于项目的导入</p><p>导入按组进行组织，组之间有空行</p><p>标准库包始终位于第一组中</p><p>示例</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"hash/adler32"</span><span class="token string">"os"</span><span class="token string">"github.com/foo/bar"</span><span class="token string">"rsc.io/goversion/version"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Import-Blank"><a href="#Import-Blank" class="headerlink" title="Import Blank"></a>Import Blank</h2><p>仅因其副作用而导入的包（使用语法 import _ “pkg”）只能在程序的主包中导入，或者在需要它们的测试中导入</p><h2 id="Import-Dot"><a href="#Import-Dot" class="headerlink" title="Import Dot"></a>Import Dot</h2><p>import . form 在由于循环依赖而无法成为被测试包的一部分的测试中非常有用：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> foo_test<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"bar/testutil"</span> <span class="token comment">// also imports "foo"</span><span class="token punctuation">.</span> <span class="token string">"foo"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下，测试文件不能位于包 foo 中，因为它使用 bar&#x2F;testutil，它导入了 foo。所以我们使用“import”.形式让文件假装是包 foo 的一部分，即使它不是。</p><p>除这一种情况外，不要使用 import 。在你的程序中。它使程序更难阅读，因为不清楚像 Quux 这样的名称是否是当前包或导入包中的顶级标识符</p><h2 id="In-Band-Errors"><a href="#In-Band-Errors" class="headerlink" title="In-Band Errors"></a>In-Band Errors</h2><p>在 C 和类似语言中，函数通常返回 -1 或 null 等值来表示错误或丢失结果：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Lookup返回key的值，如果没有key的映射，则返回""。</span><span class="token keyword">func</span> <span class="token function">Lookup</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span class="token comment">// 未能检查in-band错误值可能会导致错误</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token function">Lookup</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// 返回"parse failure for value"而不是"no value for key"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Go 对多个返回值的支持提供了更好的解决方案</p><p>函数不应要求客户端检查in-band错误值，而应返回一个附加值来指示其其他返回值是否有效。</p><p>当不需要解释时，此返回值可能是错误，也可能是布尔值，这可以防止调用者错误地使用结果：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Lookup返回key的值，如果没有key的映射，则返回ok=false</span><span class="token keyword">func</span> <span class="token function">Lookup</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>value <span class="token builtin">string</span><span class="token punctuation">,</span> ok <span class="token builtin">bool</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>更建议以下这种写法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">value<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token function">Lookup</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span><span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"no value for %q"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token function">Parse</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此规则适用于导出的函数，但对于未导出的函数也很有用</p><p>当像 nil、””、0 和 -1 这样的返回值是函数的有效结果时，也就是说，当调用者不需要以与其他值不同的方式处理它们时，它们就可以了</p><p>某些标准库函数（例如“strings”包中的函数）会返回带内错误值。这极大地简化了字符串操作代码</p><p>一般来说，Go 代码应该返回错误的附加值</p><h2 id="Indent-Error-Flow"><a href="#Indent-Error-Flow" class="headerlink" title="Indent Error Flow"></a>Indent Error Flow</h2><p>尽量使正常的代码路径保持最小的缩进，并缩进错误处理，首先处理它。通过允许快速视觉扫描正常路径，提高了代码的可读性。</p><p>例如，不要写：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// error handling</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">// normal code</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>建议的写法是：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// error handling</span><span class="token keyword">return</span> <span class="token comment">// or continue, etc.</span><span class="token punctuation">&#125;</span><span class="token comment">// normal code</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果if语句有初始化语句，如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> x<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// error handling</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">// use x</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么这可能需要将短变量声明移至其自己的行：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">x<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// error handling</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token comment">// use x</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Initialisms"><a href="#Initialisms" class="headerlink" title="Initialisms"></a>Initialisms</h2><p>名称中的首字母缩写词或首字母缩写词（例如“URL”或“NATO”）具有一致的大小写。例如，“URL”应显示为“URL”或“url”（如“urlPony”或“URLPony”），而不是“Url”</p><p>举个例子：ServeHTTP 不是 ServeHttp。对于具有多个初始化“单词”的标识符，请使用“xmlHTTPRequest”或“XMLHTTPRequest”等</p><p>当“ID”是“identifier”的缩写时，此规则也适用于“ID”（这几乎是所有情况，当它不是“ego”、“superego”中的“id”时），因此写“appID”而不是“appId” ”</p><h1 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h1><p>Go 接口通常属于使用接口类型值的包，而不是实现这些值的包</p><p>实现包应该返回具体的（通常是指针或结构）类型：这样，可以将新方法添加到实现中，而不需要大量重构</p><p>不要在 API 的实现者端定义“用于模拟”的接口；相反，设计 API 以便可以使用实际实现的公共 API 进行测试</p><p>不要在使用之前定义接口：如果没有实际的使用示例，就很难看出接口是否必要，更不用说它应该包含哪些方法了</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> consumer  <span class="token comment">// consumer.go</span><span class="token keyword">type</span> Thinger <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span> <span class="token function">Thing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">Foo</span><span class="token punctuation">(</span>t Thinger<span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span> … <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> consumer <span class="token comment">// consumer_test.go</span><span class="token keyword">type</span> fakeThinger <span class="token keyword">struct</span><span class="token punctuation">&#123;</span> … <span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>t fakeThinger<span class="token punctuation">)</span> <span class="token function">Thing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span> … <span class="token punctuation">&#125;</span>…<span class="token keyword">if</span> <span class="token function">Foo</span><span class="token punctuation">(</span>fakeThinger<span class="token punctuation">&#123;</span>…<span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"x"</span> <span class="token punctuation">&#123;</span> … <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// DO NOT DO IT!!!</span><span class="token keyword">package</span> producer<span class="token keyword">type</span> Thinger <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span> <span class="token function">Thing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#125;</span><span class="token keyword">type</span> defaultThinger <span class="token keyword">struct</span><span class="token punctuation">&#123;</span> … <span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>t defaultThinger<span class="token punctuation">)</span> <span class="token function">Thing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span> … <span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">NewThinger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Thinger <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> defaultThinger<span class="token punctuation">&#123;</span> … <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Line-Length"><a href="#Line-Length" class="headerlink" title="Line Length"></a>Line Length</h2><p>根据语义进行断行，而不是行的长度</p><p>如果一个函数的过长，可以通过改变函数的边界来改变函数的长度</p><h2 id="Named-Result-Parameters"><a href="#Named-Result-Parameters" class="headerlink" title="Named Result Parameters"></a>Named Result Parameters</h2><p>这样命名：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token function">Parent1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>Node <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token function">Parent2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>Node<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>而不是：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token function">Parent1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>node <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token function">Parent2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>node <span class="token operator">*</span>Node<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>另一方面，如果一个函数返回两个或三个相同类型的参数，或者从上下文中不清楚结果的含义，则在某些上下文中添加名称是有必要的</p><p>这样命名：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Location returns f's latitude and longitude.</span><span class="token comment">// Negative values mean south and west, respectively.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>Foo<span class="token punctuation">)</span> <span class="token function">Location</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>lat<span class="token punctuation">,</span> long <span class="token builtin">float64</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>而不是：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>Foo<span class="token punctuation">)</span> <span class="token function">Location</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">float64</span><span class="token punctuation">,</span> <span class="token builtin">float64</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Naked-Returns"><a href="#Naked-Returns" class="headerlink" title="Naked Returns"></a>Naked Returns</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">split</span><span class="token punctuation">(</span>sum <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>x <span class="token operator">=</span> sum <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">/</span> <span class="token number">9</span>y <span class="token operator">=</span> sum <span class="token operator">-</span> x<span class="token keyword">return</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Package-Comments"><a href="#Package-Comments" class="headerlink" title="Package Comments"></a>Package Comments</h2><p>包的注释必须出现在Package字句的旁边，不能有空行</p><h2 id="Package-Names"><a href="#Package-Names" class="headerlink" title="Package Names"></a>Package Names</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go_Testing</title>
      <link href="/2023/08/11/go-testing/"/>
      <url>/2023/08/11/go-testing/</url>
      
        <content type="html"><![CDATA[<h1 id="如何写一个正确的测试函数"><a href="#如何写一个正确的测试函数" class="headerlink" title="如何写一个正确的测试函数"></a>如何写一个正确的测试函数</h1><p>包测试为 Go 包的自动化测试提供支持。它旨在与“go test”命令配合使用，该命令自动执行以下形式的任何函数</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">TestXxx</span><span class="token punctuation">(</span><span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>包含测试函数的测试文件的文件名应以”_test.go”结尾</p><p>该文件将从常规包构件中排除，但在运行”go test”命令时将包含该文件</p><p>测试文件可以与被测文件在同一个包中，也可以在对应的后缀为“_test”的包中。</p><p>如果测试文件位于同一个包中，则它可能引用包内未导出的标识符，如下例所示：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> abs<span class="token keyword">import</span> <span class="token string">"testing"</span><span class="token keyword">func</span> <span class="token function">TestAbs</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    got <span class="token operator">:=</span> <span class="token function">Abs</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> got <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">&#123;</span>        t<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Abs(-1) = %d; want 1"</span><span class="token punctuation">,</span> got<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果文件位于单独的“_test”包中，则必须显式导入正在测试的包，并且只能使用其导出的标识符。这称为“黑盒”测试。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> abs_test<span class="token keyword">import</span><span class="token punctuation">(</span>    <span class="token string">"testing"</span>    <span class="token string">"path_to_pkg/abs"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">TestAbs</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    got <span class="token operator">:=</span> abs<span class="token punctuation">.</span><span class="token function">Abs</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> got <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">&#123;</span>        t<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">"Abs(-1) = %d; want 1"</span><span class="token punctuation">,</span> got<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Benchmarks"><a href="#Benchmarks" class="headerlink" title="Benchmarks"></a>Benchmarks</h1><p> 函数形式</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">BenchmarkXxx</span><span class="token punctuation">(</span><span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在提供 -bench 标志时由“go test”命令执行。Benchmarks按顺序运行。</p><p>一个简单的banchmark函数如下</p><p><em>基准测试函数必须运行目标代码 b.N 次。在基准测试执行期间，b.N 会被调整，直到基准测试函数持续足够长的时间以可靠地计时。</em></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">BenchmarkRandInt</span><span class="token punctuation">(</span>b <span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">&#123;</span>        rand<span class="token punctuation">.</span><span class="token function">Int</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">BenchmarkRandInt<span class="token operator">-</span><span class="token number">8</span>   <span class="token number">68453040</span>        <span class="token number">17.8</span> ns<span class="token operator">/</span>op<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>意味着循环以每个循环 17.8 ns 的速度运行了 68453040 次。</p><p>如果基准测试在运行之前需要一些复杂的设置，则计时器可能会被重置：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">BenchmarkBigLen</span><span class="token punctuation">(</span>b <span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    big <span class="token operator">:=</span> <span class="token function">NewBig</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    b<span class="token punctuation">.</span><span class="token function">ResetTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        big<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果基准测试需要在并行设置中测试性能，则可以使用 RunParallel 辅助函数；此类基准测试旨在与 go test -cpu 标志一起使用：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">BenchmarkTemplateParallel</span><span class="token punctuation">(</span>b <span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    templ <span class="token operator">:=</span> template<span class="token punctuation">.</span><span class="token function">Must</span><span class="token punctuation">(</span>template<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token string">"Hello, &#123;&#123;.&#125;&#125;!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    b<span class="token punctuation">.</span><span class="token function">RunParallel</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>pb <span class="token operator">*</span>testing<span class="token punctuation">.</span>PB<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> buf bytes<span class="token punctuation">.</span>Buffer        <span class="token keyword">for</span> pb<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            buf<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            templ<span class="token punctuation">.</span><span class="token function">Execute</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token string">"World"</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考文档：</p><p><a href="https://pkg.go.dev/testing#hdr-Benchmarks">https://pkg.go.dev/testing#hdr-Benchmarks</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【青训营】—高质量编程与性能调优</title>
      <link href="/2023/08/11/qing-xun-ying-gao-zhi-liang-bian-cheng-yu-xing-neng-diao-you/"/>
      <url>/2023/08/11/qing-xun-ying-gao-zhi-liang-bian-cheng-yu-xing-neng-diao-you/</url>
      
        <content type="html"><![CDATA[<h3 id="实践准备"><a href="#实践准备" class="headerlink" title="实践准备"></a>实践准备</h3><ul><li>克隆<a href="https://link.juejin.cn/?target=https://github.com/wolfogre/go-pprof-practice%E5%88%B0%E6%9C%AC%E5%9C%B0%EF%BC%8C%E4%BF%9D%E8%AF%81%E8%83%BD%E5%A4%9F%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C">https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwolfogre%2Fgo-pprof-practice到本地，保证能够编译运行</a></li><li>尝试使用test命令，编译并运行简单测试<a href="https://link.juejin.cn/?target=https://go.dev/doc/tutorial/add-a-test">https://link.juejin.cn/?target=https%3A%2F%2Fgo.dev%2Fdoc%2Ftutorial%2Fadd-a-test</a></li><li>尝试使用-bench参数，对编写的函数进行性能测试，<a href="https://link.juejin.cn/?target=https://pkg.go.dev/testing%23hdr-Benchmarks">https://link.juejin.cn/?target=https%3A%2F%2Fpkg.go.dev%2Ftesting%23hdr-Benchmarks</a></li></ul><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p>Go代码Review建议</p><p>Uber的Go编码规范 </p><h3 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h3><ul><li>如何编写更简洁清晰的代码</li><li>常用Go语言程序优化手段</li><li>熟悉Go程序性能分析工具</li><li>了解工程中性能优化的原则和流程</li></ul><h1 id="01-高质量编程"><a href="#01-高质量编程" class="headerlink" title="01.高质量编程"></a>01.高质量编程</h1><ul><li><p>简介</p><p>各种边界条件是否考虑完备</p><p>异常情况处理，稳定性保证</p><p>易读易维护</p></li><li><p>编码规范</p></li><li><p>性能优化建议</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go语言学习路线</title>
      <link href="/2023/08/11/go-yu-yan-xue-xi-lu-xian/"/>
      <url>/2023/08/11/go-yu-yan-xue-xi-lu-xian/</url>
      
        <content type="html"><![CDATA[<p>学习 Go 语言并进行项目开发需要一系列的基础知识和技能。以下是一个逐步学习和掌握 Go 语言的学习路线：</p><p><strong>阶段一：入门基础</strong></p><ol><li><p><strong>安装和设置：</strong> 下载并安装 Go 编程语言。配置你的开发环境，确保 Go 的环境变量设置正确。</p></li><li><p><strong>语法基础：</strong> 学习 Go 语言的基础语法，包括变量、常量、数据类型、运算符、控制结构（条件语句和循环）、函数等。</p></li><li><p><strong>数据类型和集合：</strong> 学习 Go 的内置数据类型，如字符串、数组、切片、映射（map）、结构体等。</p></li><li><p><strong>指针和内存管理：</strong> 了解指针的概念以及如何在 Go 中使用。熟悉垃圾回收机制。</p></li><li><p><strong>错误处理：</strong> 学习如何处理错误以及 Go 中的错误处理机制。</p></li></ol><p><strong>阶段二：深入学习</strong><br>6. <strong>面向对象编程：</strong> 学习 Go 中的面向对象编程概念，如方法、接口、组合等。</p><ol start="7"><li><p><strong>并发与并行：</strong> 了解 Go 的并发编程模型（goroutines 和 channels），以及如何使用它们来实现高效的并发和并行程序。</p></li><li><p><strong>包和模块：</strong> 学习如何组织代码，创建和使用包（packages），以及 Go Modules 的使用。</p></li><li><p><strong>文件操作：</strong> 学习如何读写文件，处理文件路径，以及基本的文件操作。</p></li></ol><p><strong>阶段三：项目实践</strong><br>10. <strong>Web 开发：</strong> 学习使用 Go 进行 Web 开发，包括使用 Web 框架（如 Gin、Echo）创建 Web 应用、处理路由、中间件、HTTP 请求和响应等。</p><ol start="11"><li><p><strong>数据库操作：</strong> 学习如何使用 Go 连接和操作数据库，掌握 SQL 查询、事务管理、数据库ORM（如 GORM）等。</p></li><li><p><strong>RESTful API：</strong> 实现基于 Go 的 RESTful API，了解 API 设计原则、路由管理、认证和授权等。</p></li><li><p><strong>测试和调试：</strong> 学习如何编写单元测试和集成测试，使用 Go 内置的测试框架进行测试，以及调试技巧。</p></li></ol><p><strong>阶段四：高级主题</strong><br>14. <strong>性能优化：</strong> 学习如何优化 Go 代码的性能，包括内存管理、并发调优、性能分析工具的使用等。</p><ol start="15"><li><p><strong>网络编程：</strong> 探索网络编程领域，了解 TCP&#x2F;UDP 编程、Socket 编程等。</p></li><li><p><strong>工具和生态系统：</strong> 探索 Go 生态系统，学习使用一些常用的第三方库，熟悉 Go 的工具链，如 gofmt、golint、go vet 等。</p></li><li><p><strong>部署和发布：</strong> 学习如何将 Go 项目部署到生产环境，包括 Docker 化、CI&#x2F;CD 流程、部署工具等。</p></li></ol><p><strong>阶段五：个人项目</strong><br>18. <strong>个人项目：</strong> 开始一个小型的个人项目，将之前学到的知识应用到实际项目中，不断完善和扩展。</p><ol start="19"><li><strong>持续学习：</strong> 跟随 Go 社区的发展，学习新的特性和最佳实践，不断提升自己的技能。</li></ol><p>在学习过程中，建议你阅读官方文档、书籍、教程，并且实践项目，不断积累经验。还可以参与开源项目、社区讨论，从其他开发者中获取更多的知识和经验。记住，持续的实践和学习是掌握任何编程语言的关键。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go_Map</title>
      <link href="/2023/08/10/go-map/"/>
      <url>/2023/08/10/go-map/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    m <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">//创建一个空map</span>       <span class="token comment">//使用name[key] = val来设置键值对</span>    m<span class="token punctuation">[</span><span class="token string">"k1"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">7</span>    m<span class="token punctuation">[</span><span class="token string">"k2"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">13</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"map:"</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span> <span class="token comment">//输出所有键值对</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"len:"</span><span class="token punctuation">,</span><span class="token function">len</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//返回键值对数量</span>    <span class="token function">delete</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span><span class="token string">"k2"</span><span class="token punctuation">)</span> <span class="token comment">//删除键值对</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go_读文件</title>
      <link href="/2023/08/10/go-du-wen-jian/"/>
      <url>/2023/08/10/go-du-wen-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="错误检查"><a href="#错误检查" class="headerlink" title="错误检查"></a>错误检查</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">check</span><span class="token punctuation">(</span>e <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> e <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">&#123;</span>        <span class="token function">panic</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    dat<span class="token punctuation">,</span>err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">ReadFile</span><span class="token punctuation">(</span><span class="token string">"/tmp/dat"</span><span class="token punctuation">)</span>    <span class="token function">check</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>dat<span class="token punctuation">)</span><span class="token punctuation">)</span>        f<span class="token punctuation">,</span>err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"/tmp/dat"</span><span class="token punctuation">)</span> <span class="token comment">//获取一个os.File值</span>    <span class="token function">check</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>        b1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>    n1<span class="token punctuation">,</span>err <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span>    <span class="token function">check</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"%d bytes: %s\n"</span><span class="token punctuation">,</span>n1<span class="token punctuation">,</span><span class="token function">string</span><span class="token punctuation">(</span>b1<span class="token punctuation">[</span><span class="token punctuation">:</span>n1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Golang_sysnc.Once</title>
      <link href="/2023/08/10/go-sysnc.once/"/>
      <url>/2023/08/10/go-sysnc.once/</url>
      
        <content type="html"><![CDATA[<p>当一个函数在程序启动后不想被多次执行，可以使用sync.Once</p><p>sync.Once结构体仅包括两个属性，done记录执行状态，sync.Mutex和sync.atomic确保done变量的线程安全</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Once <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    done <span class="token builtin">uint32</span>    m Mutex<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>sync.Once仅提供了一个Do()方法，参数为待执行的函数</p><p>首先，<a href="https://so.csdn.net/so/search?q=atomic&spm=1001.2101.3001.7020">atomic</a>读取done字段值是否被改变，然后当如果没有改变时执行doSlow方法。当进入doSlow方法，开始执行锁操作，在并发环境下仅有一个线程被执行，然后基于done字段是否被改变执行待执行函数，如果没有改变则执行f函数。当代码块执行后，done字段被激活。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>o <span class="token operator">*</span>Once<span class="token punctuation">)</span> <span class="token function">Do</span><span class="token punctuation">(</span>f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">LoadUint32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>o<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span>    <span class="token punctuation">&#125;</span>    o<span class="token punctuation">.</span>m<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> o<span class="token punctuation">.</span>m<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> o<span class="token punctuation">.</span>done <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">&#123;</span>        <span class="token keyword">defer</span> atomic<span class="token punctuation">.</span><span class="token function">StoreUint32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>o<span class="token punctuation">.</span>done<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"sync"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">var</span> once sync<span class="token punctuation">.</span>Once<span class="token keyword">var</span> onceBody <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Only Once"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">&#123;</span>        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            once<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span>onceBody<span class="token punctuation">)</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"i="</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【青训营】—Go语言进阶与依赖管理</title>
      <link href="/2023/07/26/qing-xun-ying-go-yu-yan-gong-cheng-shi-jian/"/>
      <url>/2023/07/26/qing-xun-ying-go-yu-yan-gong-cheng-shi-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="01"><a href="#01" class="headerlink" title="01"></a>01</h1><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>多线程程序在一个核的CPU上运行</p><h3 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a><em>Goroutine</em></h3><p>协程：用户态，轻量级线程，栈KB级别</p><p>线程：内核态，线程跑多个协程，栈MB级别</p><p>在函数前加关键字<em>go</em>创建协程</p><h3 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h3><p>通过通信共享内存</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-26%20130455.png"></p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p><em><strong>make(chan 元素类型, [缓冲大小])</strong></em></p><p>有缓冲通道</p><p><em>make(chan int，2)</em></p><p>无缓冲通道&#x2F;同步通道</p><p><em>make(chan int)</em></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-26%20130759.png"></p><h3 id="并发安全LOCK"><a href="#并发安全LOCK" class="headerlink" title="并发安全LOCK"></a>并发安全LOCK</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-26%20131454.png"></p><h3 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h3><p>实现并发任务的同步</p><p>内部维护一个计数器</p><p>开启协程+1</p><p>执行结束-1</p><p>主协程阻塞直到计数器为0</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-26%20132056.png"></p><h1 id="02"><a href="#02" class="headerlink" title="02"></a>02</h1><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="Go依赖管理演进"><a href="#Go依赖管理演进" class="headerlink" title="Go依赖管理演进"></a>Go依赖管理演进</h3><p><em>GOPATH-&gt;Go vendor-&gt;Go Module</em></p><h3 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h3><p><em>bin</em></p><p>项目编译的二进制文件</p><p><em>pkg</em></p><p>编译的中间产物</p><p><em>src</em></p><p>项目源码</p><p>项目代码直接以来<em>src</em>下的代码</p><p>通过<em>go get</em>下载最新版本的包到<em>src</em>目录下</p><p>GOPATH无法实现package的多版本控制</p><h3 id="Go-Vender"><a href="#Go-Vender" class="headerlink" title="Go Vender"></a>Go Vender</h3><p>项目目录下增加vendor文件，所有依赖包副本形式放在$ProjectRoot&#x2F;vendor</p><p>依赖寻址方式：vendor&#x3D;&gt;GOPATH</p><p>项目依赖优先从vendor目录下获取</p><p>可能出现依赖冲突，编译出错</p><h3 id="Go-Module"><a href="#Go-Module" class="headerlink" title="Go Module"></a>Go Module</h3><p>通过go.mod文件管理依赖包版本</p><p>通过go get&#x2F;go mod指令工具管理依赖包</p><h3 id="依赖管理-1"><a href="#依赖管理-1" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>配置文件，描述依赖：go.mod</p><p>中心仓库管理依赖库：Proxy</p><p>本地工具：go get&#x2F;mod</p><h3 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-26%20172104.png"></p><p>依赖标识：[Module Path] [Version&#x2F;Pseudo-version]</p><p><strong>语义化版本</strong></p><p>${MAJOR}.${MINOR}.${PATCH}</p><p>不同MAJOR版本可以是不兼容的</p><p>MINOR通常是做一些功能和函数更新</p><p>PATCH通常是做一些bug修复</p><p><strong>commit伪版本</strong></p><p>v.x.0.0-yyyymmmmddffss-gcfdtd145275</p><p>版本前缀-时间戳-十二位哈希值前缀</p><p><strong>关键字</strong></p><p>indirect：为直接导入的依赖模块</p><p>incompatible：标识可能存在一些不兼容的代码逻辑</p><p><strong>go选择版本最低的兼容版本</strong></p><h3 id="依赖分发"><a href="#依赖分发" class="headerlink" title="依赖分发"></a>依赖分发</h3><p><strong>Proxy</strong></p><p>缓存源站中的软件内容</p><p>GOPROXY&#x3D;”<a href="http://proxy1.cn,http//proxy2.cn">http://proxy1.cn,http://proxy2.cn</a> ,direct”</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-26%20173909.png"></p><h3 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-26%20174025.png"></p><h3 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-26%20174113.png"></p><h1 id="03"><a href="#03" class="headerlink" title="03"></a>03</h1><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>回归测试</p><p>集成测试</p><p>单元测试</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-26%20201401.png"></p><h3 id="单元测试—规则"><a href="#单元测试—规则" class="headerlink" title="单元测试—规则"></a>单元测试—规则</h3><ul><li>所有测试文件以_test.go结尾</li><li>func TestXxx(*testing.T)</li><li>初始化逻辑放到TestMain中</li></ul><h3 id="单元测试—运行"><a href="#单元测试—运行" class="headerlink" title="单元测试—运行"></a>单元测试—运行</h3><p><em>go test[flags] [packages]</em></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-26%20201857.png"></p><h3 id="单元测试—覆盖率"><a href="#单元测试—覆盖率" class="headerlink" title="单元测试—覆盖率"></a>单元测试—覆盖率</h3><p>单元测试一般覆盖率为50%~60%，较高覆盖率80%+</p><p>测试分支相互独立、全面覆盖</p><p>测试单元粒度足够小，函数单一负责</p><h3 id="单元测试—依赖"><a href="#单元测试—依赖" class="headerlink" title="单元测试—依赖"></a>单元测试—依赖</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-26%20202633.png"></p><h3 id="单元测试—Mock"><a href="#单元测试—Mock" class="headerlink" title="单元测试—Mock"></a>单元测试—Mock</h3><p>monkey：<a href="http://github.com/bouk/monkey">http://github.com/bouk/monkey</a></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-26%20203057.png"></p><h3 id="组件工具"><a href="#组件工具" class="headerlink" title="组件工具"></a>组件工具</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-26%20204250.png"></p><h3 id="组件以及技术点"><a href="#组件以及技术点" class="headerlink" title="组件以及技术点"></a>组件以及技术点</h3><p><strong>web框架：Gin</strong></p><p>在vscode中生成go.mod文件后，在终端输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go get <span class="token parameter variable">-u</span> github.com/gin-gonic/gin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将gin引入到代码中</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"github.com/gin-gonic/gin"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【青训营】-Go语言原理与实践</title>
      <link href="/2023/07/24/qing-xun-ying-go-yu-yan-yuan-li-yu-shi-jian/"/>
      <url>/2023/07/24/qing-xun-ying-go-yu-yan-yuan-li-yu-shi-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础语法"><a href="#Go语言基础语法" class="headerlink" title="Go语言基础语法"></a>Go语言基础语法</h1><h3 id="Go语言简介"><a href="#Go语言简介" class="headerlink" title="Go语言简介"></a>Go语言简介</h3><p><strong>Go语言</strong>是谷歌出品的一门通用型计算机编程语言</p><ul><li>高性能、高并发</li><li>语法简单</li><li>标准库丰富</li><li>工具链完善</li><li>静态链接</li><li>快速编译</li><li>跨平台</li><li>垃圾回收</li></ul><h3 id="Go的开发环境"><a href="#Go的开发环境" class="headerlink" title="Go的开发环境"></a>Go的开发环境</h3><h4 id="安装Golang"><a href="#安装Golang" class="headerlink" title="安装Golang"></a>安装<em>Golang</em></h4><p><a href="http://go.dev/">官方链接</a></p><p><a href="http://studygolang.com/dl">镜像网站1</a></p><p><a href="http://goproxy.cn/">镜像网站2</a></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-24%20223546.png"></p><h4 id="配置集成开发环境"><a href="#配置集成开发环境" class="headerlink" title="配置集成开发环境"></a>配置集成开发环境</h4><p>选择<em>VScode</em>或<em>Goland</em>即可</p><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p><strong>变量的声明</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"init"</span><span class="token keyword">var</span> b<span class="token punctuation">,</span>c <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token boolean">true</span><span class="token keyword">var</span> e <span class="token builtin">float64</span>f <span class="token operator">:=</span> <span class="token function">float32</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>g <span class="token operator">:=</span> a <span class="token operator">+</span> <span class="token string">"ial"</span><span class="token keyword">const</span> s <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"constant"</span><span class="token keyword">const</span> h <span class="token operator">=</span> <span class="token number">500</span><span class="token keyword">const</span> i <span class="token operator">=</span> <span class="token number">3e20</span> <span class="token operator">/</span> h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em><strong>if else</strong></em></p><p><em>if</em>后的括号可以自动去掉</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-25%20173537.png"></p><p><strong>循环</strong></p><p><em>go</em>中循环只有佛如一种，也无需括号</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-25%20173618.png"></p><p><em><strong>switch</strong></em></p><p>无需<em>break</em></p><p>可以使用任意的变量类型</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-25%20173710.png"></p><p><strong>数组</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-25%20173918.png"></p><p><strong>切片</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-25%20174039.png"></p><p><em><strong>map</strong></em></p><p><em>map[type of key]type of value</em></p><p><em>ok</em>来获取<em>map</em>的<em>key</em>是否存在</p><p><em>map</em>是完全无序的</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-25%20174358.png"></p><p><em><strong>range</strong></em></p><p>对于数组，第一个值<em>（i）</em>为索引，第二个值<em>（num）</em>为索引对应的值</p><p>对于<em>map</em>，第一个值为<em>（k）</em>为<em>key</em>，第二个值<em>（v）</em>为<em>value</em></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-25%20175114.png"></p><p><strong>函数</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-25%20191646.png"></p><p><strong>指针</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-25%20191747.png"></p><p><strong>结构体</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-25%20191903.png"></p><p><strong>结构体方法（类成员函数）</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-25%20192055.png"></p><p><strong>错误处理</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-25%20192202.png"></p><p><strong>字符串操作</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-25%20192429.png"></p><p><strong>字符串格式化</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-25%20192551.png"></p><p><strong>JSON处理</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-25%20192824.png"></p><p><strong>时间处理</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-25%20193019.png"></p><p> <strong>数字解析</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-25%20194537.png"></p><p><strong>进程信息</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-25%20194654.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录—回溯算法</title>
      <link href="/2023/07/13/suan-fa-shua-ti-ji-lu-hui-su-suan-fa/"/>
      <url>/2023/07/13/suan-fa-shua-ti-ji-lu-hui-su-suan-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="回溯算法理论基础"><a href="#回溯算法理论基础" class="headerlink" title="回溯算法理论基础"></a>回溯算法理论基础</h3><p>回溯法一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定的规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独</li></ul><p><strong>回溯法解决的问题都可以抽象为树形结构</strong></p><p><strong>集合的大小构成的树的宽度，递归的深度构成了树的深度</strong></p><p><strong>回溯法的三个要点</strong>：</p><ul><li><p>回溯函数<em>backtracking</em>模板以及参数</p><p>返回值一般为<em>void</em></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void backtracking(参数)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>回溯函数终止条件</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(终止条件)&#123;    存放结果;    return;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>回溯搜索的遍历过程</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(选择：本层集合中元素（树中节点孩子的数量就是集合的大小）)&#123;    处理节点;    backtracking（路径，选择列表）;    回溯，撤销处理结果&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77.组合"></a>77.组合</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;private:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; path;    void backtracking(int n, int k, int startIndex)    &#123;        if(path.size() &#x3D;&#x3D; k)        &#123;            result.push_back(path);            return;        &#125;        for(int i&#x3D;startIndex;i&lt;&#x3D;n;i++)        &#123;            path.push_back(i);            backtracking(n, k, i+1);            path.pop_back();        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k)    &#123;        backtracking(n, k, 1);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="216-组合总和Ⅲ"><a href="#216-组合总和Ⅲ" class="headerlink" title="216.组合总和Ⅲ"></a>216.组合总和Ⅲ</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solutiom&#123;private:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; path;    void backtracking(int k, int n, int sum, int startIndex)    &#123;        if(path.size() &#x3D;&#x3D; k)        &#123;            if(sum &#x3D;&#x3D; n) result.push_back(path);            return;        &#125;        for(int i&#x3D;startIndex;i&lt;&#x3D;9;i++)        &#123;            sum +&#x3D;i;            path.push_back(i);            baccktracking(k, n, sum, i+1);            sum -&#x3D;i;            path.pop_back();        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n)    &#123;        backtracking(k, n, 0, 1);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;private:    const string map[10]&#x3D;&#123;        &quot;&quot;,&#x2F;&#x2F;0        &quot;&quot;,&#x2F;&#x2F;1        &quot;abc&quot;,&#x2F;&#x2F;2        &quot;def&quot;,&#x2F;&#x2F;3        &quot;ghi&quot;,&#x2F;&#x2F;4        &quot;jkl&quot;,&#x2F;&#x2F;5        &quot;mno&quot;,&#x2F;&#x2F;6        &quot;pqrs&quot;,&#x2F;&#x2F;7        &quot;tuv&quot;,&#x2F;&#x2F;8        &quot;wxyz&quot;&#x2F;&#x2F;9    &#125;;public:    vector&lt;string&gt; result;    string s;    void backtracking(const string&amp; digits, int index)    &#123;        if(index &#x3D;&#x3D; digits.size())        &#123;            result.push_back(s);            return;        &#125;        int digit &#x3D; digits[index] - &#39;0&#39;;        string letters &#x3D; map[digit];        for(int i&#x3D;0;i &lt; letters.size();i++)        &#123;            s.push_back(letters[i]);            backtracking(digits, index+1);            s.pop_back();        &#125;    &#125;    vector&lt;string&gt; letterCombination(string digits)    &#123;        if(digits.size() &#x3D;&#x3D; 0)        &#123;            return result;        &#125;        backtracking(digits,0);        return result;            &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.组合总和</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;private:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; path;    void backtracking(vector&lt;int&gt;&amp; candicates, int target, int sum, int startindex)    &#123;        if(sum &#x3D;&#x3D; target)        &#123;            result.push_back(path);            return;                    &#125;        for(int i&#x3D;startindex;i &lt; candicates.size() &amp;&amp; sum + candicates[i]&lt;&#x3D;target;i++)        &#123;            sum+&#x3D;candicates[i];            path.push_back(candicates[i]);            backtracking(candicates, target, sum, i);            sum-&#x3D;candicates[i];            path.pop_back();        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candicates, int target)    &#123;        result.clear();        path.clear();        sort(candicates.begin(), candicates.end());        backtracking(candicates, target, 0, 0);        return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="40-组合总和Ⅱ"><a href="#40-组合总和Ⅱ" class="headerlink" title="40.组合总和Ⅱ"></a>40.组合总和Ⅱ</h3><p>去重的是同一树层上使用过的，同一树枝上都是同一组合的元素，不用去重</p><p>并且需要对数组进行<strong>排序</strong></p><p><strong>如果candidates[i] &#x3D;&#x3D; candidates[i-1]且used[i-1] &#x3D;&#x3D; false，说明前一个树枝，使用了candidatea[i-1]，也就是说同一树层使用过candidates[i-1]</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;private:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; path;    void backtracking(vector&lt;int&gt;&amp; candidates, int target, int sum, int startIndex, vector&lt;bool&gt;&amp; used) &#123;        if (sum &#x3D;&#x3D; target) &#123;            result.push_back(path);            return;        &#125;        for (int i &#x3D; startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;&#x3D; target; i++) &#123;            &#x2F;&#x2F; used[i - 1] &#x3D;&#x3D; true，说明同一树枝candidates[i - 1]使用过            &#x2F;&#x2F; used[i - 1] &#x3D;&#x3D; false，说明同一树层candidates[i - 1]使用过            &#x2F;&#x2F; 要对同一树层使用过的元素进行跳过            if (i &gt; 0 &amp;&amp; candidates[i] &#x3D;&#x3D; candidates[i - 1] &amp;&amp; used[i - 1] &#x3D;&#x3D; false) &#123;                continue;            &#125;            sum +&#x3D; candidates[i];            path.push_back(candidates[i]);            used[i] &#x3D; true;            backtracking(candidates, target, sum, i + 1, used); &#x2F;&#x2F; 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次            used[i] &#x3D; false;            sum -&#x3D; candidates[i];            path.pop_back();        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;        vector&lt;bool&gt; used(candidates.size(), false);        path.clear();        result.clear();        &#x2F;&#x2F; 首先把给candidates排序，让其相同的元素都挨在一起。        sort(candidates.begin(), candidates.end());        backtracking(candidates, target, 0, 0, used);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;private:    vector&lt;vector&lt;string&gt;&gt; result;    vector&lt;string&gt; path; &#x2F;&#x2F; 放已经回文的子串    void backtracking (const string&amp; s, int startIndex) &#123;        &#x2F;&#x2F; 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了        if (startIndex &gt;&#x3D; s.size()) &#123;            result.push_back(path);            return;        &#125;        for (int i &#x3D; startIndex; i &lt; s.size(); i++) &#123;            if (isPalindrome(s, startIndex, i)) &#123;   &#x2F;&#x2F; 是回文子串                &#x2F;&#x2F; 获取[startIndex,i]在s中的子串                string str &#x3D; s.substr(startIndex, i - startIndex + 1);                path.push_back(str);            &#125; else &#123;                                &#x2F;&#x2F; 不是回文，跳过                continue;            &#125;            backtracking(s, i + 1); &#x2F;&#x2F; 寻找i+1为起始位置的子串            path.pop_back(); &#x2F;&#x2F; 回溯过程，弹出本次已经添加的子串        &#125;    &#125;    bool isPalindrome(const string&amp; s, int start, int end) &#123;        for (int i &#x3D; start, j &#x3D; end; i &lt; j; i++, j--) &#123;            if (s[i] !&#x3D; s[j]) &#123;                return false;            &#125;        &#125;        return true;    &#125;public:    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;        result.clear();        path.clear();        backtracking(s, 0);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Morris算法</title>
      <link href="/2023/07/10/morris-suan-fa/"/>
      <url>/2023/07/10/morris-suan-fa/</url>
      
        <content type="html"><![CDATA[<p><em>Morris</em>算法可以将二叉树遍历的空间复杂度降到<em>O(1)</em></p><h1 id="Morris遍历的实现"><a href="#Morris遍历的实现" class="headerlink" title="Morris遍历的实现"></a><em>Morris</em>遍历的实现</h1><h3 id="Morris遍历的规则"><a href="#Morris遍历的规则" class="headerlink" title="Morris遍历的规则"></a>Morris遍历的规则</h3><p>当前节点为<em><strong>cur</strong></em></p><p>开始时<em><strong>cur</strong></em>指向一整棵树的头节点</p><p>-<strong><em>cur</em>无左子树</strong></p><p><em><strong>cur</strong></em>向右移动（<em><strong>cur&#x3D;cur.right</strong></em>）</p><p>-<strong><em>cur</em>有左子树</strong></p><p>找到<em><strong>cur</strong></em>左子树上最右的节点，记为<em><strong>mostright</strong></em></p><p>如果<em>mostright</em>的<em>right</em>指针指向NULL，让其指向<em>cur</em>（<em>mostright.right&#x3D;cur</em>），<em>cur</em>向左移动（<em>cur&#x3D;cur.left</em>）</p><p>如果<em>mostright</em>的<em>right</em>指针指向<em>cur</em>，让其指向<em>NULL</em>（<em>mostright.right&#x3D;NULL）</em>，<em>cur</em>向右移动（<em>cur&#x3D;cur.right</em>）</p><p><strong>没有左子树的节点只到达一次，有左子树的节点到达两次</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">public static void morris(Node head)&#123;    if(head &#x3D;&#x3D; null) return;    Node cur &#x3D; head;    Node mostright &#x3D; NULL;    while(cur !&#x3D; NULL)    &#123;        mostright &#x3D; cur.left;        if(mostright !&#x3D; NULL) &#x2F;&#x2F;有左树        &#123;            while(mostright.right !&#x3D; NULL &amp;&amp; mostright.right !&#x3D; cur)                mostright &#x3D; mostright.right; &#x2F;&#x2F;找到最右的节点            if(mostright.right &#x3D;&#x3D; NULL)            &#123;                mostright.right &#x3D; cur;                cur &#x3D; cur.left;                continue;            &#125;            else            &#123;                mostright.right &#x3D; NULL;            &#125;                    &#125;        cur &#x3D; cur.right;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>先序遍历</strong>：第一次到达就打印</p><p><strong>中序遍历</strong>：只能到达一次的节点直接打印，能到达第二次的节点第二次打印</p><p><strong>后序遍历</strong>：第二次到达节点的时候打印节点左子树的逆序右边界</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git使用</title>
      <link href="/2023/07/06/git-shi-yong/"/>
      <url>/2023/07/06/git-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>Git 是一个开源的分布式的版本控制系统</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>克隆Git资源位工作目录</p><p>在克隆的资源上添加或修改文件</p><p>更新资源</p><p>在提交前查看修改状态</p><p>提交修改</p><p>修改完成后，可以撤回提交并再次修改提交</p><h3 id="Git工作区、暂存区、版本库"><a href="#Git工作区、暂存区、版本库" class="headerlink" title="Git工作区、暂存区、版本库"></a>Git工作区、暂存区、版本库</h3><p><strong>工作区</strong>：电脑里能看到的目录</p><p><strong>暂存区</strong>：<strong>stage 或 index</strong>，一般放在 <strong>.git</strong> 目录下的<strong>index</strong>文件（**.git&#x2F;index**）中，也叫做索引</p><p><strong>版本库</strong>：工作区有一个隐藏目录，**.git** ，实际上是Git的本地版本仓库</p><h3 id="Git基本命令"><a href="#Git基本命令" class="headerlink" title="Git基本命令"></a>Git基本命令</h3><p><strong>创建版本库</strong></p><p>创建一个gitspace空目录（可选），用作以后创建本地版本仓库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mkdir</span> <span class="token builtin class-name">test</span> <span class="token comment">#创建目录</span>$ <span class="token builtin class-name">cd</span> <span class="token builtin class-name">test</span> <span class="token comment">#进入目录</span>$ <span class="token builtin class-name">pwd</span>/d/gitspace/test$ <span class="token function">git</span> init <span class="token comment">#初始化当前仓库</span>Initialized empty Git respository <span class="token keyword">in</span> D:/gitspace/test/.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>.git</em> 目录是Git用来跟踪管理版本仓库的</p><p>可使用<em>ls -ah</em>查看隐藏目录</p><p><strong>新建文件</strong></p><p>-<em>add</em>：将文件添加到缓存区</p><p>-<em>commit</em>：提交到本地仓库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">touch</span> test.c <span class="token comment">#创建新文件</span>$ <span class="token function">git</span> <span class="token function">add</span> test.c <span class="token comment">#将文件添加到本地仓库的提交缓存</span><span class="token comment">#简单描述我们做了什么 使用-m命令简写描述信息</span>$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"add new file <span class="token entity" title="\&quot;">\"</span>test.c<span class="token entity" title="\&quot;">\"</span>"</span>$ <span class="token function">git</span> status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>版本回退</strong></p><p><em>git log</em>命令显示从最近到最远的提交日志</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token comment">#查看日志记录</span>$ <span class="token function">git</span> log <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> reset <span class="token parameter variable">--hard</span> HEAD^ <span class="token comment">#回到第一个版本</span>$ <span class="token function">git</span> reset <span class="token parameter variable">--hard</span> 7fs9vj47 <span class="token comment">#版本号写出前8位即可</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><em>Git</em>内部有个指向当前版本的<em>HEAD</em>指针，当回退版本时，<em>Git</em>仅仅是把<em>HEAD</em>指向当前的版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token comment">#查看日志</span>$ <span class="token function">git</span> reflog <span class="token comment">#展示每次的命令，commit id</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Git的管理和修改</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">diff</span> HEAD -- 文件名 <span class="token comment">#对比工作区和本地仓库中文件的区别</span>$ <span class="token function">git</span> restore 文件名 <span class="token comment">#撤销文件在工作区做的修改</span>$ <span class="token function">git</span> checkout -- 文件名 <span class="token comment">#不能撤销已经添加到暂存区的内容</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> restore <span class="token parameter variable">--staged</span> 文件名 <span class="token comment">#从暂存区撤回，退回到工作状态</span>$ <span class="token function">git</span> reset HEAD 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Git删除文件</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">rm</span> 文件名 <span class="token comment">#仅删除工作区的文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">rm</span> 文件名 <span class="token comment">#同时删除工作区和暂存区的文件</span>$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"commit del 文件名"</span> <span class="token comment">#将删除修改提交到版本库中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Selenium-Webdrier框架的使用</title>
      <link href="/2023/07/04/selenium-webdrier-kuang-jia-de-shi-yong/"/>
      <url>/2023/07/04/selenium-webdrier-kuang-jia-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Webdriver"><a href="#Webdriver" class="headerlink" title="Webdriver"></a>Webdriver</h1><p>面向对象的API</p><p>有效的驱动浏览器</p><h2 id="操作浏览器的基本方法"><a href="#操作浏览器的基本方法" class="headerlink" title="操作浏览器的基本方法"></a>操作浏览器的基本方法</h2><h3 id="打开网页"><a href="#打开网页" class="headerlink" title="打开网页"></a>打开网页</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#导入Webdriver模块</span><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token comment">#打开浏览器</span>driver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#谷歌</span><span class="token comment">#driver = webdriver.Firefox() 火狐</span><span class="token comment">#driver = webdriver.Ie() IE</span><span class="token comment">#打开网站</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"http://www.baidu.com"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置休眠"><a href="#设置休眠" class="headerlink" title="设置休眠"></a>设置休眠</h3><p>由于打开网址后，页面加载需要几秒钟，定时等待几秒钟等到页面加载完毕后再进行下一步操作</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token keyword">import</span> timedriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chorme<span class="token punctuation">(</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"http://ww.baidu.com"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="页面刷新"><a href="#页面刷新" class="headerlink" title="页面刷新"></a>页面刷新</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">driver<span class="token punctuation">.</span>refresh<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="页面切换"><a href="#页面切换" class="headerlink" title="页面切换"></a>页面切换</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#返回上一页</span>driver<span class="token punctuation">.</span>back<span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">#切换到下一页</span>driver<span class="token punctuation">.</span>forward<span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置窗口大小"><a href="#设置窗口大小" class="headerlink" title="设置窗口大小"></a>设置窗口大小</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#设置窗口大小</span>driver<span class="token punctuation">.</span>set_window_size<span class="token punctuation">(</span><span class="token number">1920</span><span class="token punctuation">,</span> <span class="token number">1080</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">#将浏览器窗口最大化</span>driver<span class="token punctuation">.</span>maximxze_window<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h3><p>截屏后可以设置保存路径+文件名+后缀</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">driver<span class="token punctuation">.</span>get_screenshot_as_file<span class="token punctuation">(</span><span class="token string">"D//screenshot.jpg"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>退出有两种方式</p><p>close：关闭当前窗口</p><p>quit：结束进程，关闭所有窗口</p><p>结束测试用quit，可以回收c盘的临时文件</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">driver<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="请求浏览器信息"><a href="#请求浏览器信息" class="headerlink" title="请求浏览器信息"></a>请求浏览器信息</h3><p>包括窗口句柄、浏览器尺寸位置、cookie</p><h3 id="建立等待策略"><a href="#建立等待策略" class="headerlink" title="建立等待策略"></a>建立等待策略</h3><p>在尝试定位元素之前，确保该元素位于页面上，并且在尝试与该元素交互之前，该元素处于可交互状态</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">driver<span class="token punctuation">.</span>implicitly_wait<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="发送命令、查找元素"><a href="#发送命令、查找元素" class="headerlink" title="发送命令、查找元素"></a>发送命令、查找元素</h3><p>在Selenium会话中，要先找到元素才能与其交互</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">text_box <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>by<span class="token operator">=</span>By<span class="token punctuation">.</span>NAME<span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">"my-text"</span><span class="token punctuation">)</span>submit_button <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>by<span class="token operator">=</span>By<span class="token punctuation">.</span>CSS_SELECTOR<span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">"button"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">text_box<span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span><span class="token string">"Selenuium"</span><span class="token punctuation">)</span>submit_button<span class="token punctuation">.</span>click<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="获取元素信息"><a href="#获取元素信息" class="headerlink" title="获取元素信息"></a>获取元素信息</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">value <span class="token operator">=</span> message<span class="token punctuation">.</span>text<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>下面是一个简单脚本</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>common<span class="token punctuation">.</span>by <span class="token keyword">import</span> Bydriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"http://ww.baidu.com"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token comment">#查找元素</span>search_box <span class="token operator">=</span> chrome<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>NAME<span class="token punctuation">,</span> <span class="token string">'q'</span><span class="token punctuation">)</span><span class="token comment">#模拟按键输入</span>search_box<span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span><span class="token string">'ChromeDriver'</span><span class="token punctuation">)</span><span class="token comment">#搜索框模拟回车</span>search_box<span class="token punctuation">.</span>submit<span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【MIT6.S81】-Lab1</title>
      <link href="/2023/06/30/mit6.s81-lab1/"/>
      <url>/2023/06/30/mit6.s81-lab1/</url>
      
        <content type="html"><![CDATA[<p>课程链接</p><p><strong>MIT6.S081</strong>：<a href="https://pdos.csail.mit.edu/6.828/2020/overview.html">https://pdos.csail.mit.edu/6.828/2020/overview.html</a></p><p>在做到lab3时卡壳，准备重新看一下前面的内容再继续实验，感觉对前面的内容理解的还是不透彻，所以在文档中加入一些6.S081的相关内容</p><h1 id="Chapter-1-Operating-system-interfaces"><a href="#Chapter-1-Operating-system-interfaces" class="headerlink" title="Chapter 1: Operating system interfaces"></a>Chapter 1: Operating system interfaces</h1><h2 id="1-1-process-and-memory"><a href="#1-1-process-and-memory" class="headerlink" title="1.1 process and memory"></a>1.1 process and memory</h2><blockquote><p>**int fork(): **创建一个新的进程，在父进程中返回子进程的PID， 在子进程中返回0</p><p>**int exit(int status): **终止现有的进程，释放资源，将结束进程的状态报告给wait()</p><p>**int wait(int *status): **返回刚刚结束的子进程的PID，将子进程的退出状态复制到传入wait()的地址，若调用wait的进程无子进程，则返回-1，若无子进程终止，则继续等待</p><p>**int exec(char *file, char *argv[]): **加载文件并传参运行</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"echo"</span><span class="token punctuation">;</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"/bin/echo"</span><span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"exec error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>xv6<strong>shell</strong>利用以上调用来代替用户运行程序</p><p>xv6<strong>shell</strong>的代码如下</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161324.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161423.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161454.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161526.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161611.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161651.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161727.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161755.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161831.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161903.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161929.png"></p><blockquote><p>当shell开始运行时，main函数首先通过getcmd来获取用户输入，接着调用fork，创建一个子进程，在子进程中调用runcmd函数，runcmd函数再通过exec来运行用户输入的命令，在exec中会调用exit来退出子进程返回到父进程，对应的是父进程的wait函数。</p></blockquote><h2 id="1-2-I-x2F-O-and-file-descriptors"><a href="#1-2-I-x2F-O-and-file-descriptors" class="headerlink" title="1.2 I&#x2F;O and file descriptors"></a>1.2 I&#x2F;O and file descriptors</h2><blockquote><p>文件描述符是一个小整数，表示进程可以读取或写入的内核管理对象。</p></blockquote><p>文件描述符将不同的文件抽象成字节流。</p><p>xv6 内核使用文件描述符作为每个进程表的索引，以便每个进程都有一个从零开始的文件描述符的私有空间。通常情况下，0代表读，1代表写，2代表错误。</p><p>&#x3D;&#x3D;新分配的文件描述符始终是当前进程中编号最小的未使用描述符。&#x3D;&#x3D;</p><p>下图中，子进程会关闭0，再将0用于input.txt，cat在使用0来执行</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-20%20101621.png"></p><blockquote><p>为什么fork和exec要分别定义为不同的系统调用？</p><p>将fork和exec分开定义可以再不干扰主shell I&#x2F;O设置的情况下重定向子进程的I&#x2F;O</p></blockquote><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-20%20103047.png"></p><p>&#x3D;&#x3D;两个文件描述符共享offset的情况：这两个文件描述符是必须从fork或者dup调用中的原始文件描述符中产生的&#x3D;&#x3D;</p><h2 id="1-3-pipe"><a href="#1-3-pipe" class="headerlink" title="1.3 pipe"></a>1.3 pipe</h2><blockquote><p>A pipe is a small kernel buffer exposed to processes as a pair of file descriptors, one for reading and one for writing.</p><p>管道是一个小的内核缓冲区，作为一对文件描述符暴露给进程，一个用于读取，一个用于写入。</p></blockquote><p><strong>wc中对pipe的简单应用：</strong></p><p>如果pipe的读端无可读数据，pipe等待数据写入或等待写入端的所有文件描述符关闭，在后一种情况下，read 将返回 0，就像已到达数据文件末尾一样，所以及时关闭pipe的写端是很有必要的</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-20%20105442.png"></p><p>xv6<strong>shell</strong>实现管道如下图代码所示(user&#x2F;sh.c:100)，例如grep fork sh.c | wc -1</p><p>和wc中类似，子进程创建pipe连接”|“的左右两端</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161454.png"></p><h2 id="1-4-file-system"><a href="#1-4-file-system" class="headerlink" title="1.4 file system"></a>1.4 file system</h2><p>这部分内容比较简单，xv6 book中已详细说明，此处不再赘述。</p><h1 id="Lab-Xv6-and-Unix-utilities"><a href="#Lab-Xv6-and-Unix-utilities" class="headerlink" title="Lab: Xv6 and Unix utilities"></a>Lab: Xv6 and Unix utilities</h1><h2 id="Lab-guidance"><a href="#Lab-guidance" class="headerlink" title="Lab guidance"></a>Lab guidance</h2><p>调试技巧</p><p>以下是调试解决方案的一些提示：</p><ul><li>确保您了解 C 和指针。 Kernighan 和 Ritchie 所著的《C 编程语言（第二版）》一书对 C 进行了简洁的描述。<a href="https://pdos.csail.mit.edu/6.828/2019/lec/pointers.c">这里</a>有一些有用的指针练习。 除非您已经精通 C 语言，否则请勿跳过或浏览上面的指针练习。 如果你不真正理解 C 中的指针，你将在实验室中遭受难以言喻的痛苦和痛苦，然后最终以艰难的方式理解它们。 相信我们; 你不想知道什么是“艰难的道路”。</li><li>如果您的练习部分有效，请通过提交代码来检查进度。 如果您稍后破坏了某些内容，则可以回滚到检查点并以较小的步骤前进。 要了解有关 Git 的更多信息，请查看 <a href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html">Git 用户手册</a>，或者您可能会发现此<a href="">面向 CS 的 Git 概述</a><a href="http://eagain.net/articles/git-for-computer-scientists/%E5%BE%88%E6%9C%89%E7%94%A8%E3%80%82">http://eagain.net/articles/git-for-computer-scientists/很有用。</a></li><li>如果测试失败，请确保您了解代码未通过测试的原因。 插入打印语句，直到您了解发生了什么。</li><li>您可能会发现您的 print 语句可能会产生很多您想要搜索的输出； 一种方法是在<em>script</em>内运行 <em>make qemu</em> （在您的计算机上运行 <em>man script</em>），它将所有控制台输出记录到一个文件中，然后您可以搜索该文件。 不要忘记退出<em>script</em>。</li><li>在许多情况下，打印语句就足够了，但有时能够单步执行某些汇编代码或检查堆栈上的变量会很有帮助。 要将 <em>gdb</em> 与 <em>xv6</em> 一起使用，请在一个窗口中运行  <em>make qemu-gdb</em>，在另一个窗口中运行 <em>gdb</em>（或 <em>riscv64-linux-gnu-gdb</em>），设置一个断点，然后是“c”（<em>continue</em>）和 <em>xv6</em> 将运行直到到达断点。 （有关有用的 <em>GDB</em> 提示，请参阅使用 <a href="https://pdos.csail.mit.edu/6.828/2019/lec/gdb_slides.pdf">GNU 调试器</a>。</li><li>如果您想查看编译器为内核生成的程序集是什么，或者想了解特定内核地址处的指令是什么，请查看文件 <em>kernel.asm</em>，该文件是 Makefile 在编译内核时生成的。 （Makefile 还为所有用户程序生成 <em>.asm</em>。）</li><li>如果内核<em>panics</em>，它将打印一条错误消息，列出崩溃时程序计数器的值； 您可以搜索 <em>kernel.asm</em> 以找出程序计数器崩溃时所在的函数，或者您可以运行 <em>addr2line -e kernel&#x2F;kernel pc-value</em> （运行 <em>man addr2line</em> 了解详细信息）。 如果你想获得回溯，请使用 <em>gdb8 重新启动：在一个窗口中运行“</em>make qemu-gdb<em>”，在另一个窗口中运行 <em>gdb</em>（或 <em>riscv64-linux-gnu-gdb</em>），在</em>panic<em>中设置断点（“</em>b panic<em>”），然后 by 后跟“c”（</em>continue<em>）。 当内核到达断点时，输入“</em>bt*”以获取回溯。</li><li>如果您的内核挂起（例如，由于死锁）或无法进一步执行（例如，由于执行内核指令时出现页面错误），您可以使用 <em>gdb</em> 找出挂起的位置。 在一个窗口中运行<em>make qemu-gdb</em>，在另一个窗口中运行 <em>gdb</em>   ( <em>riscv64-linux-gnu-gdb</em>)，然后运行“c”（<em>continue</em>）。 当内核出现挂起时，在 <em>qemu-gdb</em> 窗口中按 <em>Ctrl-C</em> 并输入“bt”以获取回溯。</li><li><em>qemu</em> 有一个“监视器”，可以让您查询模拟机器的状态。 您可以通过输入<em>control-a c</em>（“c”代表控制台）来获取它。 一个特别有用的监视命令是 <em>info mem</em>，用于打印页表。 您可能需要使用 cpu 命令来选择要查看哪个核心信息 <em>mem</em>，或者您可以使用 <em>make CPUS&#x3D;1 qemu</em> 来启动 *qemu8，以导致只有一个核心。</li></ul><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>VMware：<a href="https://www.vmware.com/cn.html">https://www.vmware.com/cn.html</a></p><p>Ubuntu20.04：<a href="https://ubuntu.com/download/desktop/thank-you?version=20.04.2.0&architecture=amd64">https://ubuntu.com/download/desktop/thank-you?version=20.04.2.0&amp;architecture=amd64</a></p><p><strong>尽量使用20.04版本进行环境的搭建，不然容易出现错误</strong></p><p>安装后还需要进行更换软件源等初步准备工作，这里不在赘述</p><p><strong>安装xv6</strong></p><p>打开终端，输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">git</span> build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu libglib2.0-dev libpixman-1-dev gcc-riscv64-unknown-elf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>下载xv6源码</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone git://g.csail.mit.edu/xv6-labs-2020<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> xv6-riscv<span class="token function">make</span> qemu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>gdb调试</strong></p><p>打开一个终端窗口，输入 <em>make-gdb</em></p><p>再打开一个终端窗口，输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"add-auto-load-safe-path YOUR_PATH/xv6-riscv/.gdbinit "</span> <span class="token operator">>></span> ~/.gdbinit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入<em>gdb-multiarch</em></p><p>接下来就可以进行调试了</p><p><strong>退出qemu</strong>：按下ctrl - a 放开后按x（之前一直搞错，要放开ctrl - a以后在按x）</p><h2 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h2><p>为 xv6 实现 UNIX 程序 sleep； sleep应该暂停用户指定的ticks。 时钟周期是 xv6 内核定义的时间概念，即定时器芯片两次中断之间的时间。 您的解决方案应该位于文件user&#x2F;sleep.c中</p><p>原文如下</p><blockquote><p>Implement the UNIX program <code>sleep</code> for xv6; your <code>sleep</code> should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file <code>user/sleep.c</code>.</p></blockquote><p>提示：</p><ul><li>在开始编码之前，请阅读 <a href="https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf">xv6</a> 书的第一章。</li><li>查看 user&#x2F; 中的一些其他程序（例如 user&#x2F;echo.c、user&#x2F;grep.c 和 user&#x2F;rm.c），了解如何获取传递给程序的命令行参数。</li><li>如果用户忘记传递参数，sleep 应该打印一条错误消息。</li><li>命令行参数作为字符串传递；您可以使用 atoi 将其转换为整数（请参阅 user&#x2F;ulib.c）。</li><li>使用系统调用sleep。</li><li>请参阅 kernel&#x2F;sysproc.c 了解实现 sleep 系统调用的 xv6 内核代码（查找 sys_sleep），参见 user&#x2F;user.h 了解可从用户程序调用 sleep 的 C 定义，以及 user&#x2F;usys.S 了解汇编代码从用户代码跳转到内核的sleep。</li><li>确保 main 调用 exit() 以退出程序。</li><li>将你的睡眠程序添加到Makefile中的UPROGS中；完成此操作后，make qemu 将编译您的程序，您将能够从 xv6 shell 运行它。</li><li>查看 Kernighan 和 Ritchie 的书《C 编程语言（第二版）》（K&amp;R）来了解 C。</li></ul><p>原文如下</p><blockquote><p>Some hints:</p><ul><li>Before you start coding, read Chapter 1 of the <a href="https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf">xv6 book</a>.</li><li>Look at some of the other programs in <code>user/</code> (e.g., <code>user/echo.c</code>, <code>user/grep.c</code>, and <code>user/rm.c</code>) to see how you can obtain the command-line arguments passed to a program.</li><li>If the user forgets to pass an argument, sleep should print an error message.</li><li>The command-line argument is passed as a string; you can convert it to an integer using <code>atoi</code> (see user&#x2F;ulib.c).</li><li>Use the system call <code>sleep</code>.</li><li>See <code>kernel/sysproc.c</code> for the xv6 kernel code that implements the <code>sleep</code> system call (look for <code>sys_sleep</code>), <code>user/user.h</code> for the C definition of <code>sleep</code> callable from a user program, and <code>user/usys.S</code> for the assembler code that jumps from user code into the kernel for <code>sleep</code>.</li><li>Make sure <code>main</code> calls <code>exit()</code> in order to exit your program.</li><li>Add your <code>sleep</code> program to <code>UPROGS</code> in Makefile; once you’ve done that, <code>make qemu</code> will compile your program and you’ll be able to run it from the xv6 shell.</li><li>Look at Kernighan and Ritchie’s book <em>The C programming language (second edition)</em> (K&amp;R) to learn about C.</li></ul></blockquote><p>传入main函数的argc表示参数的个数，argv[]表示传入的参数，argv[0]通常为，命令名</p><p>完整代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/stat.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//传入的参数个数不为2，即不是sleep 3格式的</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"Usage: sleep..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//exit传入参数1表示错误结束</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//exit传入参数0表示成功结束</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外，还要在Makefile的UPROGS中加入sleep函数</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$U</span>/_sleep<span class="token punctuation">\</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Pingpong"><a href="#Pingpong" class="headerlink" title="Pingpong"></a>Pingpong</h2><p>编写一个程序，使用 UNIX 系统调用通过一对管道（每个方向一个）在两个进程之间“pingpong”一个字节。 父进程应向子进程发送一个字节； 子进程应打印“<pid>：已收到 ping”，其中 <pid> 是其进程 ID，将管道上的字节写入到父进程，然后退出； 父进程应该从子进程读取字节，打印“<pid>：收到 pong”，然后退出。 您的解决方案应该位于文件 user&#x2F;pingpong.c 中。</p><p>原文如下</p><blockquote><p>Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “<pid>: received ping”, where <pid> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “<pid>: received pong”, and exit. Your solution should be in the file <code>user/pingpong.c</code>.</p></blockquote><p>提示：</p><ul><li>使用pipe创建一个管道</li><li>使用fork创建一个子进程</li><li>使用read来读管道，write来写管道</li><li>使用 getpid 查找调用进程的进程 ID</li><li>将程序添加到 Makefile 中的 UPROGS 中</li><li>xv6 上的用户程序具有一组有限的可用库函数。您可以在 user&#x2F;user.h 中看到该列表；源代码（系统调用除外）位于 user&#x2F;ulib.c、user&#x2F;printf.c 和 user&#x2F;umalloc.c 中</li></ul><p>原文如下</p><blockquote><p>Some hints:</p><ul><li>Use <code>pipe</code> to create a pipe.</li><li>Use <code>fork</code> to create a child.</li><li>Use <code>read</code> to read from the pipe, and <code>write</code> to write to the pipe.</li><li>Use <code>getpid</code> to find the process ID of the calling process.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li><li>User programs on xv6 have a limited set of library functions available to them. You can see the list in <code>user/user.h</code>; the source (other than for system calls) is in <code>user/ulib.c</code>, <code>user/printf.c</code>, and <code>user/umalloc.c</code>.</li></ul></blockquote><p>完整代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/stat.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token keyword">int</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> p1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> p2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">pipe</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//father-to-child</span><span class="token function">pipe</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//child-to-father</span><span class="token keyword">if</span><span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"Usage: pingpong"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//in child</span><span class="token function">close</span><span class="token punctuation">(</span>p1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//close the write side of the pipe(father-to-child)</span><span class="token comment">//child start to read</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>p1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"%d:received ping"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"%d received failed!"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">close</span><span class="token punctuation">(</span>p2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//close the read side of the pipe(child-to-father)</span><span class="token function">write</span><span class="token punctuation">(</span>p2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"pong\n"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//child start to write</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token comment">//in father</span><span class="token function">close</span><span class="token punctuation">(</span>p1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//close the read side of the pipe(father-to-child)</span><span class="token function">write</span><span class="token punctuation">(</span>p1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"ping\n"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//father start to write</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>p2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//close the write side of the pipe(child-to-father)</span><span class="token comment">//father start to read</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>p2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"%d:received ping"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"%d received failed!"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Primes"><a href="#Primes" class="headerlink" title="Primes"></a>Primes</h2><p>使用管道编写素数筛的并发版本。这个想法源自 Unix 管道的发明者 Doug McIlroy。<a href="http://swtch.com/~rsc/thread/">本页</a>中间的图片和周围的文字解释了如何操作。您的解决方案应该位于文件 user&#x2F;primes.c 中。</p><p>原文如下</p><blockquote><p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a href="http://swtch.com/~rsc/thread/">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</p></blockquote><p>您的目标是使用pipe和fork来设置管道。第一个进程将数字 2 到 35 输入管道。对于每个质数，您将安排创建一个进程，通过管道从其左邻居读取数据，并通过另一管道向其右邻居写入数据。由于xv6的文件描述符和进程数量有限，第一个进程可以停在35</p><p>原文如下</p><blockquote><p>Your goal is to use <code>pipe</code> and <code>fork</code> to set up the pipeline. The first process feeds the numbers 2 through 35 into the pipeline. For each prime number, you will arrange to create one process that reads from its left neighbor over a pipe and writes to its right neighbor over another pipe. Since xv6 has limited number of file descriptors and processes, the first process can stop at 35.</p></blockquote><p>提示：</p><ul><li>请小心关闭进程不需要的文件描述符，否则您的程序将在第一个进程达到 35 之前耗尽资源来运行 xv6。</li><li>一旦第一个进程达到 35，它应该等待整个管道终止，包括所有子进程、孙进程等。 因此，主 primes 进程仅应在所有输出打印完毕以及所有其他 primes 进程退出后退出。</li><li>提示：当管道的写入端关闭时，read返回零。</li><li>最简单的方法是直接将 32 位（4 字节）整数写入管道，而不是使用格式化的 ASCII I&#x2F;O</li><li>您应该仅在需要时在管道中创建进程</li><li>将程序添加到 Makefile 中的 UPROGS 中。</li></ul><p>原文如下</p><blockquote><p>Some hints:</p><ul><li>Be careful to close file descriptors that a process doesn’t need, because otherwise your program will run xv6 out of resources before the first process reaches 35.</li><li>Once the first process reaches 35, it should wait until the entire pipeline terminates, including all children, grandchildren, &amp;c. Thus the main primes process should only exit after all the output has been printed, and after all the other primes processes have exited.</li><li>Hint: <code>read</code> returns zero when the write-side of a pipe is closed.</li><li>It’s simplest to directly write 32-bit (4-byte) <code>int</code>s to the pipes, rather than using formatted ASCII I&#x2F;O.</li><li>You should create the processes in the pipeline only as they are needed.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li></ul></blockquote><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-12%20155809.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> prime<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>prime<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"prime %d\n"</span><span class="token punctuation">,</span> prime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> p2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">pipe</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">close</span><span class="token punctuation">(</span>p2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> i<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> prime <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token function">write</span><span class="token punctuation">(</span>p2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">close</span><span class="token punctuation">(</span>p2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">process</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">pipe</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// parent</span>        <span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"prime 2\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">35</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">write</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">process</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>编写一个简单版本的 UNIX 查找程序：查找目录树中具有特定名称的所有文件。您的解决方案应该位于文件 user&#x2F;find.c 中。</p><blockquote><p>Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file <code>user/find.c</code>.</p></blockquote><p>提示：</p><ul><li>查看 user&#x2F;ls.c 以了解如何读取目录</li><li>使用递归允许 find 深入到子目录</li><li>不要递归成“.” 和 ”..”</li><li>文件系统的更改在 qemu 运行期间持续存在； 要获得干净的文件系统，请运行 make clean，然后运行 make qemu</li><li>您需要使用 C 字符串。 看一下 K&amp;R，例如第 5.5 节</li><li>请注意，&#x3D;&#x3D; 并不像 Python 中那样比较字符串。 请改用 strcmp()</li><li>将程序添加到 Makefile 中的 UPROGS 中</li></ul><blockquote><p>Some hints:</p><ul><li>Look at user&#x2F;ls.c to see how to read directories.</li><li>Use recursion to allow find to descend into sub-directories.</li><li>Don’t recurse into “.” and “..”.</li><li>Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu.</li><li>You’ll need to use C strings. Have a look at K&amp;R (the C book), for example Section 5.5.</li><li>Note that &#x3D;&#x3D; does not compare strings like in Python. Use strcmp() instead.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li></ul></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">T_DIR</span> <span class="token expression"><span class="token number">1</span> </span><span class="token comment">//Directory</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">T_FILE</span> <span class="token expression"><span class="token number">2</span> </span><span class="token comment">//File</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">T_DEVICE</span> <span class="token expression"><span class="token number">3</span> </span><span class="token comment">//Device</span></span><span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> dev<span class="token punctuation">;</span> <span class="token comment">//file system's disk device</span>    uint ino<span class="token punctuation">;</span> <span class="token comment">//inode number</span>    <span class="token keyword">short</span> type<span class="token punctuation">;</span> <span class="token comment">//type of file</span>    <span class="token keyword">short</span> nlink<span class="token punctuation">;</span> <span class="token comment">//number of links to file</span>    unit64 size<span class="token punctuation">;</span> <span class="token comment">//size of file in bytes</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/stat.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/fs.h"</span></span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">fmtname</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">static</span> <span class="token keyword">char</span> buf<span class="token punctuation">[</span>DIRSIZ <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> path <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">>=</span> path <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>p <span class="token operator">!=</span> <span class="token char">'/'</span><span class="token punctuation">;</span>p<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  p<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">>=</span> DIRSIZ<span class="token punctuation">)</span> <span class="token keyword">return</span> p<span class="token punctuation">;</span>  <span class="token function">memmove</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> p<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token operator">+</span><span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">,</span> DIRSIZ<span class="token operator">-</span><span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  buf<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> buf<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>fileName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>  <span class="token keyword">int</span> fd<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">stat</span> st<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">dirent</span> de<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"find: cannot open %s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fstat</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>st<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"find: cannot stat %s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//printf("%s %s\n",path, fmtname(path));</span>  <span class="token keyword">switch</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">case</span> T_FILE<span class="token operator">:</span><span class="token comment">//printf("%s\n", fmtname(path));</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token function">fmtname</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">,</span> fileName<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token keyword">case</span> T_DIR<span class="token operator">:</span><span class="token comment">//printf("%s %s\n", path, fmtname(path));</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> DIRSIZ <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> <span class="token keyword">sizeof</span> buf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"find: path too long\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>p <span class="token operator">=</span> buf <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span>p<span class="token operator">++</span> <span class="token operator">=</span> <span class="token char">'/'</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>de<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>de<span class="token punctuation">.</span>inum <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>de<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>de<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">".."</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">continue</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">memmove</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> de<span class="token punctuation">.</span>name<span class="token punctuation">,</span> DIRSIZ<span class="token punctuation">)</span><span class="token punctuation">;</span>  p<span class="token punctuation">[</span>DIRSIZ<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">find</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> fileName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">find</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><p>编写一个简单版本的 UNIX xargs 程序：从标准输入读取行并为每行运行一个命令，将该行作为参数提供给命令。您的解决方案应该位于文件 user&#x2F;xargs.c 中</p><blockquote><p>Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file <code>user/xargs.c</code>.</p></blockquote><p>提示：</p><ul><li>使用 fork 和 exec 在每一行输入上调用命令。 在父级中使用 wait 来等待子级完成命令</li><li>要读取单行输入，请一次读取一个字符，直到出现换行符 (‘\n’)。kernel&#x2F;param.h 声明了 MAXARG，如果您需要声明 argv 数组，这可能很有用。</li><li>将程序添加到 Makefile 中的 UPROGS 中。</li><li>文件系统的更改在 qemu 运行期间持续存在； 要获得干净的文件系统，请运行 make clean，然后运行 make qemu。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/06/25/test/"/>
      <url>/2023/06/25/test/</url>
      
        <content type="html"><![CDATA[<h1 id="test"><a href="#test" class="headerlink" title="test"></a>test</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络：自顶向下—Wireshark实验：HTTP和DNS</title>
      <link href="/2023/06/25/ji-suan-ji-wang-luo-zi-ding-xiang-xia-wireshark-shi-yan-http-he-dns/"/>
      <url>/2023/06/25/ji-suan-ji-wang-luo-zi-ding-xiang-xia-wireshark-shi-yan-http-he-dns/</url>
      
        <content type="html"><![CDATA[<h1 id="Wireshark实验：HTTP"><a href="#Wireshark实验：HTTP" class="headerlink" title="Wireshark实验：HTTP"></a>Wireshark实验：HTTP</h1><p><strong>执行操作：</strong></p><p>1.启动浏览器</p><p>2.启动wireshark数据包嗅探器，在display-filter-specification窗口中输入http，这样就在稍后的分组列表中只捕获http消息</p><p>3.稍等一会开始wireshark数据包捕获</p><p>4.4. 在浏览器中输入以下内容 <a href="http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html">http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html</a> ，您的浏览器应显示非常简单的单行HTML文件</p><ol start="5"><li>停止Wireshark数据包捕获。</li></ol><p>捕获到的http数据包如下图所示</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-11%20202941.png" alt="wireshark截图"></p><p>捕获的消息截图</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-11%20204459.png" alt="wireashark截图"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-11%20204538.png"></p><p>回答下列问题：</p><p>1.您的浏览器是否运行HTTP版本1.0或1.1？服务器运行什么版本的HTTP？</p><p>均匀运行http&#x2F;1.1</p><p>2.您的浏览器会从服务器接收哪种语言？</p><p>无</p><p>3.您的计算机的IP地址是什么？gaia.cs.umass.edu服务器地址呢？</p><p>我的计算机IP地址192.168.31.81</p><p>gaia.cs.umass.edu服务器地址是1.62.64.77</p><p>4.服务器返回到浏览器的状态代码是什么？</p><p>200 OK</p><p>5.服务器上的HTML文件的最近一次修改是什么时候？</p><p>Last-Modified: Thu, 16 Mar 2023 00:28:56</p><p>6.服务器返回多少字节的内容到您的浏览器？</p><p>352</p><p>7.通过检查数据包内容窗口中的原始书就，你是否看到有协议头在数据包列表窗口中未显示？如果是，请举一个例子</p><p>不到有没有</p><p>应该没有</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络自顶向下—第二章部分习题</title>
      <link href="/2023/06/25/ji-suan-ji-wang-luo-zi-ding-xiang-xia-di-er-zhang-bu-fen-xi-ti/"/>
      <url>/2023/06/25/ji-suan-ji-wang-luo-zi-ding-xiang-xia-di-er-zhang-bu-fen-xi-ti/</url>
      
        <content type="html"><![CDATA[<p><strong>P7.假定你在浏览器中点击一条超链接获得web页面。相关联的URL的IP地址没有缓存在本地主机上，因此必须使用DNSlookup以获得该IP地址。如果主机从DNS得到IP地址之前已经访问了n个DNS服务器；相继产生的RTT依次为RTT1,…,RTTn。进一步假定与链路相关的web页面只包含一个对象，即由少量的HTML文本组成。令RTT0表示本地主机和包含对象的服务器之间的RTT值。假定该对象传输时间为零，则从该客户点击该超链接到它接收到该对象需要多长时间？</strong></p><p>从DNS获得服务器的IP地址所需要的时间：<br>$$<br>RTT_1+…+RTT_n<br>$$<br>建立TCP连接，发送对象所需的时间<br>$$<br>2RTT_0<br>$$<br><strong>P8.参照习题P7，假定在同一服务器上某HTML文件引用了8个非常小的对象。忽略发送时间，在下列情况下需要多长时间</strong></p><p><strong>a.没有并行TCP连接的非持续HTTP</strong></p><p><strong>b.配置有5个并行连接的非持续HTTP</strong>、</p><p><strong>c.持续HTTP</strong></p><p>a.传输引用对象<br>$$<br>2<em>8RTT_0<br>$$<br>传输HTML基本文件<br>$$<br>2RTT_0<br>$$<br>总时间<br>$$<br>18RTT_0+RTT_1+…+RTT_n<br>$$<br>b.传输引用对象<br>$$<br>2</em>2RTT_0<br>$$<br>传输HTML基本文件<br>$$<br>2RTT_0<br>$$<br>总时间<br>$$<br>6RTT_0+RTT_1+…+RTT_n<br>$$<br>c.有管线连接<br>$$<br>RTT_0+RTT_1+…+RTT_n<br>$$<br>无管线连接<br>$$<br>10RTT_0+RTT_1+…+RTT_n<br>$$</p><p><strong>P9.考虑图2-12，其中有一个机构的网络和因特网相连。假定对象的平均长度为850 000比特，从这个机构网的浏览器到初始服务器的平均请求是每秒16个请求。还假定从接入链路的因特网一侧的路由器转发一个HTTP请求开始，到接收到其响应的平均时间是3秒。将总的平均响应时间建模为平均接入时延（即从因特网路由器到机构路由器的时延）和平均因特网时延之和了。对于平均接入时延，使用∆&#x2F;（1-∆β），∆是跨越接入链路发送一个对象的平均时间，β是对象对该接入链路的平均到达率。</strong></p><p><strong>a.求出总的平均响应时间</strong></p><p><strong>b.现在假定在这个机构LAN中安装了一个缓存器。假定命中率为0.4，求出总的响应时间</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230322223604.jpg"></p><p>a.<br>$$<br>∆&#x3D;0.85Mb&#x2F;15Mbps&#x3D;0.0567s<br>$$</p><p>$$<br>β&#x3D;16&#x2F;s<br>$$</p><p>$$<br>平均接入时延&#x3D;0.0567&#x2F;(1-0.0567*16)&#x3D;0.611s<br>$$</p><p>$$<br>总平均响应时间&#x3D;3+0.611&#x3D;3.611s<br>$$</p><p>b.<br>$$<br>β&#x3D;16*0.6<br>$$</p><p>$$<br>平均接入时延&#x3D;0.0567&#x2F;(1-0.0567*9.6)&#x3D;0.124s<br>$$</p><p>$$<br>命中总响应时间&#x3D;0.85Mb&#x2F;100Mb&#x3D;0.0085s<br>$$</p><p>$$<br>总平均响应时间&#x3D;0.0085<em>0.4+3.124</em>0.6&#x3D;1.8778s<br>$$</p><p><strong>P10.考虑一条10米短链路，某发送方经过它能够以150bps速率双向传输。假定包含数据的分组是100 000比特长，仅包含控制（如ACK或握手）的分组是200比特长。假定N个并行连接每个都获得1&#x2F;N的链路带宽。现在考虑HTTP协议，并且假定每个下载对象是100kb长，这些初始下载对象包含10个来自相同发送方的引用对象。在这种情况下，经非持续HTTP的并行实例的并行下载有意义吗？现在考虑持续HTTP。你期待这比非持续的情况有很大增益吗？评价并解释你的答案。</strong></p><p>发送方需与对方进行三次握手</p><p>若利用非持续HTTP进行下载：</p><p>前两次握手：<br>$$<br>控制分组传输+RTT<br>$$<br>总时间：<br>$$<br>(200&#x2F;150+Tp+200&#x2F;150+Tp+200&#x2F;150+Tp+100000&#x2F;150+Tp)+((200&#x2F;(150&#x2F;10)+Tp)*3+100000&#x2F;(150&#x2F;10)+Tp)<br>$$</p><p>若利用持续HTTP进行下载：</p><p>前两次握手所需时间与非持续HTTP相同</p><p>总时间为：<br>$$<br>(200&#x2F;150+Tp+200&#x2F;150+Tp+200&#x2F;150+Tp+100000&#x2F;150+Tp)+10*(200&#x2F;150+Tp+100000&#x2F;150+Tp)<br>$$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络自顶向下—第二章—套接字编程作业</title>
      <link href="/2023/06/25/ji-suan-ji-wang-luo-zi-ding-xiang-xia-di-er-zhang-tao-jie-zi-bian-cheng-zuo-ye/"/>
      <url>/2023/06/25/ji-suan-ji-wang-luo-zi-ding-xiang-xia-di-er-zhang-tao-jie-zi-bian-cheng-zuo-ye/</url>
      
        <content type="html"><![CDATA[<p><strong>网站<a href="http://www.pearsonhighered.com/cs-resource%E5%8F%AF%E4%BB%A5%E6%89%BE%E5%88%B0%E4%BD%9C%E4%B8%9A%E7%9A%84%E5%85%A8%E9%9D%A2%E7%BB%86%E8%8A%82">http://www.pearsonhighered.com/cs-resource可以找到作业的全面细节</a></strong></p><p>作业文档翻译以及解答参考</p><p><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer">https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer</a></p><h1 id="作业1：Web服务器"><a href="#作业1：Web服务器" class="headerlink" title="作业1：Web服务器"></a>作业1：Web服务器</h1><p><strong>在这个编程作业中，你将用Python语言开发一个简单的Web服务器，它仅能处理一个请求。具体而言，你的Web服务器将：（1）当一个客户（浏览器）联系时创建一个连接套接字；（2）从这个连接接收HTTP请求；（3）解释该请求以确定所请求的特定文件；（4）从服务器的文件系统获得请求的文件；（5）创建一个由请求的文件组成的HTTP响应报文，报文前面有首部行；（6）经TCP连接向请求的浏览器发送响应。如果浏览器请求一个在该服务器中不存在的文件，服务器应当返回一个“404 Not Found”差错报文。在配套网站中，我们提供了用于该服务器的框架代码。你的任务是完善该代码，运行你的服务器，通过在不同主机上运行的浏览器发送请求来测试服务器。如果运行你服务器的主机上已经有一个Web服务器在运行，你应当为该Web服务器使用一个不同于80端口的其他端口。</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span>serverSocket <span class="token operator">=</span>socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span> <span class="token comment">#socket类实例化，第一个参数是地址族（默认是socket.AF_INET,指定使用IPv4协议）；第二个参数是流（默认是socket.SOCK_STREAM,指定面向流的TCP协议）；第三个参数默认是0</span>serverPort<span class="token operator">=</span><span class="token number">6789</span><span class="token comment">#设置端口号为6789</span>serverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#将服务器套接字与端口号6789绑定</span>serverSocket<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#聆听来自客户端的请求，参数定义请求最大数（至少为1）</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Ready to serve...'</span><span class="token punctuation">)</span>    connectionSocket<span class="token punctuation">,</span> addr <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">#调用accept方法，创建名为connectionSocket的新的套接字供特定的客户使用</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        message <span class="token operator">=</span> connectionSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token comment">#获得客户端发送的报文，设定要发送的字节数</span>        filename <span class="token operator">=</span> message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment">#获得客户请求的文件名</span>        f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        outputdata <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#向客户端发送http首部</span>        header <span class="token operator">=</span> <span class="token string">'http/1.1 200 OK\nConnection: close\nContent-Type: text/html\nContent-Length: %d\n\n'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span>        connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>header<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>outputdata<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        connectionSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#报文发送完毕后关闭连接</span>    <span class="token keyword">except</span> IOError<span class="token punctuation">:</span><span class="token comment">#错误提示</span>        outputdata <span class="token operator">=</span> <span class="token string">'http/1.1 404 Not Found\r\n\r\n'</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>outputdata<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>emcode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    connectionSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>severSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在本地浏览器输入localhost:6789&#x2F;f.html</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-24%20174512.png" alt="发送成功"></p><p><strong>可选练习</strong></p><p><strong>1.目前，这个Web服务器一次只处理一个HTTP请求。请实现一个能够同时处理多个请求的多线程服务器。使用线程，首先创建一个主线程，在固定端口监听客户端请求。当从客户端收到TCP连接请求时，它将通过另一个端口建立TCP连接，并在另外的单独线程中为客户端请求提供服务。这样在每个请求&#x2F;响应对的独立线程中将有一个独立的TCP连接。</strong></p><p>程序中需要用到python的threading模块进行多线程编程</p><blockquote><p>在代码中引用threading模块</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="创建thread对象"><a href="#创建thread对象" class="headerlink" title="创建thread对象"></a>创建thread对象</h3><p>每个thread对象代表一个线程，在每个线程中我们可以让程序处理不同的任务</p><p>1.直接创建thread对象</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">threading</span><span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>group<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> target<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> kwargs<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> daemon<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>thread构造方法中，需要将一个callable对象赋值给target，线程才能正常运行</p><p>调用start()方法启动thread对象</p><p><strong>thread的名字</strong></p><p>每个thread都有一个name的属性，代表的就是线程的名字，可以在构造方法中赋值</p><p>默认为“Thread-number”的形式</p><p>可以通过is_alive的方法查询线程是否还在运行</p><p>在主线程结束时，若要使子线程也立即结束，可在子线程调用start()方法之前设置deamon的值为true</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">import</span> threading serverSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_IENT<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span><span class="token comment">#实例化socket类 </span><span class="token comment">#设置接收请求的端口号 </span>serverPort <span class="token operator">=</span> <span class="token number">1111</span> serverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#绑定 </span>serverSocekt<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>  <span class="token keyword">def</span> <span class="token function">function</span><span class="token punctuation">(</span>connectionSocket<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">try</span><span class="token punctuation">:</span>                 message <span class="token operator">=</span> connectionSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>                 filename <span class="token operator">=</span> message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                 f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                 outputdata <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>                 header <span class="token operator">=</span> <span class="token string">' HTTP/1.1 200 OK\nConnection: close\nContent-Type: text/html\nContent-Length: %d\n\n'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span>                       connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>header<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                 connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>outputdata<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                         connectionSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token keyword">except</span> IOError<span class="token punctuation">:</span>                 outputdata <span class="token operator">=</span> <span class="token string">'HTTP/1.1 404 Not Found\r\n\r\n'</span>                 <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                         connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>outputdata<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                      connectionSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span> <span class="token string">'Ready to serve...'</span><span class="token punctuation">)</span>         connectionSocket<span class="token punctuation">,</span> addr <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>         thread <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>webProcess<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>connectionSocket<span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#多线程     </span>    thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>   serverSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**2.不使用浏览器，编写自己的HTTP客户端来测试你的服务器。您的客户端将使用一个TCP连接用于连接到服务器，向服务器发送HTTP请求，并将服务器响应显示出来。您可以假定发送的HTTP请求将使用GET方法。    客户端应使用命令行参数指定服务器IP地址或主机名，服务器正在监听的端口，以及被请求对象在服务器上的路径。以下是运行客户端的输入命令格式。 **</p><blockquote><p>client.py server_host server_port filename</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span> serverName <span class="token operator">=</span> <span class="token string">'192.0.0.0'</span> serverPort <span class="token operator">=</span> <span class="token number">6789</span> clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_IENT<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span> clientSocket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>serverName<span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>  outputdata <span class="token operator">=</span> <span class="token string">'GET /f.html HTTP/1.1\r\n Host: 192.168.137.1\r\n\r\n'</span> clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>outputdata<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> data <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">while</span> data<span class="token punctuation">:</span>         data <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">)</span>      clientSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="作业2：UDP-ping程序"><a href="#作业2：UDP-ping程序" class="headerlink" title="作业2：UDP ping程序"></a>作业2：UDP ping程序</h1><p><strong>在这个编程作业中，你将用python编写一个客户ping程序。该客户将发送一个简单的ping报文，接受一个从服务器返回的对应pong报文，并确定从该客户发送ping报文到接收到pong报文为止的时延。该时延称为往返时延（RTT）。由该客户和服务器提供的功能类似于在现代操作系统中可用的标准ping程序。然而，标准的ping使用互联网控制报文协议（ICMP）。此时我们将创建一个非标准（但简单的）基于UDP的ping程序。</strong></p><p><strong>你的ping程序经UDP向目标服务器发送10个ping报文。对于每个报文，当对应的pong报文返回时，你的客户要确定和打印RTT。因为UDP是一个不可靠的协议，由客户发送的分组可能会丢失。为此，客户不能无限期地等待对ping报文的回答。客户等待服务器回答的时间至多为一秒；如果没有收到回答，客户假定该分组丢失并相应的打印一条报文。</strong></p><p><strong>在此作业中，你将给出服务器的完整代码，你的任务是编写客户代码，可以随意地从服务器代码中剪贴代码行。</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#UDPserver.py</span><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> random <span class="token comment">#随机数生成</span>serverSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">)</span>serverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> <span class="token number">1111</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>                  rand <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>                  message<span class="token punctuation">,</span> address <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>                  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"收到来自 %s 的报文：（%s）"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>address<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">)</span>                  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"随机数是：%d"</span> <span class="token operator">%</span> rand<span class="token punctuation">)</span>                  message <span class="token operator">=</span> message<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span>                                    <span class="token keyword">if</span> rand <span class="token operator">&lt;</span> <span class="token number">4</span>                     comtinue                  serverSocket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>message<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#UDPclient.py</span><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> timeserverName <span class="token operator">=</span> <span class="token string">'localhost'</span>serverPort <span class="token operator">=</span> <span class="token number">1111</span>clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        time_start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#开始计时</span>        message <span class="token operator">=</span> <span class="token string">'Ping *'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>time_start<span class="token punctuation">)</span> <span class="token comment">#要发送的ping报文</span>        clientSocket<span class="token punctuation">.</span>settimeout<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">#超时处理时间设置为1s</span>        clientSocket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>message<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">,</span><span class="token number">1111</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">try</span><span class="token punctuation">:</span>            modified<span class="token punctuation">,</span> serveraddress <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>            Time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> time_start <span class="token comment">#计算RTT</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cost'</span><span class="token punctuation">,</span> Time<span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">)</span>        <span class="token keyword">except</span> timeout<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Request Time Out'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>            clientSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写程序时遇到的问题与解决方法：</p><p>1.将服务器端代码与客户端代码运行后，客户端收到的消息一直为“Request Time Out”，将except后错误类型改为timeout解决</p><p><strong>可选练习</strong></p><p>**1.目前，程序计算每个数据包的往返时间（RTT），并单独打印出来。请按照标准ping程序的模式修改。您需要在客户端每次ping后显示最小，最大和平均RTT。另外，还需计算丢包率（百分比）。 **</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">import</span> time  serverName <span class="token operator">=</span> <span class="token string">'localhost'</span> serverPort <span class="token operator">=</span> <span class="token number">1111</span> recvnum<span class="token operator">=</span><span class="token number">0</span> <span class="token builtin">max</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token builtin">min</span> <span class="token operator">=</span> <span class="token number">2</span> aver <span class="token operator">=</span> <span class="token number">0</span> clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">)</span> <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>         <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                      time_start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>                     message <span class="token operator">=</span> <span class="token string">'Ping *'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>time_start<span class="token punctuation">)</span>                    clientSocket<span class="token punctuation">.</span>settimeout<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                     clientSocket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>message<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> <span class="token number">1111</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                      <span class="token keyword">try</span><span class="token punctuation">:</span>                             modified<span class="token punctuation">,</span> serveraddress <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>                               Time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span> time_start                             <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cost'</span><span class="token punctuation">,</span> Time<span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">)</span>                             recvnum<span class="token operator">+=</span><span class="token number">1</span>                             aver <span class="token operator">+=</span>Time                            <span class="token keyword">if</span><span class="token punctuation">(</span>Time<span class="token operator">></span><span class="token builtin">max</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                                     <span class="token builtin">max</span><span class="token operator">=</span>Time                             <span class="token keyword">if</span><span class="token punctuation">(</span>Time<span class="token operator">&lt;</span><span class="token builtin">min</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                                     <span class="token builtin">min</span><span class="token operator">=</span>Time                       <span class="token keyword">except</span> timeout<span class="token punctuation">:</span>                             <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Request Time Out'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"丢失率"</span><span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">-</span>recvnum<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">100</span><span class="token operator">/</span>recvnum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"%"</span><span class="token punctuation">)</span> <span class="token keyword">if</span><span class="token punctuation">(</span>recvnum<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"最短"</span><span class="token punctuation">,</span> <span class="token builtin">min</span><span class="token punctuation">,</span> <span class="token string">"最长"</span><span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token punctuation">,</span> <span class="token string">"平均"</span><span class="token punctuation">,</span> aver<span class="token operator">/</span>recvnum<span class="token punctuation">)</span>  clientSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.  UDP Ping的另一个类似的应用是UDP Heartbeat。心跳可用于检查应用程序是否已启动并运行，并报告单向丢包。客户端在UDP数据包中将一个序列号和当前时间戳发送给正在监听客户端心跳的服务器。服务器收到数据包后，计算时差，报告丢包（若发生）。如果心跳数据包在指定的一段时间内丢失，我们可以假设客户端应用程序已经停止。实现UDP Heartbeat（客户端和服务器端）。您需要修改给定的UDPPingerServer.py和您自己的UDP ping客户端。</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#server</span><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span>serverSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">)</span>serverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> <span class="token number">1111</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    message<span class="token punctuation">,</span> address <span class="token operator">=</span> serverSocekt<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    message <span class="token operator">=</span> message<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    message <span class="token operator">=</span> message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    timeDiff <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token builtin">float</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"RTT is"</span><span class="token punctuation">,</span> timeDiff<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#client</span><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> timeserverName <span class="token operator">=</span> <span class="token string">'localhost'</span>serverPort <span class="token operator">=</span> <span class="token number">1111</span>clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    time1 <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    outputdata <span class="token operator">=</span> <span class="token string">'Heartbeat'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>time1<span class="token punctuation">)</span>    clientSocket<span class="token punctuation">.</span>seendto<span class="token punctuation">(</span>outputdata<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>serverName<span class="token punctuation">,</span> serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="作业三：邮件客户"><a href="#作业三：邮件客户" class="headerlink" title="作业三：邮件客户"></a>作业三：邮件客户</h1><p><strong>这个编程作业的目的是创建一个向任何接收方发送电子邮件的简单邮件客户。你的客户将必须与邮件服务器（如谷歌的电子邮件服务器）创建一个TCP连接，使用SMTP协议与邮件服务器进行交谈，经该邮件服务器向某接收方（如你的朋友）发送一个电子邮件报文，最后关闭与该邮件服务器的TCP连接。</strong></p><p><strong>对本作业，配套的web站点为你的客户提供了框架代码。你的任务是完善该代码并通过向不同的用户账户发送电子邮件来测试你的客户。你也可以尝试通过不同的服务器（例如谷歌的邮件服务器和你所在的大学的邮件服务器）进行发送</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socekt <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> base64mailserver <span class="token operator">=</span> <span class="token string">'smtp.qq.com'</span> <span class="token comment">#你所用邮件服务器的地址</span>mailUser <span class="token operator">=</span> <span class="token string">'aaa'</span>mailFromAddress <span class="token operator">=</span> <span class="token string">'aaa@qq.com'</span>mailPassword <span class="token operator">=</span> <span class="token string">'******'</span> <span class="token comment">#可以在邮箱设置授权码，使用授权码登录</span>mailToAddress <span class="token operator">=</span> <span class="token string">'bbb@163.com'</span>clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>mailserver<span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#qq的smtp端口号</span>recv <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>recv<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span><span class="token keyword">if</span> recv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'220'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"220 reply not received from server"</span><span class="token punctuation">)</span>        helloCommand <span class="token operator">=</span> <span class="token string">'HELO mailserver\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>helloCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    recv1 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv1 <span class="token operator">=</span> recv1<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv1<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv1<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'250'</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>        loginCommand <span class="token operator">=</span> <span class="token string">'AUTH LOGIN\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>loginCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    recv <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv <span class="token operator">=</span> recv<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'334'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>                userCommand <span class="token operator">=</span> base64<span class="token punctuation">.</span>b64encode<span class="token punctuation">(</span>mailUser<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">b'\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span>：clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>userCommand<span class="token punctuation">)</span>    recv <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv <span class="token operator">=</span> recv<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'334'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>                passCommand <span class="token operator">=</span> base64<span class="token punctuation">.</span>b64encode<span class="token punctuation">(</span>mailPassword<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">b'\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>passCommand<span class="token punctuation">)</span>    recv <span class="token operator">=</span> client<span class="token punctuation">.</span>socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>recv <span class="token operator">=</span> recv<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'235'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>                mailfromCommand <span class="token operator">=</span> <span class="token string">'MAIL FROM: &lt;aaa@qq.com>\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>mailfromCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    recv2 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv2 <span class="token operator">=</span> recv2<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv2<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'250'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>                rcptCommand <span class="token operator">=</span> <span class="token string">'RCPT TO: &lt;bbb@163.com>\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>rcptCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    recv3 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv3 <span class="token operator">=</span> recv3<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv3<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv3<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'250'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>                dataCommand <span class="token operator">=</span> <span class="token string">'DATA\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>DataCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    recv4 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv4 <span class="token operator">=</span> recv4<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv4<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv4<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'354'</span>    <span class="token keyword">break</span>                messageCommand <span class="token operator">=</span> <span class="token string">'\r\ni am doing my computer networking homework\r\n:)\r\n'</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>messageCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>endCommand <span class="token operator">=</span> <span class="token string">'\r\n.\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>endCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    recv5 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv5 <span class="token operator">=</span> recv5<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv5<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv5<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'250'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>                quitCommand <span class="token operator">=</span> <span class="token string">'QUIT\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocekt<span class="token punctuation">.</span>send<span class="token punctuation">(</span>quitCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    recv6 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv6 <span class="token operator">=</span> recv6<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv6<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv5<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'221'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>clientSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-25%20230712.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-25%20233953.png"></p><p><strong>可选练习：</strong></p><p><strong>1.类似Google邮件的服务器（如地址：smtp.gmail.com，端口：587））要求您的客户端在发送MAIL FROM命令之前，需要为了身份验证和安全原因添加传输层安全（TLS）或安全套接字层（SSL）。将TLS &#x2F; SSL命令添加到现有的命令中，并使用上述地址和端口为Google邮件服务器实现客户端。</strong></p><p>代码部分只需在上一题基础上稍作更改</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#导入ssl模块</span><span class="token keyword">import</span> ssl<span class="token comment">#创建套接字</span>context <span class="token operator">=</span> ssl<span class="token punctuation">.</span>create_default_context<span class="token punctuation">(</span><span class="token punctuation">)</span>clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>mailserver<span class="token punctuation">,</span> <span class="token number">465</span><span class="token punctuation">)</span><span class="token punctuation">)</span>clientSocketSSL <span class="token operator">=</span> context<span class="token punctuation">.</span>wrap_socket<span class="token punctuation">(</span>clientSocket<span class="token punctuation">,</span> server_hostname<span class="token operator">=</span>mailserver<span class="token punctuation">)</span><span class="token comment">#套接字变成clientSocketSSL</span><span class="token comment">#需要更改的部分</span>recv <span class="token operator">=</span> clientSocketSSL<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>clientSocketSSL<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token operator">**</span><span class="token operator">*</span>Command<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>clientSocketSSL<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.您当前的SMTP邮件客户端只能在电子邮件正文中发送文本消息。修改您的客户端，使其可以发送包含文本和图像的电子邮件。</strong></p><h1 id="作业四：多线程web代理服务器"><a href="#作业四：多线程web代理服务器" class="headerlink" title="作业四：多线程web代理服务器"></a>作业四：多线程web代理服务器</h1><p><strong>在这个编程作业中，你将研发一个简单的web代理服务器。当你的代理服务器从一个浏览器接收到对某对象的HTTP请求，它生成对相同对象的一个新的HTTP请求并向初始服务器发送。当该代理服务器从初始服务器接收到具有该对象的HTTP响应时，它生成一个包括该对象的新HTTP响应，并发送给该客户。这个代理将是多线程的，使其在相同时间能够处理多个请求。</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os <span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">import</span> sys  <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Usage : "python ProxyServer.py server_ip"\n[server_ip : It is the IP Address Of Proxy Server'</span> <span class="token punctuation">)</span>         sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">#创建服务器套接字，与端口绑定，保持倾听 </span>tcpSerSock <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span> tcpSerPort <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>tcpSerSock<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> tcpSerPort<span class="token punctuation">)</span><span class="token punctuation">)</span> tcpSerSock<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>  <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'ready to serve...'</span><span class="token punctuation">)</span>         tcpCliSock<span class="token punctuation">,</span> addr <span class="token operator">=</span> tcpSerSock<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'received a connection from:'</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>        message <span class="token operator">=</span> tcpCliSock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"message: "</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>message <span class="token operator">==</span> <span class="token string">''</span><span class="token punctuation">)</span>             <span class="token keyword">continue</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        filename <span class="token operator">=</span> message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>partition<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span>         fileExist <span class="token operator">=</span> <span class="token string">'false'</span>         filetouse <span class="token operator">=</span> <span class="token string">"/"</span> <span class="token operator">+</span> filename         <span class="token keyword">print</span><span class="token punctuation">(</span>filetouse<span class="token punctuation">)</span>         <span class="token keyword">try</span><span class="token punctuation">:</span>                 f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"WEB/"</span><span class="token punctuation">,</span> filetouse<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span>                 outputdata <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>                 fileExist <span class="token operator">=</span> <span class="token string">"true"</span>                tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"HTTP/1.0 200 OK \r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                 tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"Content-type:text/html\r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                 tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span>                 <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'read from cache'</span><span class="token punctuation">)</span>          <span class="token keyword">except</span> IOError<span class="token punctuation">:</span>                 <span class="token keyword">if</span> fileExist <span class="token operator">==</span> <span class="token string">'false'</span><span class="token punctuation">:</span>                         c <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span>                        hosten <span class="token operator">=</span> filename<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"www."</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>                         <span class="token keyword">print</span><span class="token punctuation">(</span>hosten<span class="token punctuation">)</span>                         <span class="token keyword">try</span><span class="token punctuation">:</span>                                 serverName <span class="token operator">=</span> hosten<span class="token punctuation">.</span>partition<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                                 serverPort <span class="token operator">=</span> <span class="token number">80</span>                                 c<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>serverName<span class="token punctuation">,</span> serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>                                 askfile <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>filename<span class="token punctuation">.</span>partition<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                                 fileobj <span class="token operator">=</span> c<span class="token punctuation">.</span>makefile<span class="token punctuation">(</span><span class="token string">'rwb'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>                                 fileobj<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> askfile<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"HTTP/1.0\r\nHost: "</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\r\n\r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                 serverRespnse <span class="token operator">=</span> fileobj<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>                                  filename <span class="token operator">=</span> <span class="token string">"WEB/"</span> <span class="token operator">+</span> filename                                 filesplit <span class="token operator">=</span> filename<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>                                 <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>filesplit<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                                        <span class="token keyword">if</span> notos<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>filesplit<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>filesplit<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                  tmpFile <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">"wb"</span><span class="token punctuation">)</span>                                  <span class="token keyword">print</span><span class="token punctuation">(</span>serverResponse<span class="token punctuation">)</span>                                  serverResponse <span class="token operator">=</span> serverResponse<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">b'\r\n\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                                  <span class="token keyword">print</span><span class="token punctuation">(</span>serverResponse<span class="token punctuation">)</span>                                  tmpFile<span class="token punctuation">.</span>write<span class="token punctuation">(</span>serverResponse<span class="token punctuation">)</span>                                  tmpFile<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>                                  tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"HTTP/1.1 200 OK\r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                  tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"Content-Type:text/html\r\n\r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                     tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span>serverResponse<span class="token punctuation">)</span>                           <span class="token keyword">except</span><span class="token punctuation">:</span>                                 <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"illegal request"</span><span class="token punctuation">)</span>                             c<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>                     <span class="token keyword">else</span><span class="token punctuation">:</span>                             <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"net error"</span><span class="token punctuation">)</span>               tcpCliSock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>   tcpCliSock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>美赛绘图介绍</title>
      <link href="/2023/06/25/mei-sai-hui-tu-jie-shao/"/>
      <url>/2023/06/25/mei-sai-hui-tu-jie-shao/</url>
      
        <content type="html"><![CDATA[<h1 id="美赛绘图介绍"><a href="#美赛绘图介绍" class="headerlink" title="美赛绘图介绍"></a>美赛绘图介绍</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h3><p><a href="https://mycolor.space/">colorspace</a></p><h3 id="图片素材"><a href="#图片素材" class="headerlink" title="图片素材"></a>图片素材</h3><p><a href="https://www.freepik.com/">freepic</a></p><h3 id="python画图"><a href="#python画图" class="headerlink" title="python画图"></a>python画图</h3><p><a href="https://zhuanlan.zhihu.com/p/81553421?utm_source=wechat_session">seaborn库</a></p><h3 id="绘图网站"><a href="#绘图网站" class="headerlink" title="绘图网站"></a>绘图网站</h3><p><a href="https://www.bioladder.cn/web/#/pro/index">bioladder</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录—链表</title>
      <link href="/2023/06/25/suan-fa-shua-ti-ji-lu-lian-biao/"/>
      <url>/2023/06/25/suan-fa-shua-ti-ji-lu-lian-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">力扣题目链接</a></p><ul><li><p><strong>直接使用原来的链表进行删除操作</strong></p></li><li><p><strong>设置一个虚拟头节点在进行操作</strong></p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        ListNode* dummyHead &#x3D; new ListNode(0); &#x2F;&#x2F; 设置一个虚拟头结点        dummyHead-&gt;next &#x3D; head; &#x2F;&#x2F; 将虚拟头结点指向head，这样方面后面做删除操作        ListNode* cur &#x3D; dummyHead;        while (cur-&gt;next !&#x3D; NULL) &#123;            if(cur-&gt;next-&gt;val &#x3D;&#x3D; val) &#123;                ListNode* tmp &#x3D; cur-&gt;next;                cur-&gt;next &#x3D; cur-&gt;next-&gt;next;                delete tmp;            &#125; else &#123;                cur &#x3D; cur-&gt;next;            &#125;        &#125;        head &#x3D; dummyHead-&gt;next;        delete dummyHead;        return head;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><p><a href="https://leetcode.cn/problems/design-linked-list/">力扣题目链接</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;定义链表结构体struct LinkedNode&#123;    int val;    LinkedNode* next;    LinkedNode(int val):val(val),next(nullptr)&#123;&#125;    &#125;;MyLinkedList()&#123;    _dummyhead &#x3D; new LinkedNode(0);    _size&#x3D;0;&#125;int get(int index)&#123;    if(index &gt; (_size - 1)||index&lt;0)&#123;        return -1;    &#125;    LinkedNode* cur &#x3D; _dummyhead-&gt;next;    while(index--)&#123;        cur &#x3D; cur-&gt;next;    &#125;    return cur-&gt;val;&#125;void addAtHead(int val)&#123;    LinkedNode* newnode &#x3D; new LinkedNode(val);    newnode-&gt;next&#x3D;_dummyhead-&gt;next;    _dummyhead-&gt;next&#x3D;newnode;    _size++;&#125;void addAtTail(int val)&#123;    LinkedNode* newnode &#x3D; new LinkedNode(val);    LinkedNode* cur &#x3D; _dummyhead;    whlie(cur-&gt;next !&#x3D; nullptr)&#123;        cur &#x3D; cur-&gt;next;    &#125;    cur-&gt;next &#x3D; newnode;   _size++; &#125;void addAtIndex(int index, int val)&#123;    if(index &gt; _size) return;    if(index &lt; 0) index&#x3D;0;    LinkedNode* newnode &#x3D; new LinkedNode(val);    LinkedNode* cur &#x3D; _dummyhead;    whlie(index--)&#123;        cur&#x3D;cur-&gt;next;    &#125;    newnode-&gt;next &#x3D; cur-&gt;next;    cur-&gt;next &#x3D; newnode;    _size++;    &#125;void deleteAtIndex(int index)&#123;    if(index &gt;&#x3D; _size || index &lt; 0)&#123;        return;    &#125;    LinkedNode* cur &#x3D; _dunnyhead;    while(index--)&#123;        cur&#x3D;cur-&gt;next;    &#125;    LinkedNode* tmp &#x3D; cur-&gt;next;    cur-&gt;next &#x3D; cur-&gt;next-&gt;next;    delete tmp;    _size--;&#125;private: int _size; LinkedNode* _dummyhead;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/">力扣题目链接</a></p><p><strong>双指针法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">LinkNode* reverseList(ListNode* head)&#123;    ListNode* temp;    ListNode* cur &#x3D; head;    ListNode* pre &#x3D; nullptr;    while(cur)&#123;        temp &#x3D; cur-&gt;next;        pre &#x3D; cur;        cur &#x3D; temp;    &#125;    return pre;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>递归法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode* reverse(ListNOde* pre, ListNode* cur)&#123;    if(cur&#x3D;&#x3D;nullptr) return pre    ListNode* temp &#x3D; cur-&gt;next;    cur-&gt;next &#x3D; pre;    return reverse(cur, temp);&#125;ListNode* reverseList(ListNode* head)&#123;    return reverse(nullptr,head);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="19-删除链表倒数第n个结点"><a href="#19-删除链表倒数第n个结点" class="headerlink" title="19.删除链表倒数第n个结点"></a>19.删除链表倒数第n个结点</h3><p><strong>双指针法</strong></p><p>添加虚拟头节点</p><p>fast指针向后移动n+1步</p><p>fast和slow同时移动至fast指针指向末尾</p><p>删除slow后面的节点</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode* dummyhead&#x3D;new ListNode(0);dummyhead-&gt;next&#x3D;head;ListNode* fast&#x3D;dummyhead;ListNode* slow&#x3D;dummyhead;while(n-- &amp;&amp; fast!&#x3D;nullptr)&#123;    fast&#x3D;fast-&gt;next;&#125;fast-fast-&gt;next;while(fast!&#x3D;nullptr)&#123;    fast&#x3D;fast-&gt;next;    slow&#x3D;slow-&gt;next;&#125;slow-&gt;next&#x3D;slow-&gt;next-&gt;next;return dummyhead-&gt;next;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h3><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">力扣题目链接</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode* dummyhead&#x3D;new ListNode(0);dummyhead-&gt;next&#x3D;head;ListNode* cur&#x3D;dummyhead;while(cur-&gt;next !&#x3D; nullptr &amp;&amp; cur-&gt;next-&gt;next !&#x3D; nuulptr)&#123;    ListNode* temp1&#x3D;cur-&gt;next;  ListNode* temp2&#x3D;cur-&gt;next-&gt;next-&gt;next;    cur-&gt;next&#x3D;cur-&gt;next-&gt;next;    cur-&gt;next-&gt;next&#x3D;temp1;    cur-&gt;next-&gt;next-&gt;next&#x3D;temp2;    &#125;return dummyhead-&gt;next;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="160-链表相交"><a href="#160-链表相交" class="headerlink" title="160.链表相交"></a>160.链表相交</h3><p>计算两链表的长度</p><p>求出长度差值</p><p>让指针移动到末尾对其的位置</p><p>比较两指针是否相同，不相同则后移</p><p>直至两指针相等</p><h3 id="142-环形链表"><a href="#142-环形链表" class="headerlink" title="142.环形链表"></a>142.环形链表</h3><p><strong>双指针法</strong></p><p>fast走两个节点，slow走一个节点</p><p><strong>fast指针先进入环中，fast与slow一定在换环中相遇。</strong></p><p><strong>相对于slow来说，fast是一步步靠近slow的</strong></p><h4 id="如何找到环的入口"><a href="#如何找到环的入口" class="headerlink" title="如何找到环的入口"></a>如何找到环的入口</h4><p>从头节点出发一个指针，从相遇节点也出发一个指针，每次均走一个节点，两个指针相遇时就是环形入口的节点。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode* fast&#x3D;head;ListNode* slow&#x3D;head;while(fast!&#x3D;nullptr&amp;&amp;fast-&gt;next!&#x3D;nullptr)&#123;    slow&#x3D;slow-&gt;next;    fast&#x3D;fast-&gt;next-&gt;next;    if(slow&#x3D;&#x3D;fast)    &#123;        ListNode* index1&#x3D;fast;        ListNode* index2&#x3D;head;        while(index1!&#x3D;index2)        &#123;            index1&#x3D;index1-&gt;next;            index2&#x3D;index2-&gt;next;        &#125;        return index2;    &#125;&#125;return NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录—栈与队列</title>
      <link href="/2023/06/25/suan-fa-shua-ti-ji-lu-zhan-yu-dui-lie/"/>
      <url>/2023/06/25/suan-fa-shua-ti-ji-lu-zhan-yu-dui-lie/</url>
      
        <content type="html"><![CDATA[<h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说，我们可以控制使用哪种容器来实现栈的功能）</p><p>栈不提供走访功能，不提供迭代器</p><p>我们常用的SGI STL，如果没有指定其底层实现的话，默认是以deque为缺省情况下的底层结构</p><p>也可以指定vector为栈的底层实现</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::stack&lt;int, std::vector&lt;int&gt; &gt; third;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>队列的情况也是一样的</p><p>不允许有遍历行为，不提供迭代器</p><p>SGI STL中也是以deque缺省情况下的底部结构</p><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    bool isValid(string s)    &#123;        stack&lt;char&gt; ss;        if(s.size()%2 !&#x3D; 0) return false;                for(int i&#x3D;0;i&lt;s.size();i++)        &#123;            if(s[i]&#x3D;&#x3D;&#39;(&#39;) ss.push(&#39;)&#39;);            else if(s[i]&#x3D;&#x3D;&#39;[&#39;) ss.push(&#39;]&#39;);            else if(s[i]&#x3D;&#x3D;&#39;&#123;&#39;) ss.push(&#39;&#125;&#39;);            else if(ss.empty() || ss.top!&#x3D;s[i]) return false;            else ss.pop();        &#125;        return ss.empty();                &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1047-删除字符串中的相邻重复项"><a href="#1047-删除字符串中的相邻重复项" class="headerlink" title="1047.删除字符串中的相邻重复项"></a>1047.删除字符串中的相邻重复项</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123; public:         string removeDuplicates(string s)     &#123;                 stack&lt;char&gt; ss;                 for(char a:s)                 &#123;                         if(ss.empty() || a!&#x3D;ss.top())                        &#123;          ss.push(a);          &#125;              else                         &#123;                                ss.pop();             &#125;                     &#125;                  string result&#x3D;&quot;&quot;;                 while(!ss.empty())                 &#123;                     result+&#x3D;ss.top();                         ss.pop();                 &#125;                 reverse(result.begin(),result.end());                 return result;           &#125; &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="150-逆波兰表达式"><a href="#150-逆波兰表达式" class="headerlink" title="150.逆波兰表达式"></a>150.逆波兰表达式</h3><blockquote><p>字符串有关的函数</p><p>1.stoi()</p><p>将字符串转换为整型</p><p>2.stoll()</p><p>将字符串转换为long long</p><p>3.stof()</p><p>将字符串转换为float</p><p>4.stod()</p><p>将字符串转换为double<a href="https://www.comap-math.com/mcm/2023Certs/2303164.pdf">https://www.comap-math.com/mcm/2023Certs/2303164.pdf</a></p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    int evalRPN(vector&lt;string&gt;&amp; tokens)&#123;stack&lt;long long&gt; st;        for(int i&#x3D;0;i &lt; tokens.size();i++)        &#123;            if(tokens[i] &#x3D;&#x3D; &quot;+&quot; || tokens[i] &#x3D;&#x3D; &quot;-&quot; || tokens &#x3D;&#x3D; &quot;*&quot; || tokens &#x3D;&#x3D; &quot;&#x2F;&quot;)&#123;                long long num1 &#x3D; st.top();                st.pop();                long long num2 &#x3D; st.top();                st.pop();                if(tokens[i] &#x3D;&#x3D; &quot;+&quot;) st.push(num1 + num2);                if(tokens[i] &#x3D;&#x3D; &quot;-&quot;) st.push(num2 - num1);                if(tokens[i] &#x3D;&#x3D; &quot;*&quot;) st.push(num2 * num1);                if(tokens[i] &#x3D;&#x3D; &quot;&#x2F;&quot;) st.push(num2 &#x2F; num1);                            &#125;            else&#123;                st.push(stoll(tokens[i]));            &#125;&#125;        int result &#x3D; st.top();        st.pop();        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h3><p>对于此题，我们需要一个队列，随着窗口移动，队列一进一出，每次移动调用que.pop()（滑动窗口移除元素）、que.push()（滑动窗口添加元素）、que.front()（返回最大值）</p><p><strong>该队列只维护有可能成为窗口里最大值的元素（单调队列）</strong></p><p>单调队列如何配合窗口进行移动：</p><ol><li><p>pop(value)：<strong>窗口移除的元素value &#x3D; 队列出口元素，则弹出元素，否则不进行任何操作</strong></p></li><li><p>push(value)：<strong>push的元素value &gt; 入口元素的值，弹出入口元素，直到push元素的数值 &lt;&#x3D; 队列入口元素的数值</strong></p></li><li><p>que.front()返回窗口最大值</p></li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;private:    class Myqueue&#123;        public:        deque&lt;int&gt; que;        void pop(int value)            &#123;                if(!que.empty &amp;&amp; value &#x3D;&#x3D; que.front())                    que.pop_front();            &#125;        void push(int value)            &#123;                while(!que.empty &amp;&amp; value &gt; que.front())                &#123;                    que.pop_back();                &#125;                que.push_back(value);            &#125;        int front()        &#123;            return que.front();        &#125;            &#125;;public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k)    &#123;        Myqueue que;        vector&lt;int&gt; result;        for(int i&#x3D;0;i &lt; k;i++)        &#123;            que.push(nums[i]);        &#125;        result.push_back(que.front());        for(int i&#x3D;k;i &lt; nums.size();i++)        &#123;            que.pop(nums[i-k]);            que.push(nums[i]);            result.push_back(que.front());        &#125;        return result;    &#125;    &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="347-前k个高频元素"><a href="#347-前k个高频元素" class="headerlink" title="347.前k个高频元素"></a>347.前k个高频元素</h3><ol><li>利用map进行元素频率的统计</li><li>利用priority_queue对频率进行排列</li></ol><blockquote><p>优先级队列内部元素自动依照元素的权值排列</p><p>缺省情况下priority_queue利用max_heap完成对元素的排列，该大顶堆是以vector为表现形式的complete binary tree</p><p>本题利用小顶堆来实现</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    class mycomparison&#123;        public:        bool operator()(const pair&lt;int,int&gt;&amp; lhs, const pair&lt;int,int&gt;&amp; rhs)            &#123;                return lhs.second &gt; rhs.second;            &#125;    &#125;;        vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k)    &#123;        unordered_map&lt;int, int&gt; map;        for(int i&#x3D;0;i  &lt; nums.size();i++)        &#123;            map[nums[i]]++;        &#125;        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; ,mycomparison&gt; que;        for(unordered_map&lt;int, int&gt;::iterator it&#x3D;map.begin();it!&#x3D;map.end();it++)        &#123;            que.push(*it);            if(que.size()&gt;k)                que.pop();        &#125;        vector&lt;int&gt; result(k);        for(int i&#x3D;k-1;i&gt;&#x3D;0;i--)        &#123;            result[i] &#x3D; que.top().first;            que.pop()        &#125;                return result;            &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><p>匹配左括号时，右括号先入栈，只需要比较当前元素和栈顶相不相等</p><h4 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h4><p>将字符串顺序放到一个栈中，如果相同的话栈就弹出</p><h4 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h4><p>相邻字符串的消除问题</p><h4 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h4><p>队列没有必要维护窗口里的所有元素，只需要维护可能成为窗口里最大值的元素，同时保证队列里的元素数值时由大到小的</p><p>设计单调队列时，pop和push的操作要保持以下原则：</p><ol><li>pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用进行任何操作</li><li>push(value)：如果push的元素value大于入口元素的数值，那么就将队列出口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</li></ol><h4 id="求前K个高频元素"><a href="#求前K个高频元素" class="headerlink" title="求前K个高频元素"></a>求前K个高频元素</h4><p>unordered_map计算频率</p><p>利用priority_queue完成对元素的排序</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题基础—数组</title>
      <link href="/2023/06/25/suan-fa-shua-ti-ji-lu-shu-zu/"/>
      <url>/2023/06/25/suan-fa-shua-ti-ji-lu-shu-zu/</url>
      
        <content type="html"><![CDATA[<h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h3><p><a href="https://leetcode.cn/problems/binary-search/">力扣题目链接</a></p><p>二分法的两种写法：</p><ul><li><p>定义target在左闭右闭的区间里</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int low &#x3D; 0;        int high &#x3D; nums.size() - 1;         while (low &lt;&#x3D; high)         &#123;             int middle &#x3D; low + ((high - low) &#x2F; 2);&#x2F;&#x2F; 防止溢出             if (nums[middle] &gt; target) &#123;                high &#x3D; middle - 1;            &#125; else if (nums[middle] &lt; target) &#123;                left &#x3D; middle + 1;             &#125; else            &#123;                return middle;             &#125;        &#125;                return -1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>定义target在一个左闭右开的区间里</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int low &#x3D; 0;        int high &#x3D; nums.size();         while (low &lt; high) &#123;             int middle &#x3D; low + ((high - low) &gt;&gt; 1);            if (nums[middle] &gt; target) &#123;                high &#x3D; middle;             &#125; else if (nums[middle] &lt; target) &#123;                low &#x3D; middle + 1;             &#125; else &#123;                 return middle;             &#125;        &#125;              return -1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="74-移除元素"><a href="#74-移除元素" class="headerlink" title="74.移除元素"></a>74.移除元素</h3><p><a href="https://leetcode.cn/problems/remove-element/">力扣题目链接</a></p><ul><li><p>暴力求解</p></li><li><p>双指针法：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作</p><p>快指针：寻找新数组的元素，新数组就是不含有目标元素的数组。</p><p>慢指针：指向更新新数组下标的位置。</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><p><strong>双指针法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int slowIndex &#x3D; 0;        for (int fastIndex &#x3D; 0; fastIndex &lt; nums.size(); fastIndex++) &#123;            if (val !&#x3D; nums[fastIndex]) &#123;                nums[slowIndex++] &#x3D; nums[fastIndex];            &#125;        &#125;        return slowIndex;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>相向双指针法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int leftIndex &#x3D; 0;        int rightIndex &#x3D; nums.size() - 1;        while (leftIndex &lt;&#x3D; rightIndex) &#123;            &#x2F;&#x2F; 找左边等于val的元素            while (leftIndex &lt;&#x3D; rightIndex &amp;&amp; nums[leftIndex] !&#x3D; val)&#123;                ++leftIndex;            &#125;            &#x2F;&#x2F; 找右边不等于val的元素            while (leftIndex &lt;&#x3D; rightIndex &amp;&amp; nums[rightIndex] &#x3D;&#x3D; val) &#123;                -- rightIndex;            &#125;            &#x2F;&#x2F; 将右边不等于val的元素覆盖左边等于val的元素            if (leftIndex &lt; rightIndex) &#123;                nums[leftIndex++] &#x3D; nums[rightIndex--];            &#125;        &#125;        return leftIndex;   &#x2F;&#x2F; leftIndex一定指向了最终数组末尾的下一个元素    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">力扣题目链接</a></p><p><strong>双指针法</strong></p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p><p>2</p><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">力扣题目链接</a></p><p><strong>滑动窗口</strong></p><p>不断的调节子序列的起始位置和终止位置，从而得出结果。</p><h3 id="59-螺旋矩阵"><a href="#59-螺旋矩阵" class="headerlink" title="59.螺旋矩阵"></a>59.螺旋矩阵</h3><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">力扣题目链接</a></p><p><strong>四条边要坚持左闭右开或者左开右闭的原则</strong></p><p>完整代码如下</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;        vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0)); &#x2F;&#x2F; 使用vector定义一个二维数组        int startx &#x3D; 0, starty &#x3D; 0; &#x2F;&#x2F; 定义每循环一个圈的起始位置        int loop &#x3D; n &#x2F; 2; &#x2F;&#x2F; 每个圈循环几次，例如n为奇数3，那么loop &#x3D; 1 只是循环一圈，矩阵中间的值需要单独处理        int mid &#x3D; n &#x2F; 2; &#x2F;&#x2F; 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)        int count &#x3D; 1; &#x2F;&#x2F; 用来给矩阵中每一个空格赋值        int offset &#x3D; 1; &#x2F;&#x2F; 需要控制每一条边遍历的长度，每次循环右边界收缩一位        int i,j;        while (loop --) &#123;            i &#x3D; startx;            j &#x3D; starty;            &#x2F;&#x2F; 下面开始的四个for就是模拟转了一圈            &#x2F;&#x2F; 模拟填充上行从左到右(左闭右开)            for (j &#x3D; starty; j &lt; n - offset; j++) &#123;                res[startx][j] &#x3D; count++;            &#125;            &#x2F;&#x2F; 模拟填充右列从上到下(左闭右开)            for (i &#x3D; startx; i &lt; n - offset; i++) &#123;                res[i][j] &#x3D; count++;            &#125;            &#x2F;&#x2F; 模拟填充下行从右到左(左闭右开)            for (; j &gt; starty; j--) &#123;                res[i][j] &#x3D; count++;            &#125;            &#x2F;&#x2F; 模拟填充左列从下到上(左闭右开)            for (; i &gt; startx; i--) &#123;                res[i][j] &#x3D; count++;            &#125;            &#x2F;&#x2F; 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)            startx++;            starty++;            &#x2F;&#x2F; offset 控制每一圈里每一条边遍历的长度            offset +&#x3D; 1;        &#125;        &#x2F;&#x2F; 如果n为奇数的话，需要单独给矩阵最中间的位置赋值        if (n % 2) &#123;            res[mid][mid] &#x3D; count;        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录—字符串</title>
      <link href="/2023/06/25/suan-fa-shua-ti-ji-lu-zi-fu-chuan/"/>
      <url>/2023/06/25/suan-fa-shua-ti-ji-lu-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="算法刷题记录—字符串"><a href="#算法刷题记录—字符串" class="headerlink" title="算法刷题记录—字符串"></a>算法刷题记录—字符串</h1><h3 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h3><p>关键代码：</p><p>去掉多余的空格</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void removeExtraSpaces(string&amp; s)&#123;    int slow&#x3D;0;    for(int i&#x3D;0;i&lt;s.size();++i)    &#123;        if(s[i]!&#x3D;&#39; &#39;)        &#123;            if(slow!&#x3D;0) s[slow++]&#x3D;&#39; &#39;;            while(i&lt;s.size() &amp;&amp; s[i]!&#x3D;&#39; &#39;)                s[slow++] &#x3D; s[i++];        &#125;    &#125;    s.resize(slow);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="剑指offer-58-左旋转字符串"><a href="#剑指offer-58-左旋转字符串" class="headerlink" title="剑指offer 58:左旋转字符串"></a>剑指offer 58:左旋转字符串</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string reverseLeftWords(string s,int n)&#123;    reverse(s.begin(), s.begin()+n);    reverse(s.begin()+n,s.end());    reverse(s.begin(),s.end());    return s;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p><strong>前缀表（prefix table）：记录了模式串与主串（文本串不匹配的时候，模式串应该从哪里开始匹配）</strong></p><p><strong>记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀</strong></p><h4 id="最长公共前后缀"><a href="#最长公共前后缀" class="headerlink" title="最长公共前后缀"></a>最长公共前后缀</h4><p>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</p><p>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</p><p>前缀表要求的就是相同前后缀的长度</p><h4 id="使用next数组来匹配"><a href="#使用next数组来匹配" class="headerlink" title="使用next数组来匹配"></a>使用next数组来匹配</h4><p><strong>初始化</strong></p><p>定义两个指针，j指向前缀末尾位置，i指向后缀末尾位置。</p><p><strong>处理前后缀不相同的情况</strong></p><p>遍历模式串下标j要从1开始</p><p>如果s[i] s[j+1]不相同，也就是 前后缀末尾不相同的情况，要向前回退。</p><p><strong>处理前后缀相同的情况</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(s[i] &#x3D;&#x3D; s[j+1])&#123;    j++:&#125;next[i]&#x3D;j;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>构建next数组的函数代码</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void getNext(int* next,const string&amp; s)&#123;    int j&#x3D;-1;    next[0]&#x3D;j;    for(int i&#x3D;1;i&lt;s.size();i++)&#123;        while(j&gt;&#x3D;0 &amp;&amp; s[i] !&#x3D; s[j+1])&#123;            j &#x3D; next[j];        &#125;        if(s[i] &#x3D;&#x3D; s[j+1])            j++;        next[i]&#x3D;j;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用next数组来匹配</strong></p><p>在文本串s里找是否出现过模式串t</p><p>定义两个下标</p><p>j：指向模式串起始位置（初始值为-1，因为next数组里记录的起始位       置为-1</p><p>i：指向文本串起始位置</p><p>i从0开始，遍历文本串</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i&#x3D;0;i&lt;s.size();i++)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>s[i]与t[j+1]进行比较</p><p><strong>不相同：j从next数组里寻找下一个匹配的位置</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while(j &gt;&#x3D; 0 &amp;&amp; s[i] !&#x3D; t[j+1])&#123;    j &#x3D; next[j];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>相同：i，j同时向后移动</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(s[i] &#x3D;&#x3D; t[j+1])&#123;    j++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>如果j指向了模式串t的末尾，说明已经完全匹配</strong></p><p><strong>完全匹配后，要找出文本串中模式串出现的第一个位置，所以返回</strong></p><p><strong>当前在文本串匹配模式串的位置i 减去 模式串的长度</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(j &#x3D;&#x3D; (t.size() - 1))&#123;return (i - t.size() + 1)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="前缀表统一减一代码实现"><a href="#前缀表统一减一代码实现" class="headerlink" title="前缀表统一减一代码实现"></a>前缀表统一减一代码实现</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    void getnext(int *next, const string &amp;s)&#123;        int j&#x3D;-1;        next[0]&#x3D;j;        for(int i&#x3D;1;i&lt;s.size();i++)        &#123;            while(j&gt;&#x3D;0&amp;&amp;s[i]!&#x3D;s[j+1])&#123;&#x2F;&#x2F;前后缀不同的情况                j&#x3D;next[j];&#x2F;&#x2F;回退            &#125;            if(s[i]&#x3D;&#x3D;s[j+1])&#123;&#x2F;&#x2F;前后缀相同                j++;            &#125;            next[i]&#x3D;j;&#x2F;&#x2F;j此时为前缀的长度，赋给next[i]        &#125;    &#125;        int strStr(string haystack, string needle)&#123;        if(neddle.size() &#x3D;&#x3D; 0)        &#123;            return 0;        &#125;        int next[needle,size()];        getnext(next,needle);        int j&#x3D;-1;        for(int i&#x3D;0;i&lt;haystack.size();i++)&#x2F;&#x2F;i从0开始        &#123;            while(j&gt;&#x3D;0&amp;&amp;haystack[i]!&#x3D;needle[j+1])&#x2F;&#x2F;不匹配            &#123;                j&#x3D;next[j];            &#125;            if(haystack[i] &#x3D;&#x3D; needle[j+1])&#x2F;&#x2F;匹配，同时移动            &#123;                j++;            &#125;            if(j&#x3D;&#x3D;(needle.size()-1))&#x2F;&#x2F;出现模式串            &#123;                return (i-needle.size()+1);            &#125;        &#125;        return -1;    &#125;        &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="459-重复的字符串"><a href="#459-重复的字符串" class="headerlink" title="459.重复的字符串"></a>459.重复的字符串</h3><h4 id="移动匹配"><a href="#移动匹配" class="headerlink" title="移动匹配"></a>移动匹配</h4><p>如果字符串由重复的子串组成，则s+s中必定出现一个s</p><p>其中需要用到find库函数</p><p>下面是使用方法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20215137.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123; public:         bool repeatedSubstringPattern(string s) &#123;                 string t&#x3D;s+s;                 t.erase(t.begin());                 t.erase(t.end()-1);                        if(t.find(s)!&#x3D;std::string::npos)                     return true;                  return false;         &#125; &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="KMP解法"><a href="#KMP解法" class="headerlink" title="KMP解法"></a>KMP解法</h4><p>当一个字符串由重复子串组成，最长相等前后缀不包含的字串就是最小重复子串</p><p>假设字符串s使用多个重复字串组成，重复出现的子字符串长度是x</p><p>所以s由n*x组成</p><p>因为字符串的最长相同前后缀长度一定是不包含s本身</p><p>所以最长相同前后缀长度必然是m*x</p><p>且n-m&#x3D;1</p><p>如果nx%(n-m)x&#x3D;0</p><p>就可以判定由重复出现的字符串</p><p>如果len%(len-(next[len-1]+1))&#x3D;&#x3D;0</p><p>说明数组长度可以被（数组长度-最长相等前后缀长度）整除</p><p><strong>数组长度减去最长相同前后缀的长度相当于是一个周期的长度</strong></p><p>前缀表统一减一的代码实现</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    void getNext(int* next,string&amp; s)    &#123;        next[0]&#x3D;-1;        int j&#x3D;-1;        for(int i&#x3D;1;i&lt;s.size();i++)        &#123;            while(j&gt;&#x3D;0 &amp;&amp; s[i]!&#x3D;s[j+1])            &#123;                j&#x3D;next[j];            &#125;            if(s[i]&#x3D;&#x3D;s[j+1])            &#123;                j++;            &#125;            next[i]&#x3D;j;   bool repeatSubstringPattern(string s)   &#123;       if(s.size()&#x3D;&#x3D;0)       &#123;           return false;       &#125;       int next[s.size()-1];       int len&#x3D;s.size()-1;       getNext(next,s);       if(next[len-1]!&#x3D;-1 &amp;&amp; len%(len-(next[len-1]+1)&#x3D;&#x3D;0)          &#123;              return true;          &#125;          return false;   &#125;                        &#125;               &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录—双指针法</title>
      <link href="/2023/06/25/suan-fa-shua-ti-ji-lu-shuang-zhi-zhen-fa/"/>
      <url>/2023/06/25/suan-fa-shua-ti-ji-lu-shuang-zhi-zhen-fa/</url>
      
        <content type="html"><![CDATA[<p><strong>本文只给出代码过程，具体分析见对应类别的文章</strong></p><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int removeElement(vector&lt;int&gt;&amp; nums,int val)&#123;    int slow&#x3D;0;    for(int fast&#x3D;0;fast&lt;nums.size();fast++)    &#123;        if(val!&#x3D;nums[fast])            nums[slow++]&#x3D;nums[fast];    &#125;    return slow;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void reverseString(vector&lt;char&gt;&amp; s)&#123;    for(int i&#x3D;0,j&#x3D;s.size()-1;i&lt;s.size()&#x2F;2;i++,j--)    &#123;        swap(s[i],s[j]);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="剑指offer05-替换空格"><a href="#剑指offer05-替换空格" class="headerlink" title="剑指offer05.替换空格"></a>剑指offer05.替换空格</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string replaceSpace(string s)&#123;    int count&#x3D;0;    int oldsize&#x3D;s.size();    for(int i&#x3D;0;i&lt;s.size();i++)    &#123;        if(s[i]&#x3D;&#x3D;&#39; &#39;)            count++;    &#125;    s.resize(s.size()+count*2);    int newsize&#x3D;s.size();    for(int i&#x3D;newsize-1,j&#x3D;oldsize-1;j&lt;i;i--,j--)    &#123;        if(s[j]!&#x3D;&#39; &#39;)            s[i]&#x3D;s[j];        else&#123;            s[i]&#x3D;&#39;0&#39;;            s[i-1]&#x3D;&#39;2&#39;;            s[i-2]&#x3D;&#39;%&#39;;            i-&#x3D;2;        &#125;    &#125;    return s;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="206-翻转链表"><a href="#206-翻转链表" class="headerlink" title="206.翻转链表"></a>206.翻转链表</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode* reverseList(ListNode* head)&#123;    ListNode* temp;    ListNode* cur&#x3D;head;    ListNode* pre&#x3D;NULL;    while(cur)    &#123;        temp&#x3D;cur-&gt;next;        cur-&gt;next&#x3D;pre;        pre&#x3D;cur;        cur&#x3D;temp;    &#125;    return pre;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="19-删除链表倒数第N个结点"><a href="#19-删除链表倒数第N个结点" class="headerlink" title="19.删除链表倒数第N个结点"></a>19.删除链表倒数第N个结点</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode* removeNthFromEnd(ListNode* head,int n)&#123;    ListNode* dummyhead &#x3D; new ListNode(0);    dummyhead-&gt;next&#x3D;head;    ListNode* slow&#x3D;dummyhead;    ListNode* fast&#x3D;dummyhead;    while(n-- &amp;&amp; fast!&#x3D;null)    &#123;        fast&#x3D;fast-&gt;next;    &#125;    fast&#x3D;fast-&gt;next;    while(fast!&#x3D;null)    &#123;        fast&#x3D;fast-&gt;next;        slow&#x3D;slow-&gt;next;            &#125;    slow-&gt;next&#x3D;slow-&gt;next-&gt;next;        return dummyhead-&gt;next;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题02-07-链表相交"><a href="#面试题02-07-链表相交" class="headerlink" title="面试题02.07.链表相交"></a>面试题02.07.链表相交</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    ListNode* curA &#x3D; headA;    ListNode* curB &#x3D; headB;    int lenA &#x3D; 0,lenB &#x3D; 0;    while(curA!&#x3D;null)&#123;        lenA++;        curA&#x3D;curA-&gt;next;    &#125;    while(curB!&#x3D;null)&#123;        lenB++;        curB&#x3D;curB-&gt;next;    &#125;    curA&#x3D;headA; curB&#x3D;headB;        if(lenB&gt;lenA)&#123;        swap(lenA,lenB);        swap(curA,curB);    &#125;    int gap &#x3D; lenA-lenB;    while(gap--)&#123;        curA&#x3D;curA-&gt;next;    &#125;    while(curA!&#x3D;null)&#123;        if(curA &#x3D;&#x3D; curB)            return curA;    &#125;    curA&#x3D;curA-&gt;next;    curB&#x3D;curB-&gt;next;        return null;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="142-环形链表Ⅱ"><a href="#142-环形链表Ⅱ" class="headerlink" title="142.环形链表Ⅱ"></a>142.环形链表Ⅱ</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    ListNode* fast &#x3D; head;    ListNode* slow &#x3D; head;    while(fast!&#x3D;null &amp;&amp; fast-&gt;next!+null)&#123;        slow&#x3D;slow-&gt;next;        fast&#x3D;fast-&gt;next-&gt;next;    &#125;    if(slow &#x3D;&#x3D; fast)&#123;        ListNode* index1 &#x3D; fast;        ListNode* index2 &#x3D; slow;        while(index1!&#x3D;index2)&#123;            index1 &#x3D; index1-&gt;next;            index2 &#x3D; index2-&gt;next;                        &#125;        return index2;    &#125;    return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="0015-三数之和"><a href="#0015-三数之和" class="headerlink" title="0015.三数之和"></a>0015.三数之和</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums)&#123;        vector&lt;vector&lt;int&gt;&gt; result;        sort(nums.begin(),nums.end());                for(int i&#x3D;0;i&lt;nums.size();i++)        &#123;            if(nums[i]&gt;0)                return result;            if(i&gt;0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i-1])                continue;            int left&#x3D;i+1;            int right&#x3D;nums.size()-1;            while(right&gt;left)&#123;                if(numns[i]+nums[left]+nums[right]&gt;0)                    right--;                else if(nums[i]+nums[left]+nums[right]&lt;0)                    left++;                else&#123;                    result.push_back(vector&lt;int&gt;&#123;nums[i],nums[left],nums[right]&#125;);                    while(right&gt;left &amp;&amp; nums[right] &#x3D;&#x3D; nums[right-1]) right--;                    while(right&gt;left &amp;&amp; nums[left] &#x3D;&#x3D; nums[left-1]) left++;                    right--;                    left++;                &#125;            &#125;        &#125;                            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录—二叉树</title>
      <link href="/2023/06/25/suan-fa-shua-ti-ji-lu-er-cha-shu/"/>
      <url>/2023/06/25/suan-fa-shua-ti-ji-lu-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="二叉树理论基础"><a href="#二叉树理论基础" class="headerlink" title="二叉树理论基础"></a>二叉树理论基础</h3><h4 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h4><p>满二叉树：深度为k，有2^k-1个节点</p><p>完全二叉树：除最底层节点可能没填满外，其余每层节点数都达到最大值</p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>二叉搜索树是一个有序树</p><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值</p><p>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</p><p>它的左右子树也分别为二叉排序树</p><h4 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h4><p>AVL树</p><p>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</p><p>c++中map、set、multimap、multiset的底层实现都是平衡二叉搜索树</p><h4 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h4><p>二叉树既可以链式存储，也可以顺序存储</p><p>链式存储方式就用指针，顺序存储的方式就是用数组</p><p>遍历数组存储的二叉树：左孩子是i * 2+1，右孩子是i * 2+2</p><h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h4><p>1.深度优先遍历</p><p>前序遍历（递归法，迭代法）</p><p>中序遍历（递归法，迭代法）</p><p>后序遍历（递归法，迭代法）</p><p>2.广度优先遍历</p><p>层次遍历（迭代法）</p><h4 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h4><p>链式存储</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct TreeNode&#123;    int val;    TreeNode *left;    TreeNode *right;    TreeNode(int x) : val(x),left(NULL),right(NULL)&#123;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;前序遍历class Solution&#123;public:    void traverval(TreeNode* cur, vector&lt;int&gt;&amp; vec)    &#123;        if(cur &#x3D;&#x3D; NULL) return;        vec.push_back(cur-&gt;val);        traverval(cur-&gt;left, vec);        traverval(cur-&gt;right, vec);    &#125;    vector&lt;int&gt; preorderTraverval(TreeNode* root)    &#123;        vector&lt;int&gt; result;        traverval(root, result);        return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;中序遍历void traverval(TreeNode* cur, vector&lt;int&gt;&amp; vec)     &#123;             if(cur &#x3D;&#x3D; NULL) return;                      traverval(cur-&gt;left, vec);     vec.push_back(cur-&gt;val);    traverval(cur-&gt;right, vec);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;后序遍历void traverval(TreeNode* cur, vector&lt;int&gt;&amp; vec)     &#123;             if(cur &#x3D;&#x3D; NULL) return;                      traverval(cur-&gt;left, vec);     traverval(cur-&gt;right, vec);    vec.push_back(cur-&gt;val);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    vector&lt;int&gt; preorderTraverval(TreeNode* root)    &#123;        stack&lt;TreeNode*&gt; st;        vector&lt;int&gt; result;        if(root &#x3D;&#x3D; NULL) return result;        st.push(root);        while(!st.empty)        &#123;            TreeNode* node &#x3D; st.top();            st.pop();            result.push_back(node-&gt;val);            if(node-&gt;right) st.push-&gt;back(node-&gt;right);            if(node-&gt;left) st.push_back(node-&gt;left);        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p><strong>借助指针访问结点，借助栈处理元素</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    vector&lt;int&gt; inorderTraverval(TreeNode* root)    &#123;        vector&lt;int&gt; result;        stack&lt;int&gt; st;        TreeNode* cur &#x3D; root;        while(cur !&#x3D; NULL || !st.empty())        &#123;            if(cur !&#x3D; NULL)            &#123;                st.push(cur);                cur &#x3D; cur-&gt;left;            &#125;            else&#123;                cur &#x3D; st.top();                st.pop();                result.push_back(cur-&gt;val);                cur &#x3D; cur-&gt;right;            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    vector postorderTraverval(TreeNode* root)    &#123;        vector&lt;int&gt; result;        stack&lt;int&gt; st;        if(root &#x3D;&#x3D; NULL) return result;       st.push(root);        while(!st.empty())        &#123;            TreeNode* node &#x3D; st.top();            st.pop();            result.push_back(node-&gt;val);            if(node-&gt;left) st.push_back(node-&gt;val);            if(node-&gt;right) st.push_back(node-&gt;val);        &#125;        reverese(result.begin(), result.end());        return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树的统一迭代法"><a href="#二叉树的统一迭代法" class="headerlink" title="二叉树的统一迭代法"></a>二叉树的统一迭代法</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    vector&lt;int&gt; inorderTraverval(TreeNode* root)    &#123;        vector&lt;int&gt; result;        stack&lt;TreeNode*&gt; st;        if(root &#x3D;&#x3D; NULL) return result;        st.push(root);        while(!st.empty())        &#123;            TreeNode* node &#x3D; st.top();            if(node !&#x3D; NULL)            &#123;                st.pop();                if(node-&gt;right) st.push(node-&gt;right);&#x2F;&#x2F;右结点入栈                                st.push(node);&#x2F;&#x2F;下一个要访问的结点入栈                st.push(NULL);                                if(node-&gt;left) st.push(node-&gt;left);&#x2F;&#x2F;左结点入栈                                            &#125;            else&#123; &#x2F;&#x2F;当遇到空结点时                st.pop(); &#x2F;&#x2F;弹出空结点                node &#x3D; st.pop(); &#x2F;&#x2F;保存当前结点                st.pop();                result.push_back(node-&gt;val); &#x2F;&#x2F;空结点后的结点值加入结果集            &#125;            return result;        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前序遍历和后序遍历仅需改变三行代码的顺序即可实现</p><h3 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h3><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root)    &#123;        queue&lt;TreeNode*&gt; que;        vector&lt;vector&lt;int&gt;&gt; result;        if(node &#x3D;&#x3D; NULL) return result;        que.push(root);        while(!que.empty())        &#123;            int size &#x3D; que.size(); &#x2F;&#x2F;使用固定大小的size            vector&lt;int&gt; vec;            for(int i&#x3D;0;i &lt; size;i++)            &#123;                TreeNode* node &#x3D; que.front();                que.pop();                vec.push_back(node-&gt;val);                if(node-&gt;left) que.push(node-&gt;left);                if(node-&gt;right) que.push(node-&gt;right);            &#125;            result.push_back(vec);        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;递归法class Solution&#123;public:    void order(TreeNode* cur, vector&lt;int&gt;&lt;int&gt;&amp; result, int depth)    &#123;        if(cur &#x3D;&#x3D; NULL) return;        if(result.size()&#x3D;&#x3D;depth) result.push_back(vector&lt;int&gt;());        result[depth].push_back(cur-&gt;val);        order(cur-&gt;left, result, depth+1);        order(cur-&gt;right, result, depth+1);    &#125;    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root)    &#123;        vector&lt;vector&lt;int&gt;&gt; result;        int depth &#x3D; 0;        order(root, result, depth);        return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="107-二叉树的层次遍历II"><a href="#107-二叉树的层次遍历II" class="headerlink" title="107.二叉树的层次遍历II"></a>107.二叉树的层次遍历II</h3><p> 在层次遍历的基础上将result反转</p><h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199.二叉树的右视图"></a>199.二叉树的右视图</h3><p>当每层遍历到结尾时，将结点的值放入结果集中</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    vector&lt;int&gt; rightsideView(TreeNode* root)    &#123;        queue&lt;TreeNode*&gt; que;        vector&lt;int&gt; result;        if(root &#x3D;&#x3D; NULL) return result;        que.push(root);        while(!que.empty())        &#123;            int size &#x3D; que.size();            for(int i&#x3D;0;i &lt; size;i++)            &#123;                TreeNode* node &#x3D; que.front();                que.pop();                if(i &#x3D;&#x3D; size - 1) result.push_back(node-&gt;val);                if(node-&gt;left) que.push(node-&gt;left);                if(node-&gt;right) que.push(node-&gt;right);            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637.二叉树的层平均值"></a>637.二叉树的层平均值</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    vector&lt;double&gt; averageOfLevel(TreeNode* root)    &#123;        queue&lt;TreeNode*&gt; que;        vector&lt;double&gt; result;        if(root &#x3D;&#x3D; NULL) return result;        que.push(root);        while(!que.empty())        &#123;            int size &#x3D; que.size();            double sum &#x3D; 0;            for(int i&#x3D;0;i&lt;size;i++)            &#123;                TreeNode* node &#x3D; que.front();                que.pop();                sum +&#x3D; node-&gt;val;                if(node-&gt;left) que.push(node-&gt;left);                if(node-&gt;right) que.push(node-&gt;right);            &#125;            result.push_back(sum&#x2F;size);        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429.N叉树的层序遍历"></a>429.N叉树的层序遍历</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root)    &#123;        queue&lt;Node*&gt; que;        vector&lt;vector&lt;int&gt;&gt; result;        if(root !&#x3D; NULL)( que.push(root);        while(!que.empty())                         &#123;                             int size &#x3D; que.size();                             vector&lt;int&gt; vec;                             for(int i&#x3D;0;i&lt;size;i++)                             &#123;                                 Node* node &#x3D; que.front();                                 que.pop();                                 vec.push_back(node-&gt;val);                                 for(int i&#x3D;0;i&lt;node-&gt;children.size();i++)                                 &#123;                                     if(node-&gt;childrem[i]) que.push(node-&gt;children[i]);                                 &#125;                                                              &#125;                             result.push_back(vec);                         &#125;                         return result;    &#125;                         &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515.在每个树行中找最大值"></a>515.在每个树行中找最大值</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    vector&lt;int&gt; largestValue(TreeNode* root)    &#123;        vector&lt;int&gt; result;        queue&lt;int&gt; que;        int maxx &#x3D; INT_MIN;        if(root !&#x3D; NULL) que.push(root);        while(!que.empty())        &#123;            int size &#x3D; que.size();            for(int i&#x3D;0;i &lt; size;i++)            &#123;                TreeNode* node &#x3D; que.front();                que.pop();                max &#x3D; mode-&gt;val &gt; max ? max : val;                if(node-&gt;right) que.push(node-&gt;right);                if(node-&gt;left) que.push(node-&gt;left);                            &#125;            result.push_back(max);        &#125;        return result;            &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116.填充每个节点的下一个右侧节点指针"></a>116.填充每个节点的下一个右侧节点指针</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    Node* connect(Node* root)    &#123;        queue&lt;Node*&gt; que;        if(root !&#x3D; NULL) que.push(root);        Node* nodepre;        Node* node;        while(!que.empty())        &#123;            int size &#x3D; que.size();            for(int i&#x3D;0;i &lt; size;i++)            &#123;                if(i &#x3D;&#x3D; 0)                &#123;                    nodepre &#x3D; que.front();                    que.pop();                    node &#x3D; nodepre;                &#125;                else                &#123;                    node &#x3D; que.front();                    que.pop();                    nodepre-&gt;next &#x3D; node;                    nodepre &#x3D; nodepre-&gt;next;                &#125;                if(node-&gt;right) que.push(node-&gt;right);                if(node-&gt;left) que.push(node-&gt;left);            &#125;            nodepre-&gt;next &#x3D; NULL;        &#125;        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="117-填充每个节点的下一个右侧节点指针Ⅱ"><a href="#117-填充每个节点的下一个右侧节点指针Ⅱ" class="headerlink" title="117.填充每个节点的下一个右侧节点指针Ⅱ"></a>117.填充每个节点的下一个右侧节点指针Ⅱ</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    Node* connect(Node* root) &#123;        queue&lt;Node*&gt; que;        if (root !&#x3D; NULL) que.push(root);        while (!que.empty()) &#123;            int size &#x3D; que.size();                       Node* nodePre;            Node* node;            for (int i &#x3D; 0; i &lt; size; i++) &#123;                if (i &#x3D;&#x3D; 0) &#123;                    nodePre &#x3D; que.front(); &#x2F;&#x2F; 取出一层的头结点                    que.pop();                    node &#x3D; nodePre;                &#125; else &#123;                    node &#x3D; que.front();                    que.pop();                    nodePre-&gt;next &#x3D; node; &#x2F;&#x2F; 本层前一个节点next指向本节点                    nodePre &#x3D; nodePre-&gt;next;                &#125;                if (node-&gt;left) que.push(node-&gt;left);                if (node-&gt;right) que.push(node-&gt;right);            &#125;            nodePre-&gt;next &#x3D; NULL; &#x2F;&#x2F; 本层最后一个节点指向NULL        &#125;        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="104-二叉树最大深度"><a href="#104-二叉树最大深度" class="headerlink" title="104.二叉树最大深度"></a>104.二叉树最大深度</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    int maxDepth(TreeNode* root)    &#123;        queue&lt;TreeNode*&gt; que;        int depth &#x3D; 0;        if(root !&#x3D; NULL) que.push(root);        while(!que.empty())        &#123;            int size &#x3D; que.size();            depth++;            for(int i&#x3D;0;i &lt; size;i++)            &#123;                TreeNode* node &#x3D; que.front();                que.pop();                if(node-&gt;right) que.push(node-&gt;right);                if(node-&gt;left) que.push(node-&gt;left);            &#125;                    &#125;        return depth;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int minDepth(TreeNode* root) &#123;        queue&lt;TreeNode*&gt; que;        int depth &#x3D; 0;        if(root !&#x3D; NULL) que.push(root);        while(!que.empty())        &#123;            int size &#x3D; que.size();            depth++;            for(int i&#x3D;0;i &lt; size;i++)            &#123;                TreeNode* node &#x3D; que.front();                que.pop();                if(!node-&gt;right &amp;&amp; !node-&gt;left) return depth;                if(node-&gt;right) que.push(node-&gt;right);                if(node-&gt;left) que.push(node-&gt;left);            &#125;        &#125;        return depth;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="226-反转二叉树"><a href="#226-反转二叉树" class="headerlink" title="226.反转二叉树"></a>226.反转二叉树</h3><p><strong>递归法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    TreeNode* invertTree(TreeNode* root)&#123;        if(root &#x3D;&#x3D; NULL) return root;        swap(root-&gt;left, root-&gt;right);        invertTree(root-&gt;right);        invertTree(root-&gt;left);        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>迭代法</strong></p><p><strong>深度优先遍历</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    TreeNode* invertTree(TreeNode* root)    &#123;        if(root &#x3D;&#x3D; NULL) return root;        stack&lt;TreeNode*&gt; st;        st.push(root);        while(!st.empty())        &#123;            TreeNode* node &#x3D; st.top();            st.pop();            swap(node-&gt;left, node-&gt;right);            if(node-&gt;right) st.push(node-&gt;right);            if(node-&gt;left) st.push(node-&gt;left);                    &#125;        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>广度优先遍历</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    TreeNode* invertTree(TreeNode* root)    &#123;        queue&lt;TreeNode*&gt; que;        if(root !&#x3D; NULL) que.push(root);        while(!que.empty())        &#123;            int size &#x3D; que.size();            for(int i&#x3D;0;i &lt; size;i++)            &#123;                TreeNode* node &#x3D; que.front();                que.pop();                swap(node-&gt;left, node-&gt;right);                if(node-&gt;left) que.push(node-&gt;left);                if(node-&gt;right) que.push(node-&gt;right);            &#125;        &#125;        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h3><p>递归法</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    bool compare(TreeNode* left, TreeNode* right)    &#123;        if(left !&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL) return false;        else if(left &#x3D;&#x3D; NULL &amp;&amp; right !&#x3D; NULL) return false;        else if(left &#x3D;&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL) return true;        else if(left-&gt;val !&#x3D; right-&gt;val) return false;                bool outside &#x3D; compare(left-&gt;left, right-&gt;right);        bool inside &#x3D; compare(left-&gt;right, right-&gt;left);        bool isSame &#x3D; outside &amp;&amp; inside;        return isSame;    &#125;    bool isSysmmetric(TreeNode* root)    &#123;        if(root &#x3D;&#x3D; NULL) return true;        return compare(root-&gt;left, root-&gt;right);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录-哈希表</title>
      <link href="/2023/06/25/suan-fa-shua-ti-ji-lu-ha-xi-biao/"/>
      <url>/2023/06/25/suan-fa-shua-ti-ji-lu-ha-xi-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="算法刷题记录-哈希表"><a href="#算法刷题记录-哈希表" class="headerlink" title="算法刷题记录-哈希表"></a>算法刷题记录-哈希表</h1><h3 id="哈希表理论基础"><a href="#哈希表理论基础" class="headerlink" title="哈希表理论基础"></a>哈希表理论基础</h3><p><strong>哈希函数 hash function</strong><br>$$<br>index &#x3D; hashFunction(name)<br>$$</p><p>$$<br>hashFunction &#x3D; hashCode(name)%tablesize<br>$$</p><p><strong>哈希碰撞的通常解决方法</strong>：</p><p><strong>拉链法和线性探测法</strong></p><h4 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h4><ul><li><p>数组</p></li><li><p>set</p></li><li><p>map</p></li></ul><p>unordered_set&#x2F;unordered_map底层实现为哈希表，set&#x2F;map和multiset&#x2F;multimap底层实现是红黑树，key值是有序的，只能删除和增加。</p><p>要使用集合解决哈希问题时，优先使用unordered_set，因为它的查询增删效率最优。</p><p>如果需要集合是有序的 ，那么就用set。</p><p>如果不仅要求有序还要有重复数据的话，那么就用multiset.</p><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><p><a href="https://leetcode.cn/problems/valid-anagram/">力扣题目链接</a></p><p>利用s[i]-‘a’来确定字母在数组中的位置。</p><h3 id="1002-查找常用字符"><a href="#1002-查找常用字符" class="headerlink" title="1002.查找常用字符"></a>1002.查找常用字符</h3><p><a href="https://leetcode.cn/problems/find-common-characters/">力扣题目链接</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;string&gt; commonChars(vector&lt;string&gt;&amp; A)&#123;    vector&lt;string&gt; result;    if(A.size()&#x3D;&#x3D;0) return result;    int hash[26]&#x3D;&#123;0&#125;;    for(int i&#x3D;0;i&lt;A[0].size();i++)&#123;        hash[A[0][i]-&#39;a&#39;]++;    &#125;    int hashOtherStr[26]&#x3D;&#123;0&#125;;    for(int i&#x3D;1;i&lt;A.size(),i++)&#123;        memset(hashOtherStr,0,26*sizeof(int));        for(int j&#x3D;0;j&lt;A[i].size();j++)&#123;            hashOtherStr[A[i][j]-&#39;a&#39;]++;        &#125;        for(int k&#x3D;0;k&lt;26;k++)&#123;            hash[k]&#x3D;min(hash[k],hashOtherStr[k]);        &#125;    &#125;    for(int i&#x3D;0;i&lt;26;i++)&#123;        while(hash[i]!&#x3D;0)&#123;            string s(1,i+&#39;a&#39;);            result.push_back(s);            hash[i]--;        &#125;    &#125;    return result;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349.两个数组的交集"></a>349.两个数组的交集</h3><p>使用unordered_set</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1,vector&lt;int&gt;&amp; nums2)&#123;    unordered_set result;    unordered_set nums(nums1.begin(),nums1.end())        for(int num:nums2)&#123;            if(nums.find(num)!&#x3D;nums.end())            &#123;                result.insert(num);            &#125;        &#125;    return vector&lt;int&gt;(result.begin(),result.end());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202.快乐数"></a>202.快乐数</h3><p>当我们要快速判断一个元素是否出现在集合中时，可以考虑哈希法。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int getsum(int n)&#123;    int sum&#x3D;0;    while(n)&#123;        sum+&#x3D;(n%10)*(n%10);        n&#x2F;&#x3D;10;    &#125;&#125;bool ishappy(int n)&#123;    unordered_set&lt;int&gt; set;    while(1)&#123;        int sum &#x3D; getsum(n);        if(sum&#x3D;&#x3D;1) return true;        if(set.find(sum)!&#x3D;set.end())&#123;            return false;        &#125;else&#123;            set.insert(sum);        &#125;        n&#x3D;sum;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::unordered_map map;for(int i&#x3D;0;i&lt;nums.size(),i++)&#123;    auto iter&#x3D;map.find(target&#x3D;nums[i]);    if(iter!&#x3D;map.end())    &#123;        return &#123;iter-&gt;second,i&#125;;    &#125;    map.insert(pair&lt;int,int&gt;(nums[i],i));&#125;return &#123;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="454-四数相加Ⅱ"><a href="#454-四数相加Ⅱ" class="headerlink" title="454.四数相加Ⅱ"></a>454.四数相加Ⅱ</h3><p>首先定义一个unordered_map，key放ab两数之和，value放出现次数。</p><p>遍历AB两数组，统计两数组元素之和和出现的次数。</p><p>遍历CD数组，找到如果0-(c+d)在map中出现过的话，统计次数。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int foursumcount(vector&lt;int&gt;&amp;A ,vector&lt;int&gt;&amp;B, vector&lt;int&gt;&amp;C ,vector&lt;int&gt;&amp;D)&#123;    unordered_map&lt;int,int&gt; map;    for(int a:A)    &#123;        for(int b:B)        &#123;            map[a+b]++;        &#125;                &#125;    int count&#x3D;0;    for(int c:C)    &#123;        for(int d:D)        &#123;            if(map.find(0-(c+d))!&#x3D;map.end())            &#123;                count+&#x3D;map[0-(c+d)];            &#125;                    &#125;    &#125;    return count;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool canConstruct(string ransomNote, string magazine)&#123;    int record[26]&#x3D;&#123;0&#125;;    if(ransomNote.size()&gt;magazine.size())        return false;    for(int i&#x3D;0;i&lt;magazine.size();i++)    &#123;        record[magazine[i]-&#39;a&#39;]++;    &#125;    for(int j&#x3D;0;j&lt;ransomNote.size();j++)    &#123;        record[ransomNote[j]-&#39;a&#39;]--;        if(record[ransomNote[j]-&#39;a&#39;]&lt;0)            return false;    &#125;    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums)&#123;    vector&lt;vector&lt;int&gt;&gt; result;    sort(nums.begin(),nums.end());    for(int i&#x3D;0;i&lt;nums.size();i++)    &#123;        if(nums[i]&gt;0) break;        if(i&gt;0 &amp;&amp; nums[i]&#x3D;&#x3D;nums[i-1]) contunue;        unordered_set&lt;int&gt; set;        for(int j&#x3D;i+1;j&lt;nums.size();j++)&#123;            if(j&gt;i+2&amp;&amp;nums[j]&#x3D;&#x3D;nums[j-1]&amp;&amp;nums[j-1]&#x3D;&#x3D;nums[j-2])                contunue;            int c&#x3D;0-(nums[i]+nums[j]);            if(set.find(c)!&#x3D;set.end())&#123;                result.push_back(&#123;nums[i],nums[j],c&#125;);                set.erese(c);            &#125;else&#123;                set.insert(nums[j]);            &#125;        &#125;    &#125;    return result;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>双指针法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums)&#123;    vector&lt;vector&lt;int&gt;&gt; result;    sort(nums.begin(),nums.end());    for(int i&#x3D;0;i&lt;nums.size();i++)    &#123;        if(nums[i]&gt;0&amp;&amp;i&#x3D;0) return result;        if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1]) continue;            &#125;    int left&#x3D;i+1;    int right&#x3D;nums.size()-1;    while(right&gt;left)    &#123;        if(nums[i]+nums[left]+nums[right]&gt;0) right--;        else if(nums[i]+nums[left]+nums[right]&lt;0) left++;        else&#123;            result.push_back(vector&lt;int&gt;&#123;nums[i],nums[left],nums[right]&#125;);            whlie(right&gt;left &amp;&amp; nums[right]&#x3D;&#x3D;nums[right-1]) right--;            whlie(right&gt;left &amp;&amp; nums[left]&#x3D;&#x3D;nums[left++]) left++;                        right--;            left++;                    &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录-动态规划</title>
      <link href="/2023/06/25/suan-fa-shua-ti-ji-lu-dong-tai-gui-hua/"/>
      <url>/2023/06/25/suan-fa-shua-ti-ji-lu-dong-tai-gui-hua/</url>
      
        <content type="html"><![CDATA[<h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><h4 id="什么是动态规划（Dynamic-Programming）"><a href="#什么是动态规划（Dynamic-Programming）" class="headerlink" title="什么是动态规划（Dynamic Programming）"></a>什么是动态规划（Dynamic Programming）</h4><p>动态规划用于解决有很多子问题的问题</p><p>动态规划中每一个状态一定是由上一个状态推导出来的</p><h4 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h4><p>1.确定dp数组以及下标的含义</p><p>2.确定递推公式</p><p>3.dp数组如何初始化</p><p>4.确定遍历顺序</p><p>5.举例推导dp数组</p><h3 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509.斐波那契数"></a>509.斐波那契数</h3><p><strong>动态规划</strong></p><p>1.确定dp数组以及下标的含义</p><p>dp[i]的定义是：第i个数的斐波那契数值是dp[i]</p><p>2.确定递推公式</p><p><strong>状态转移方程 dp[i] &#x3D; dp[i-1] + dp[i-2]</strong></p><p>3.dp数组如何初始化</p><p>本题初始化条件 dp[0]&#x3D;0, dp[1]&#x3D;1</p><p>4.确定遍历顺序</p><p>dp[i]依赖dp[i-1], dp[i-2]</p><p>那么遍历的顺序一定是从前向后遍历的</p><p>5.举例推导dp数组</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int fib(int n)&#123;    if(n&lt;&#x3D;1) return n;    vector&lt;int&gt; dp(n+1);    dp[0]&#x3D;0; dp[1]&#x3D;1;    for(int i&#x3D;1;i&lt;&#x3D;n;i++)    &#123;        dp[i] &#x3D; dp[i-1]+dp[i-2];    &#125;    return dp[n];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h3><p>1.确定dp数组以及下标的含义</p><p>dp[i]:爬到第i层楼梯由dp[i]种方法</p><p>2.确定递推公式</p><p>若要上到第i阶台阶，最后一步一定是从第i-1阶或第i-2阶上到第i阶</p><p>那么可知</p><p>递推公式为dp[i] &#x3D; dp[i-1] dp[i-2]</p><p>3.dp数组如何初始化</p><p>dp[1] &#x3D; 1</p><p>dp[2] &#x3D; 2</p><p>4.确定遍历顺序</p><p>从前向后</p><p>5.举例推导dp数组</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int climbStairs(int n)&#123;    if(n &lt;&#x3D; 1) return n;    vector&lt;int&gt; dp(n+1);    dp[1] &#x3D; 1;    dp[2] &#x3D; 2;    for(int i&#x3D;3;i&lt;&#x3D;n;i++)    &#123;        dp[i] &#x3D; dp[i-1] - dp[i-2];    &#125;    return dp[n];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746.使用最小花费爬楼梯"></a>746.使用最小花费爬楼梯</h3><p>1.确定dp数组以及下标的含义</p><p>到达第i台阶所花费最少体力为dp[i]</p><p>2.确定递推公式</p><p>dp[i] &#x3D; min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])</p><p>3.dp数组初始化</p><p>dp[0] &#x3D; 0</p><p>dp[1] &#x3D; 0</p><p>4.确定遍历顺序</p><p>5.举例推导dp数组</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int minCostClimbingStairs(vecror&lt;int&gt;&amp; cost)&#123;    vector&lt;int&gt; dp(cost,size());    dp[0] &#x3D; 0;    dp[1] &#x3D; 0;    for(int i&#x3D;2;i&lt;cost.size();i++)    &#123;        dp[i] &#x3D; min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]);    &#125;    return dp[cost.size()];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h3><p>1.确定dp数组以及下标含义</p><p>从（0，0）出发，到（i，j）的路径数</p><p>2.确定递推公式</p><p>dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]</p><p>3.dp数组初始化</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i&#x3D;0;i&lt;m;i++) dp[i][0] &#x3D; 1;for(int j&#x3D;0;j&lt;n;j++) dp[0][j] &#x3D; 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>4.确定遍历顺序</p><p>从左至右一层一层遍历</p><p>5.举例推导</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int uniquePath(int m, int n)&#123;    vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n, 0));    for(int i&#x3D;0;i&lt;m;i++) dp[i][0] &#x3D; 1;    for(int j&#x3D;0;j&lt;n;j++) dp[0][j] &#x3D; 1;    for(int i&#x3D;1;i&lt;m;i++)    &#123;        for(int j&#x3D;1;j&lt;n;j++)        &#123;            dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];        &#125;        return dp[m-1][n-1];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="63-不同路径Ⅱ"><a href="#63-不同路径Ⅱ" class="headerlink" title="63.不同路径Ⅱ"></a>63.不同路径Ⅱ</h3><p>1.确定dp数组以及下标含义</p><p>含义与上一题相同</p><p>2.确定递推公式</p><p>如果有障碍，路径数应为0</p><p>3.dp数组初始化</p><p>与上一题类似，障碍前的路径数都为1，障碍后的都为0</p><p>4.确定遍历顺序</p><p>从左到右一层一层遍历</p><p>5.举例推导dp数组</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid)&#123;    int m &#x3D; obstacleGrid.size();    int n &#x3D; obstacleGrid[0].size();    if (obstacleGrid[m - 1][n - 1] &#x3D;&#x3D; 1 || obstacleGrid[0][0] &#x3D;&#x3D; 1) &#x2F;&#x2F;如果在起点或终点出现了障碍，直接返回0                return 0;        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n,0));    for(int i&#x3D;0;i&lt;m &amp;&amp; obstacleGrid[i][0]&#x3D;&#x3D;0;i++) dp[i][0] &#x3D; 1;    for(int j&#x3D;0lj&lt;n &amp;&amp; obstacleGrid[0][j]&#x3D;&#x3D;0;j++) dp[0][j] &#x3D; 1;    for(int i&#x3D;1;i&lt;m;i++)    &#123;        for(int j&#x3D;1;j&lt;n;j++)        &#123;            if(obstacleGrid[i][j]&#x3D;&#x3D;1) contine;            dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];        &#125;    &#125;    return dp[m-1][n-1];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343.整数拆分"></a>343.整数拆分</h3><ol><li></li></ol><p>2.确定递推公式</p><p>从1遍历j，有两种渠道得到dp[i]</p><p>一个是j*(i-j)直接相乘</p><p>一个是j*dp[i-j],相当于拆分(i-j)</p><p>3.dp初始化</p><p>dp[2] &#x3D; 1</p><p>4.确定遍历顺序</p><p>从前向后</p><p>5.举例推导</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int integerBreak(int n)&#123;    vector&lt;int&gt; dp(n+1);    dp[2] &#x3D; 1;    for(int i&#x3D;3;i&lt;&#x3D;n;i++)    &#123;        for(int j&#x3D;1;j&lt;&#x3D;i&#x2F;2;j++)        &#123;            dp[i]&#x3D;max(dp[i],max((i-j)*j, dp[i-j]*j));&#125;    &#125;    return dp[n];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="01背包理论基础"><a href="#01背包理论基础" class="headerlink" title="01背包理论基础"></a>01背包理论基础</h3><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p>有n件物品和一个最多能背重量为w的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。每件物品只能使用一次，求解将哪些物品装入背包里价值总和最大。</p><h4 id="二维dp数组01背包"><a href="#二维dp数组01背包" class="headerlink" title="二维dp数组01背包"></a>二维dp数组01背包</h4><p>1.确定dp数组以及下标含义</p><p><strong>dp[i] [j]表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong></p><p>2.确定递推公式</p><p>可以有两个方向推出dp[i] [j]</p><p><strong>不放物品i：</strong>由dp[i-1] [j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i] [j]就是dp[i-1] [j]。</p><p><strong>放物品i：</strong>由dp[i-1] [j-weight[i]]推出，**dp[i-1] [j-weight[i]]<strong>为背包容量为</strong>j-weight[i]<strong>的时候不放物品i的最大价值，那么</strong>dp[i-1] [j-weight[i]+value[i]]**，就是背包放物品i得到的最大价值。</p><p>所以递推公式为</p><p><strong>dp[i] [j] &#x3D; max(dp[i-1] [j], dp[i-1] [j-weight[i]]+value[i])</strong></p><p>3.dp数组如何初始化</p><p>背包容量j为0的话，即dp[i] [0]，无论选取哪些物品，背包价值总和一定为0</p><p>当i为零时</p><p>j&lt;weight[0]时，dp[0] [j]应该是0</p><p>当j &gt;&#x3D; weight[0]时，dp[0] [j]应该是value[0]</p><p>4.确定遍历顺序</p><p>先遍历物品或者先遍历背包都可以</p><p>先遍历物品的代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i&#x3D;1;i&lt;weight.size();i++)&#123;    for(int j&#x3D;0;j &lt;&#x3D; bagweight;j++)    &#123;        if(j&lt;weight)            dp[i][j] &#x3D; dp[i-1][j];                else            dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i]);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先遍历背包的代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int j&#x3D;0;j &lt;&#x3D; bagweight;j++)&#123;    for(int i&#x3D;1;i &lt; weight.size();i++)    &#123;        if(j &lt; weight[i])            dp[i][j] &#x3D; dp[i-1][j];        else            dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i]);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完整代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void bag01()&#123;    vector&lt;int&gt; weight &#x3D; &#123;1,3,4&#125;;    vector&lt;int&gt; value &#x3D; &#123;15,20,30&#125;;    int bagweight &#x3D;  4;        vector&lt;vector&lt;int&gt;&gt; dp(weight.size(), vector&lt;int&gt;(bagweight + 1, 0));        for(int j &#x3D; weight[0];j &lt;&#x3D; bagweight;j++)    &#123;        dp[0][j] &#x3D; value[0];    &#125;        for(int i&#x3D;1;i&lt;weight.size();i++)    &#123;        for(int j&#x3D;0;j&lt;&#x3D;bagweight;j++)        &#123;         if(j &lt; weight[i])                   dp[i][j] &#x3D; dp[i-1][j];            else                dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i]);        &#125;    &#125;    cout&lt;&lt;dp[weight.size() - 1][bagweight]&lt;&lt;endl;&#125;int main()&#123;    bag01();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="01背包理论基础（滚动数组）"><a href="#01背包理论基础（滚动数组）" class="headerlink" title="01背包理论基础（滚动数组）"></a>01背包理论基础（滚动数组）</h3><h4 id="一维dp数组（滚动数组）"><a href="#一维dp数组（滚动数组）" class="headerlink" title="一维dp数组（滚动数组）"></a>一维dp数组（滚动数组）</h4><p> 如果把dp[i-1]那一层拷贝到dp[i]上，表达式可以是：dp[i] [j] &#x3D; max(dp[i] [j], dp[i] [j - weight[i]] + value[i])</p><p>可以直接改为一个一维数组</p><p>1.确定dp数组的定义 </p><p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p><p>2.一维数组的递推公式</p><p>dp[j]为容量为j的背包所背的最大价值</p><p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值</p><p>dp[j - weight[i]] + value[i]表示容量为j - 物品i重量的背包 + 物品i的价值</p><p>即 容量为j的背包，放入了物品i了之后的价值即：dp[j]</p><p>此时，dp[j]有两个选择，</p><p>一个是 不放物品i，值取自己，相当于dp[i-1] [j]</p><p>一个是 放入物品i，值取dp[j - weight[i]] + value[i]</p><p>递推公式为</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.一维dp数组如何初始化</p><p>dp[0] &#x3D; 0</p><p>dp数组在推导的时候一定是取价值最大的数，要比题目给的价值小，这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖</p><p>4.一维dp数组遍历顺序</p><p><strong>一维dp遍历背包应该从大到小遍历（倒序遍历）</strong></p><p>在二维数组中，右下角的值依赖上一层左上角的值，因此需要保证左边的值仍是上一层的，从右向左覆盖</p><p><strong>倒序遍历保证物品i只被放入一次</strong></p><p><strong>必须先遍历物品再遍历背包容量</strong></p><p>如果背包遍历放在上一层，那么每个dp[j]就只会放入一个物品</p><p>5.举例推导</p><p>完整代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void bag01_Onedimensional()&#123;    vector&lt;int&gt; weight &#x3D; &#123;1,3,4&#125;;    vector&lt;int&gt; value - &#123;15,20,30&#125;;    int bagweight &#x3D; 4;        vector&lt;int&gt; dp(bagweight +1,0);    for(int i&#x3D;0;i &lt; weight.size();i++)    &#123;        for(int j&#x3D;bagweight;j &gt;&#x3D; weight[i];j--)        &#123;            dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);        &#125;    &#125;    cout&lt;&lt;dp[bagweight]&lt;&lt;endl;&#125;int main()&#123;    baag01_Onedimensional();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言（第三版）王爽—第四章</title>
      <link href="/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-di-si-zhang/"/>
      <url>/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-di-si-zhang/</url>
      
        <content type="html"><![CDATA[<h1 id="4-3编辑源程序"><a href="#4-3编辑源程序" class="headerlink" title="4.3编辑源程序"></a>4.3编辑源程序</h1><p>（1）进入DOS，运行edit</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20190805.png"></p><p>（2）在edit中编辑程序</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20191012.png"></p><p>（3）将程序保存为c:\1.asm后退出edit</p><h1 id="4-4编译"><a href="#4-4编译" class="headerlink" title="4.4编译"></a>4.4编译</h1><p><strong>（1）进入DOS，c:\masm，运行masm.exe</strong></p><p>默认文件扩展名为ASM，如果源程序不是以asm为扩展名，就要输入它的全名</p><p>输入文件名时还要指明路径</p><p><strong>（2）输入源程序文件名后，系统提示输入目标文件名</strong></p><p>默认目标文件名与源程序名相同</p><p>也可指定目标文件所在的目录</p><p><strong>（3）忽略列表文件和交叉引用文件的生成</strong></p><p><strong>（4）对源程序的编译结束</strong></p><p>最后两行提示我们无警告和必须要改正的错误</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20191453.png"></p><p>编译过程中，我们提供了一个输入，即源程序文件。</p><p>最多可得到三个输出文件：目标文件(.obj)，列表文件(.lst)，交叉引用文件(.crf)</p><h1 id="4-5连接"><a href="#4-5连接" class="headerlink" title="4.5连接"></a>4.5连接</h1><p>  对源程序进行编译得到目标文件后，我们需要对目标文件进行连接，从而得到可执行文件</p><p>（1）进入DOS，运行link</p><p>（2）输入目标文件名</p><p>（3）忽略可执行文件名，忽略映像生成文件</p><p>（4）连接程序提示输入库文件的名称，这里直接忽略</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20192525.png"></p><p><strong>连接的作用</strong></p><p>（1）连接多个源程序</p><p>（2）连接库文件和目标文件</p><h1 id="4-6以简化的方式进行编译和连接"><a href="#4-6以简化的方式进行编译和连接" class="headerlink" title="4.6以简化的方式进行编译和连接"></a>4.6以简化的方式进行编译和连接</h1><p><strong>简化的编译：</strong></p><p>masm + 源程序文件的路径和文件名，并在结尾加上分号</p><p>过程中自动忽略中间文件的生成</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20193339.png" alt="简化编译"></p><p><strong>简化的连接：</strong></p><p>link + 目标文件的路径和文件名，并在结尾加上分号</p><p>过程中自动忽略中间文件的生成</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20193554.png" alt="简化连接"></p><h1 id="4-9程序执行过程的跟踪"><a href="#4-9程序执行过程的跟踪" class="headerlink" title="4.9程序执行过程的跟踪"></a>4.9程序执行过程的跟踪</h1><p>输入debug 1.exe跟踪程序的执行</p><p>使用R命令查看各个寄存器的设置情况</p><p>cx中存放的是程序的长度</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20200013.png" alt="debug的过程"></p><p><strong>DOS系统中.exe文件的加载</strong></p><p>找到一段起始地址SA:1000</p><p>在这段内存的前256个字节中，创建一个程序段前缀(PSP)</p><p>从这段内存区的256字节处开始，将程序装入，地址为SA+10H:0</p><p>将段地址存入ds中，初始化其它相关寄存器后，设置CS:IP指向程序的入口</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言（第三版）王爽—实验4</title>
      <link href="/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-si/"/>
      <url>/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-si/</url>
      
        <content type="html"><![CDATA[<h1 id="BX-和loop的使用"><a href="#BX-和loop的使用" class="headerlink" title="[BX]和loop的使用"></a>[BX]和loop的使用</h1><h3 id="（1）编程，向内存0-2000-23F依次传送数据063-3FH"><a href="#（1）编程，向内存0-2000-23F依次传送数据063-3FH" class="headerlink" title="（1）编程，向内存0:2000:23F依次传送数据063(3FH)"></a>（1）编程，向内存0:200<del>0:23F依次传送数据0</del>63(3FH)</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-17%20161753.png" alt="源程序"></p><p>编译后查看寄存器存储情况</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-17%20162152.png"></p><h3 id="（2）编程，向内存0-2000-23F依次传送数据063-3FH-，程序中只能使用9条指令，包括mov-ax-4c00h-int-21h"><a href="#（2）编程，向内存0-2000-23F依次传送数据063-3FH-，程序中只能使用9条指令，包括mov-ax-4c00h-int-21h" class="headerlink" title="（2）编程，向内存0:2000:23F依次传送数据063(3FH)，程序中只能使用9条指令，包括mov ax,4c00h,int 21h"></a>（2）编程，向内存0:200<del>0:23F依次传送数据0</del>63(3FH)，程序中只能使用9条指令，包括mov ax,4c00h,int 21h</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-17%20162633.png" alt="源程序"></p><h3 id="（3）补全程序，调试程序（程序略），跟踪运行结果"><a href="#（3）补全程序，调试程序（程序略），跟踪运行结果" class="headerlink" title="（3）补全程序，调试程序（程序略），跟踪运行结果"></a>（3）补全程序，调试程序（程序略），跟踪运行结果</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-wu/"/>
      <url>/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-wu/</url>
      
        <content type="html"><![CDATA[<ol><li>将下面的程序编译、连接，用debug加载、跟踪，然后回答问题</li></ol><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20153046.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20153158.png"></p><p>debug加载跟踪</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20152805.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20152909.png"></p><p>（1）CPU执行程序，程序返回前，data段中的数据为多少？</p><p>不变</p><p>（2）CPU执行程序，程序返回前，cs &#x3D; ？、ss &#x3D; ？、ds &#x3D; ？</p><p>cs &#x3D; 076C，ss &#x3D; 076B，ds &#x3D; 076A</p><p>（3）设程序加载后，code段的段地址为X，则data段的段地址为？，stack段的段地址为？</p><p>data段的段地址为X-2，stack段的段地址为X-1</p><ol start="2"><li>将下面的程序编译、连接，用debug加载、跟踪，然后回答问题</li></ol><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20161312.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20161408.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20161833.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20161924.png"></p><p>（1）CPU执行程序，程序返回前，data段中的数据为多少</p><p>不变</p><p>（2）CPU执行程序，程序返回前，cs &#x3D; ？、ss &#x3D; ？、ds &#x3D; ？</p><p>cs &#x3D; 076C，ss &#x3D; 076B，ds &#x3D; 076A</p><p>（3）设程序加载后，code段的段地址为X，则data段的段地址为？，stack的段地址为？</p><p>data段的段地址为X-2，stack段的段地址为X-1</p><p>（4）对于如下定义的段：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">name segment...name ends<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果段中的数据占N个字节，则程序加载后，该段实际占有的空间为？</p><p>如果N小于16，那么实际占用16个字节；如果N大于16，那么实际占用（N&#x2F;16的取整+1）*16个字节。</p><ol start="3"><li>将下面的程序编译、连接，用debug加载、跟踪，然后回答问题<img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20162859.png"></li></ol><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20162941.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20163133.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20163234.png"></p><p>（1）CPU执行程序，程序返回前，data段中的数据为多少</p><p>不变</p><p>（2）CPU执行程序，程序返回前，cs &#x3D; ？、ss &#x3D; ？、ds &#x3D; ？</p><p>（3）设程序加载后，code段的段地址为X，则data段的段地址为？，stack的段地址为？</p><p>data段的段地址为X2，stack段的段地址为</p><ol start="4"><li>如果将1、2、3题中的最后一条伪指令end start改为end（也就是说，不指明程序的入口），则哪个程序仍然可以正确执行？请说明原因</li></ol><p>程序3可以正确执行</p><p>当将最后一条伪指令改为end时，程序将从第一条代码来执行，而程序1、2中开头的代码段是数据段，可能将数据段解释为其他的指令造成混乱</p><ol start="4"><li>程序如下，编写code段中的代码，将a段，b段中的数据依次相加，将结果存到c段中</li></ol><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20164627.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20164710.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20164924.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20165011.png"></p><ol start="4"><li>程序如下，编写code段中的代码，用push指令将a段中的前8个字型数据，逆序存储到b段中</li></ol><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20170816.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20170848.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20170952.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20171024.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言（第三版）王爽—实验二</title>
      <link href="/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-er/"/>
      <url>/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-er/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="debug的使用"><a href="#debug的使用" class="headerlink" title="debug的使用"></a>debug的使用</h2><p><strong>关于D命令</strong></p><p>debug在执行如d 段地址：偏移地址这种D命令时，将段地址送入ds中比较方便</p><p><strong>在E,A,U命令中使用段寄存器</strong></p><p>debug的T命令在执行修改寄存器SS的指令时，下一条指令也紧接着被执行</p><h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><p>(1)使用debug将程序段写入内存中，并逐条执行</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_211335.png" alt="输入指令"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言（第三版）王爽—实验三</title>
      <link href="/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-san/"/>
      <url>/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-san/</url>
      
        <content type="html"><![CDATA[<h1 id="实验3-编程、编译、连接"><a href="#实验3-编程、编译、连接" class="headerlink" title="实验3 编程、编译、连接"></a>实验3 编程、编译、连接</h1><p>（1）将书中给出的程序保存为t1.asm文件，将其生成可执行文件t1.exe</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20203934.png" alt="在edit中输入程序"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20204305.png" alt="编译t1.asm文件"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20204454.png" alt="连接目标文件，生成可执行文件"></p><p>（2）用debug跟踪t1.exe的执行过程，写出每一步执行后，相关寄存器中的内容和栈顶的内容</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20204616.png" alt="查看各个寄存器的设置情况"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20204725.png" alt="分别执行每一条指令"></p><p><strong>执行至int 21H时，用p指令结束程序</strong></p><p><strong>显示”program terminated normally”表示程序已正常执行完毕</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20204818.png" alt="所有指令执行完毕"></p><p>（3）PSP的头两个字节是CD20，用debug加载t1.exe，查看PSP的内容</p><p>利用r命令查看寄存器内容</p><p>查看075a</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20205248.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言（第三版）王爽——实验一</title>
      <link href="/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-yi/"/>
      <url>/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="查看CPU和内存，用机器指令和汇编指令编程"><a href="#查看CPU和内存，用机器指令和汇编指令编程" class="headerlink" title="查看CPU和内存，用机器指令和汇编指令编程"></a>查看CPU和内存，用机器指令和汇编指令编程</h1><h2 id="debug的使用"><a href="#debug的使用" class="headerlink" title="debug的使用"></a>debug的使用</h2><h3 id="安装DOSBOX进行实验"><a href="#安装DOSBOX进行实验" class="headerlink" title="安装DOSBOX进行实验"></a>安装DOSBOX进行实验</h3><p><strong>R命令查看改变CPU寄存器内容</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_193445.png" alt="DOSBOX界面"></p><p>在所有寄存器的下方，debug还列出了CS:IP所指向的内存单元处所存放的机器码，并将它翻译为机器指令。</p><p>此处CS:IP所指向的内存单元为073F:0100.此处存放的及机器码为 0000 ，对应的汇编指令为 ADD [BX+SI],AL。</p><p>还可以利用R指令修改寄存器中的内容</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_194422.png" alt="使用R命令修改AX中的内容"></p><p><strong>D命令查看内存中的内容</strong></p><p>d 段地址：偏移地址</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_195008.png" alt="D命令查看内存1000:0处的内容"></p><p>debug将列出从指定内存单元往后128个内存单元的内容（1000:0~1000:F）</p><p>也可以指定查看的范围 d 段地址:起始偏移地址 结尾偏移地址</p><p><strong>用D命令改写内存内容</strong></p><p>e 起始地址 数据 数据 数据 数据…</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_200320.png" alt="用E指令修改1000：0开始的4个单元的内容"></p><p>也可以采用提问的方式来逐个的修改内存的内容</p><p><strong>用E命令向内存中写入机器码，用U命令查看内存中机器码的含义，用T命令执行内存中的机器码</strong></p><p>写入机器码</p><p>mov ax,0001</p><p>mov cx,0002</p><p>add ax,cx</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_202323.png" alt="将机器码写入内存"></p><p>使用U命令翻译</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_202645.png" alt="用U命令将内存单元中的内容翻译为汇编指令显示"></p><p>简单的使用T命令可以执行CS:IP指向的指令</p><p>若要用T命令控制CPU执行某个指令，必须先让CS:IP指向该指令</p><p>可用R命令修改CS:IP中的内容，使CS:IP指向指定的内容</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_203550.png" alt="修改CS:IP指向的内容"></p><p>再使用T命令执行指令</p><p>注意，指令执行后，AX中的内容被改写为1，IP改变为IP+3，CS:IP指向下一条指令</p><p><strong>A命令以汇编指令的形式在内存中写入机器指令</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_204150.png" alt="用A命令向从1000：0开始的内存单元中写入指令"></p><h3 id="本次实验中需要用到的命令"><a href="#本次实验中需要用到的命令" class="headerlink" title="本次实验中需要用到的命令"></a>本次实验中需要用到的命令</h3><p>查看修改CPU寄存器的内容：R命令</p><p>查看内存中的内容：D命令</p><p>修改内存中的内容：E命令（可以写入数据指令）</p><p>将内存中的内容解释为机器指令和对应的汇编指令：U命令</p><p>执行CS:IP指向的内存单元处的指令：T命令</p><p>以汇编指令的形式向内存中写入指令：A命令</p><h3 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h3><p>（1）使用debug，将下面的程序写入内存，逐条执行，观察每条指令(此处指令省略)执行后CPU中相关寄存器中内容的变化。</p><p>提示：可用E命令和A命令以两种方式将指令写入内存</p><p>（2）将下面3条指令写入从2000：0开始的内存单元中，利用这3条指令计算2的8次方。</p><p>mov ax,1</p><p>add ax,ax</p><p>jmp 2000:0003</p><p>（3）查看内存中的内容</p><p>（4）向内存从B8100H开始的单元中填写数据</p><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p>（1）使用debug，将下面的程序写入内存，逐条执行，观察每条指令(此处指令省略)执行后CPU中相关寄存器中内容的变化。</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_205601.png" alt="写入内存"></p><p>（2）将下面3条指令写入从2000：0开始的内存单元中，利用这3条指令计算2的8次方。</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_210154.png" alt="用A命令写入指令"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_211335.png"></p><p>执行八次即可得到2的8次方</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字节前端初阶训练营—计算机网络概论</title>
      <link href="/2023/06/25/zi-jie-qian-duan-chu-jie-xun-lian-ying-ji-suan-ji-wang-luo-gai-lun/"/>
      <url>/2023/06/25/zi-jie-qian-duan-chu-jie-xun-lian-ying-ji-suan-ji-wang-luo-gai-lun/</url>
      
        <content type="html"><![CDATA[<h1 id="01-简介"><a href="#01-简介" class="headerlink" title="01.简介"></a>01.简介</h1><h3 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h3><p><strong>自底向上</strong></p><p>由简单到复杂</p><p>由局部到整体</p><p><strong>自顶向下</strong></p><p>由复杂到简单</p><p>将复杂的系统问题模块化处理</p><h1 id="02-通过蟹堡王案例来理解计算机网络系统"><a href="#02-通过蟹堡王案例来理解计算机网络系统" class="headerlink" title="02.通过蟹堡王案例来理解计算机网络系统"></a>02.通过蟹堡王案例来理解计算机网络系统</h1><p>蟹老板要管理遍布全国的蟹堡王分店需要很多基础设施，其中比较重要的一项为通信。</p><p>为了开通外卖服务，扩大服务范围，蟹堡王需要建立专属于蟹堡王的通信网络。</p><p>蟹堡王的服务模式与现实中的计算机网络系统有许多相近之处</p><ul><li><p>比奇堡外卖</p></li><li><p>北京和上海分店</p></li><li><p>全国分店和通信网络</p></li><li><p><strong>蟹堡王顾客：客户端</strong></p></li><li><p><strong>蟹堡王分店：服务端</strong></p></li><li><p><strong>小区转发点和蟹堡王城市转发分店：路由器</strong></p></li><li><p><strong>转发表格网络协议</strong></p></li></ul><h1 id="03-计算机网络基础"><a href="#03-计算机网络基础" class="headerlink" title="03.计算机网络基础"></a>03.计算机网络基础</h1><p><strong>网络组成部分</strong></p><ul><li><p>主机：客户端和服务端</p></li><li><p>路由器</p></li><li><p>网络协议</p></li></ul><p><strong>网络结构：网络的网络</strong></p><ul><li><p>比奇堡和小区网络：本地网络</p></li><li><p>北京和上海分店+比奇堡：三个本地网络节点的网络</p></li><li><p>全国通信网络：本地网络的网络</p></li></ul><p>以上三种网络可以称为区域网络，城域网，广域网</p><blockquote><p>区域网络（Local area network，简称LAN）是连接住宅、学校、实验室、大学校园或办公大楼等有限区域内计算机的计算机网络。</p><p>城域网又称都会网络，指大型的计算机网络，是介于LAN和WAN之间能传输语音与资料的公用网络，这些网络通常涵盖一个大学校园或一座城市。 一些常用于城市区网的技术包含：异步传输模式（ATM）、光纤分布数据接口（FDDI）、千兆乙太网。</p><p>广域网（英语：Wide Area Network，缩写为WAN），又称外网、公网。 是连接不同地区局域网或城域网计算机通信的远程网。 通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个地区、城市和国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。 广域网并不等同于互联网。</p></blockquote><p><strong>信息交换的方式一般有两种：电路交换&amp;分组交换</strong></p><blockquote><p>电路交换（Circuit Switching）是相对于封包交换（或称分组交换）的一个概念。 电路交换要求必须首先在通信双方之间建立连接通道。 在连接建立成功之后，双方的通信活动才能开始。 通信双方需要传递的信息都是通过已经建立好的连接来进行传递的，而且这个连接也将一直被维持到双方的通信结束。</p><p>分组交换（Packet switching）是一种相对于电路交换的通信范例，分组（又称消息、或消息碎片）在节点间单独路由，不需要在传输前先建立通信路径。 分组交换是数据通信中一种新的且重要的概念，现在是世界上互联网通讯、数据和语音通信中最重要的基础。</p></blockquote><p><strong>网络分层</strong></p><p>计算机网络分为五层</p><p>从低到高为</p><p>物理层 链路层 网络层 运输层 应用层</p><p>每一层都有各自的职责，并对自身层级的内容进行分装，这些内容对于上一层几乎是黑盒的</p><p>类比于现实中的例子</p><ul><li><p>快递员不关心包裹内容</p></li><li><p>卡车司机不关心车厢里拉的是什么</p></li><li><p>高速公路不关心开的什么车</p></li></ul><p><strong>协议</strong></p><p>协议的存在依赖于连接</p><p>协议定义了在两个或多个通信实体之间交换的<strong>报文格式和顺序</strong>，以及报文发送和&#x2F;或接受一条报文或其他事件所采取的动作</p><p><strong>标头(header)和载荷(payload)</strong></p><blockquote><p>HTTP 标头（header）允许客户端和服务器通过 HTTP 请求（request）或者响应（response）传递附加信息。一个 HTTP 标头由它的名称（不区分大小写）后跟随一个冒号（:），冒号后跟随它具体的值。该值之前的空格 (en-US)会被忽略。  </p></blockquote><p><strong>报文的组成：链路层头部+IP协议头部+TCP头部+HTTP头部+HTTP正文</strong></p><p><strong>http协议</strong></p><p>在http&#x2F;1.1中，头部和载荷通过两个换行符和两个回车符进行分割(\r\n\r\n)</p><p><strong>TCP协议</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20214828.png"></p><p>TCP协议中，最前面的2个字节是源端口号，往后的2个字节是目标端口号</p><p>接下来的8个字节分别是序列号（4字节）、ACK号（4字节）</p><p>TCP中头部和载荷的分割依靠图中Data offset部分（13~14字节）</p><p>在HTTP协议中，需要对ASCII码进行解析，得到二进制数据，发现有连续的换行符和回车符即为头部与载荷的分割</p><p><strong>小结</strong></p><ul><li><p>网络组成部分：由主机、路由器、交换机组成</p></li><li><p>网络结构：网络的网络</p></li><li><p>信息交换方式：电路交换和分组交换</p></li><li><p>网络分层：分清职责，物理层、链路层、网络层、运输层和应用层</p></li><li><p>网络协议：标头和载荷</p></li></ul><h1 id="04-Web中的网络"><a href="#04-Web中的网络" class="headerlink" title="04.Web中的网络"></a>04.Web中的网络</h1><p><strong>HTTP协议</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20220157.png"></p><p>在这个示例中，红色的是请求，蓝色的是响应</p><p><strong>HTTP请求</strong></p><ul><li>第一行：GET &#x2F; HTTP&#x2F;1.1</li></ul><p>这三项分别代表请求的方法、资源路径、HTTP版本</p><ul><li>其他几行：头部</li></ul><p>每一行代表一个头部，头部的名称和头部的值用冒号分割</p><p>头部名称不区分大小写</p><ul><li>正文与头部间隔一行（此示例中没有头部）</li></ul><p><strong>HTTP响应</strong></p><ul><li>第一行：HTTP&#x2F;1.1 200 OK</li></ul><p>状态行</p><p>这三项分别代表HTTP版本、状态码、状态信息（可以自定义）</p><ul><li><p>其他几行：头部（与HTTP请求类似）</p></li><li><p>正文与头部间隔一行</p></li></ul><p><strong>HTTP连接模型（请求响应模型）</strong></p><p>当客户端发起第一个请求后，需要等待服务端发送第一个的完整响应，客户端才可以发出第二个请求</p><p>缺点：无法进行多路复用</p><p>Short-lived connections（HTTP&#x2F;1.0）：</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20221026.png"></p><p>Persistent connection（HTTP&#x2F;1.1）:</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20221457.png"></p><p>HTTP Pipeling:</p><p>允许客户端发送多个请求，服务器按顺序响应</p><p>但对于解决队头堵塞几乎没有帮助</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20221617.png"></p><p>为解决队头堵塞问题，最常用的方案是同时建立多个HTTP连接，将请求分散在多个HTTP连接上</p><p>浏览器一般会限制HTTP连接的数量，通常是6个</p><p><strong>HTTP1.1：无法多路复用</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">body<span class="token punctuation">&#123;</span>    <span class="token literal-property property">color</span><span class="token operator">:</span> red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果按行交错发送，客户端收到的内容将会是</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">body<span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token literal-property property">color</span><span class="token operator">:</span> red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>无法判断流中的哪一行都是属于哪个请求，因此无法实现多路复用</p><p><strong>HTTP2：帧</strong></p><p>将多个HTTP请求拆分到帧中，每个帧可以携带来自不同HTTP请求的数据（此处的帧和链路层的帧并非同一种，只是原理类似）</p><p>可以标识哪个数据包来自哪个请求，进而实现多路复用</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">request=style.css<span class="token punctuation">,</span> content=<span class="token string">'body&#123;'</span>request=main.js<span class="token punctuation">,</span> content-<span class="token string">'console.log('</span>hello world<span class="token string">')'</span>request=style.css<span class="token punctuation">,</span> content=<span class="token string">' color: red;'</span>request=style.css<span class="token punctuation">,</span> content=<span class="token string">'&#125;'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>HTTP帧的结构</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20222953.png"></p><p>最开始的3个字节：帧的长度</p><p>第4个字节：帧的类型</p><p>第5个字节：当前帧的状态</p><p>第6个字节：第1位是保留位，后面的31位代表这个帧所属流的ID</p><p>后面为帧的载荷</p><p><strong>HTTP2：帧带来的额外好处</strong></p><ul><li><p>调整响应传输的优先级</p></li><li><p>头部压缩</p></li><li><p>Server Push</p></li></ul><p><strong>HTTP 2：队头堵塞，但是在TCP上</strong></p><p>由于TCP对上层数据缺乏必要的信息（包1不影响包0、2、3），导致队头堵塞</p><p>这个问题很难再已有的TCP协议上解决</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20224128.png"></p><p><strong>HTTP 2：3RTT启动</strong></p><p>TCP连接建立需要一个RTT</p><p>TLS连接建立需要两个RTT</p><p>效率很低</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20224317.png"></p><p><strong>HTTP 3：QUIC</strong></p><p>QUIC将TLS作为自身的一部分，吸取HTTP 2中流的概念</p><p>同时引入新的机制，实现首次1 RTT，后续连接0 RTT的特性</p><ul><li><p>Quick UDP Internet Connection</p></li><li><p>现存网络设备对TCP和UDP支持已经僵化</p></li><li><p>UDP不靠谱但是QUIC靠谱</p></li><li><p>QUIC可以为除HTTP协议以外的应用层协议提供支持</p></li></ul><p><strong>HTTP 3：QUIC-1 RTT</strong></p><p>QUIC实现首次1 RTT，后续连接0 RTT的过程</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20224949.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20225129.png"></p><p><strong>除HTTP外，还有很多因素会影响浏览器的性能</strong></p><p><strong>CDN：你无法突破的物理极限</strong></p><p>超远距离因素无法克服</p><p>流量越大，花销越大</p><p>服务器承载网络流量有限</p><p>CDN可以承担内容分发的任务</p><p><strong>CDN：DNS劫持</strong></p><ul><li><p>域名解析一般由网站自己处理</p></li><li><p>要加速的域名则重定向到CDN厂商的域名解析服务处理</p></li><li><p>CDN厂商根据来源确定最近的CDN服务器的IP</p></li><li><p>用户直接访问最近的CDN服务器</p></li></ul><p><strong>CDN：如何选择CDN服务器</strong></p><p>一种比较简单的策略是，根据DNS查询来源IP的地理位置，确定最近的CDN服务器</p><p>但这并不是最好的策略</p><p><strong>CDN：拉策略和推策略</strong></p><blockquote><p>CDN 加速策略有两种方式，分别是<strong>「推模式」和「拉模式」</strong>。   </p><p> 大部分 CDN 加速策略采用的是「拉模式」，当用户就近访问的 CDN 节点没有缓存请求的数据时，CDN 会主动从源服务器下载数据，并更新到这个 CDN 节点的缓存中。    </p><p>可以看出，拉模式属于被动缓存的方式，与之相反的 「推模式」就属于主动缓存的方式。   </p><p> 如果想要把资源在还没有用户访问前缓存到 CDN 节点，则可以采用「推模式」，这种方式也叫 CDN 预热。   </p><p> 通过 CDN 服务提供的 API 接口，把需要预热的资源地址和需要预热的区域等信息提交上去，CDN 收到后，就会触发这些区域的 CDN 节点进行回源来实现资源预热。</p></blockquote><p>CDN可以从物理层面解决HTTP无法解决的问题，进而提升web应用的性能</p><p><strong>WebSocket</strong></p><p>WebSocket有以下特点：</p><ul><li><p>有状态的持久连接</p></li><li><p>服务端可以主动推送消息</p></li><li><p>发送消息延迟比HTTP低</p></li></ul><p>使用websocket协议需要在HTTP协议的基础上，双方进行协商</p><p><strong>WebSocket：示例</strong></p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">//服务端代码const</span> <span class="token punctuation">&#123;</span> WebSocketServer <span class="token punctuation">&#125;</span> = <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'ws'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token selector">const wss = new WebSocketServer(</span><span class="token punctuation">&#123;</span> <span class="token property">port</span><span class="token punctuation">:</span> 8080<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token selector">wss.on('connection', function connection(ws)</span> <span class="token punctuation">&#123;</span>    <span class="token selector">//有新连接时监听来自客户端的消息    ws.on('message', function message(data)</span> <span class="token punctuation">&#123;</span>        //打印收到的消息，再把消息原封不动地发回客户端        console.<span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'received: %s'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>        ws.<span class="token function">send</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css" data-language="css"><code class="language-css">//客户端代码const WebSocket = <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'ws'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>const ws = new <span class="token function">WebSocket</span><span class="token punctuation">(</span><span class="token string">'ws://localhost:8080'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token selector">ws.on('open', function open()</span> <span class="token punctuation">&#123;</span>    //当连接建立时，向服务器端发送一条消息    ws.<span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'something'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token selector">ws.on('message', function message(data)</span> <span class="token punctuation">&#123;</span>    //当收到来自服务器端的消息时，打印出来    console.<span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'received: %s'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>升级HTTP为WebSocket</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20233020.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20233056.png"></p><p><strong>WebSocket：发送消息</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20233231.png"></p><p><strong>小结</strong></p><ul><li><p>HTTP1、2、3的演进历史</p></li><li><p>CDN解决了HTTP协议以外的问题</p></li><li><p>WebSocket从HTTP协议升级而来</p></li></ul><h1 id="05-网络安全"><a href="#05-网络安全" class="headerlink" title="05.网络安全"></a>05.网络安全</h1><p><strong>网络安全：三要素</strong></p><ul><li><p>机密性</p></li><li><p>完整性</p></li><li><p>身份验证</p></li></ul><p><strong>网络安全：对称加密和非对称加密</strong></p><ul><li><p>对称加密：加密、解密用同样的密钥</p></li><li><p>非对称加密：加密、解密使用不同的密钥（公钥和私钥），而且公钥加密只能用私钥解密、私钥加密只能用公钥解密</p></li></ul><p><strong>网络安全：密码散列函数（哈希函数）</strong></p><ul><li><p>输入：任意长度的内容</p></li><li><p>输出：固定长度的哈希值</p></li><li><p>性质：找到两个不同输入使之经过密码散列函数后有相同的哈希值，在计算上是不可能的</p></li></ul><p><strong>网络安全：机密性</strong></p><ul><li><p>加密需要加密算法和密钥等信息（秘密信息）</p></li><li><p>网络是明文的，不安全</p></li></ul><p><strong>网络安全：完整性和身份验证</strong></p><p>完整性和身份验证相关联</p><p><strong>网络安全：如何实现机密性</strong></p><p>想要通过明文通信交换秘密信息，通信双方需要先有秘密信息</p><p><strong>网络安全：如何实现完整性</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20234140.png"><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20234149.png"></p><p><strong>网络安全：如何实现身份验证</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20234252.png"></p><p>（未完待续）</p><p>让我先把当天的笔记发上去，有时间补上后面的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字节前端初阶训练营—shell脚本和编程</title>
      <link href="/2023/06/25/zi-jie-qian-duan-chu-jie-xun-lian-ying-shell-jiao-ben-he-bian-cheng/"/>
      <url>/2023/06/25/zi-jie-qian-duan-chu-jie-xun-lian-ying-shell-jiao-ben-he-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="01-课程介绍"><a href="#01-课程介绍" class="headerlink" title="01.课程介绍"></a>01.课程介绍</h1><p>学习shell的价值：</p><p>1.linux服务器的基本操作和管理</p><p>2.前端Node.js服务的进程管理、问题排查、资源监控等运维操作</p><p>3.使用shell编写TCE、SCM、Docker脚本完成服务编译和部署</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字节前端初阶训练营—Linux基础</title>
      <link href="/2023/06/25/zi-jie-qian-duan-chu-jie-xun-lian-ying-linux-ji-chu/"/>
      <url>/2023/06/25/zi-jie-qian-duan-chu-jie-xun-lian-ying-linux-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="01-计算机硬件"><a href="#01-计算机硬件" class="headerlink" title="01.计算机硬件"></a>01.计算机硬件</h1><p>计算机由五大基本单元组成</p><ul><li><p>控制器</p></li><li><p>运算器</p></li><li><p>存储器单元</p></li><li><p>输入单元</p></li><li><p>输出单元</p></li></ul><h1 id="02-操作系统"><a href="#02-操作系统" class="headerlink" title="02.操作系统"></a>02.操作系统</h1><p><strong>操作系统（Operating System，OS）</strong></p><p>管理和控制计算机系统中的硬件和软件资源，用于在用户与系统硬件之间传递信息</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20160350.png"></p><p>目前主流的操作系统有MacOS、Linux、Windows、安卓、HarmonyOS</p><p><strong>操作系统启动流程</strong></p><p>操作系统启动共有两种模式</p><ol><li>基于BIOS引导操作系统启动的传动模式</li><li>基于UEFI引导操作系统启动的主流模式</li></ol><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20160807.png"></p><p>BIOS和UEFI是固化在主板上的一段程序，当计算机开机时能够自动运行这段程序</p><p>当这段程序被启动以后，首先进行初始化等一系列的动作，找到并运行Bootloader（操作系统引导程序），通过Bootloader运行OS</p><p>UEFI优化了BIOS的自检流程，提高了启动速度</p><blockquote><p>BIOS（英文：Basic Input&#x2F;Output System），即基本输入输出系统，亦称为ROM BIOS、System BIOS、PC BIOS，是在通电启动阶段执行硬件初始化，以及为操作系统提供运行时服务的固件。BIOS最早随着CP&#x2F;M操作系统的推出在1975年出现。BIOS预安装在个人电脑的主板上，是个人电脑启动时加载的第一个软件。许多BIOS程序都只能在特定电脑型号或特定主板型号上执行。早年，BIOS存储于ROM芯片上；现在的BIOS多存储于闪存芯片上，这方便了BIOS的更新。</p><p>统一可扩展固件接口（英语：Unified Extensible Firmware Interface，缩写UEFI）是一种个人电脑系统规格，用来定义操作系统与系统固件之间的软件界面，作为BIOS的替代方案。可扩展固件接口负责加电自检（POST）、联系操作系统以及提供连接操作系统与硬件的接口。</p></blockquote><h1 id="03-Linux系统概览"><a href="#03-Linux系统概览" class="headerlink" title="03.Linux系统概览"></a>03.Linux系统概览</h1><p><strong>Linux发展简史</strong></p><p>1969年，Unix诞生于贝尔实验室</p><p>1984年，贝尔实验室将Unix商业化</p><p>1984年，Tanenbaum开发Mnix操作系统用于教学开发并开放源码</p><p>1984年，Richard M.Stallman发起自由软件（FSF）与GNU项目，起草GPL（通用公共许可）协议</p><p>1991年，Linus Torvalds受Mnix影响实现初版的Linux内核</p><p>1992年，Linux内核以GPL协议发行V1.0</p><p><strong>Linux版本</strong></p><ul><li>内核版本</li><li>发行版本</li></ul><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20162018.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20162130.png"></p><p><strong>查看Linux系统内核版本</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">uname</span> <span class="token parameter variable">-a</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /proc/version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /etc/os-release<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>Linux应用领域</strong></p><ul><li>IT服务器（操作系统、虚拟化和云计算）</li><li>嵌入式和智能设备</li><li>个人办公桌面</li><li>学术研究和软件开发</li></ul><p><strong>Linux基本组成</strong></p><ul><li>内核</li><li>shell（命令解释器）</li><li>文件系统</li><li>应用程序</li></ul><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20162725.png"></p><p><strong>Linux体系结构</strong></p><p>Linux系统分为用户空间和内核空间</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20162837.png"></p><ul><li>内核是硬件与软件之间的中间层</li><li>内核是一个资源管理程序</li><li>内核提供一组面向系统的命令</li></ul><h1 id="03-Linux系统结构——进程管理"><a href="#03-Linux系统结构——进程管理" class="headerlink" title="03.Linux系统结构——进程管理"></a>03.Linux系统结构——进程管理</h1><p><strong>进程管理</strong></p><ul><li>进程是正在执行的一个程序或命令</li><li>进程有自己的地址空间</li><li>一个CPU核同一时间只能运行一个进程</li><li>进程由它的进程ID（PID）和它父进程的进程ID（PPID）唯一识别</li></ul><p><strong>查看进程信息</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#查看启动的nginx进程</span><span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#查看某个进程</span><span class="token function">top</span> <span class="token parameter variable">-p</span> <span class="token number">93824</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#关闭指定的进程</span><span class="token function">kill</span> <span class="token number">93824</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#全部进程动态实时视图</span><span class="token function">top</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>进程调度</strong></p><p>进程调度是指操作系统按某种策略或规则选择进程占用CPU进行运行的过程</p><ul><li>R：可执行状态</li><li>S：可中断的睡眠状态</li><li>D：不可中断的睡眠状态</li><li>T：暂停状态或跟踪状态</li><li>Z：退出状态，进程成为僵尸进程</li><li>X：退出状态，进程即将被销毁</li></ul><p><strong>进程调度的原则</strong></p><ul><li>一个CPU核同一时间只能运行一个进程</li><li>每个进程有近乎相等的执行时间</li><li>对于逻辑CPU而言进程调度使用轮询的方式进行，当轮询完成则回到第一个进程反复</li><li>进程执行消耗时间和进程量成正比</li></ul><p><strong>进程的系统调用</strong></p><p>内核空间：系统内核运行的控件</p><p>用户空间：应用程序运行的空间</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20201132.png"></p><p>当任务切换到内核态，应用程序便有权限和底层的硬件平台进行交互</p><h1 id="04-Linux系统结构——文件系统"><a href="#04-Linux系统结构——文件系统" class="headerlink" title="04.Linux系统结构——文件系统"></a>04.Linux系统结构——文件系统</h1><p><strong>文件系统</strong></p><p>文件系统是操作系统中负责管理持久数据的子系统，负责把用户的文件存到磁盘赢家那中，持久化的保存文件</p><p>Linux中，文件可以是普通文件、目录、设备、套接字</p><p>Linux中一切皆文件</p><p>Linux文件系统是采用树状的目录结构</p><p>最上层的是&#x2F;（根）目录</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20201758.png"></p><p><strong>虚拟文件系统（VFS）</strong></p><p>对应用层提供一个标准的文件<strong>操作接口</strong></p><p>对文件系统提供一个标准的文件<strong>接入接口</strong></p><p>VFS抹平不同文件之间的差异</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20202041.png"></p><p><strong>查看文件系统类型</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#df命令报告文件系统磁盘空间利用率</span><span class="token function">df</span> <span class="token parameter variable">-T</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># mount命令是挂载文件系统用的，不带任何参数运行，会打印包含文件系统类型在内的磁盘分区的信息</span><span class="token function">mount</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>文件基本操作</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> <span class="token comment">#查看文件夹下的内容</span><span class="token function">mkdir</span> demo <span class="token comment">#创建文件夹</span><span class="token function">mv</span> demo /home <span class="token comment">#移动demo文件夹到 /home</span><span class="token function">rm</span> <span class="token parameter variable">-r</span> demo <span class="token comment">#删除demo文件夹</span><span class="token function">touch</span> file.txt <span class="token comment">#创建空文件</span><span class="token function">cp</span> file.txt file_bak.txt <span class="token comment">#复制文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>文件读取流程</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20202622.png"></p><h1 id="05-Linux系统结构——用户权限"><a href="#05-Linux系统结构——用户权限" class="headerlink" title="05.Linux系统结构——用户权限"></a>05.Linux系统结构——用户权限</h1><p><strong>用户账户</strong></p><ul><li>用户账户</li></ul><p>普通用户账户：在系统中进行普通作业</p><p>超级用户账户：在系统中对普通用户和整个系统进行管理</p><ul><li>组账户</li></ul><p>标准组：可以容纳多个用户</p><p>私有组：只有用户自己</p><p><strong>查看用户信息</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#查看当前登录用户信息</span>w<span class="token comment">#查看当前用户所属的组</span><span class="token function">groups</span><span class="token comment">#查看用户的uid信息</span><span class="token function">id</span> *** <span class="token comment">#用户名</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>文件权限</strong></p><p>所有者：文件的所有者</p><p>所在组：文件的所有者所在的组</p><p>其他人：除文件所有者及所在组外的其他人</p><p>每个用户对于文件都有不同的权限，包括读（R）、写（W）、执行（X）</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20203530.png"></p><p><strong>用户权限操作</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20203705.png"></p><h1 id="06-Linux软件包"><a href="#06-Linux软件包" class="headerlink" title="06.Linux软件包"></a>06.Linux软件包</h1><ul><li>软件包</li></ul><p>通常是一个应用程序，可以是一个GUI应用程序、命令行工具或（其他软件程序需要的）软件库</p><ul><li>软件包管理</li></ul><p>底层工具：主要用来处理安装和删除软件包文件等任务，DPKG，RPM</p><p>上层工具：主要用于数据的搜索任务和依赖解析任务，APT，YUM，DNF</p><p><strong>软件包管理工具</strong></p><p>RPM（Red Hat Package Manager），为Red hat操作系统的包管理系统</p><p>DPKG（Debian Package），为Debian操作系统的包管理系统</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20204327.png"></p><p><strong>Debian APT常用命令</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20204512.png"></p><p><strong>Debian配置软件源</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20204630.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python-numpy库详解</title>
      <link href="/2023/06/25/python-numpy-ku-xiang-jie/"/>
      <url>/2023/06/25/python-numpy-ku-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>参考CSDN博主「ZSYL」的原创文章，遵循CC 4.0 BY-SA版权协议</p><p> 原文链接：<a href="https://blog.csdn.net/qq_46092061/article/details/118410838">https://blog.csdn.net/qq_46092061/article/details/118410838</a></p><h1 id="numpy介绍"><a href="#numpy介绍" class="headerlink" title="numpy介绍"></a>numpy介绍</h1><p>Numpy（Numerical Python）是一个开源的Python科学计算库，用于快速处理任意维度的数组，并且支持常见的数组和矩阵操作。</p><h2 id="ndarray"><a href="#ndarray" class="headerlink" title="ndarray"></a>ndarray</h2><p>ndarray是numpy提供的一个N维数组类型，它描述了相同类型的 items 的集合</p><p>使用示例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> nptestarray <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>   <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>testarray<span class="token comment">#返回结果</span>testarray<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ndarray比python原生的list计算速度要快很多</strong></p><h3 id="创建array"><a href="#创建array" class="headerlink" title="创建array"></a>创建array</h3><p>numpy中的array函数可以生成多维数组</p><p>通过ndarray类的shape属性可以获得每一维的元素个数，也可以通过shape[n]形式获得每一维的元素个数（n是维度，从0开始）</p><blockquote><p>常用array参数：</p><p>ndmin：指定生成数组的最小维度</p><p>dtype：数组元素的数据类型</p></blockquote><h3 id="ndarray的属性"><a href="#ndarray的属性" class="headerlink" title="ndarray的属性"></a>ndarray的属性</h3><blockquote><p>ndarray.shape：数组维度的元组</p><p>ndarray.ndim：数组维数</p><p>ndarray.size：数组中元素的数量</p><p>ndarray.itemsize：一个数组元素的长度（字节）</p><p>ndarray.dtype：数组元素的类型</p></blockquote><h3 id="ndarray的shape函数"><a href="#ndarray的shape函数" class="headerlink" title="ndarray的shape函数"></a>ndarray的shape函数</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>a<span class="token punctuation">.</span>shapeb<span class="token punctuation">.</span>shape<span class="token comment">#输出结果</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="生成数组"><a href="#生成数组" class="headerlink" title="生成数组"></a>生成数组</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#生成0 1数组</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span>shape<span class="token punctuation">,</span> dtype<span class="token punctuation">)</span>np<span class="token punctuation">.</span>ones_like<span class="token punctuation">(</span>a<span class="token punctuation">,</span> dtype<span class="token punctuation">)</span>np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>shape<span class="token punctuation">,</span> dtype<span class="token punctuation">)</span>np<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>a<span class="token punctuation">,</span> dtype<span class="token punctuation">)</span><span class="token comment">#np.empty():创建一个指定形状、数据类型且未初始化的数组，里面的元素的值是之前内存的值</span><span class="token comment">#order中，C表示行优先，F表示列优先</span>np<span class="token punctuation">.</span>empty<span class="token punctuation">(</span>shape<span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token builtin">float</span><span class="token punctuation">,</span> order<span class="token operator">=</span><span class="token string">'C'</span><span class="token punctuation">)</span><span class="token comment"># 从现有的数组当中创建 </span>a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>   a1 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">#深拷贝，在地址中重新创建对象  </span>a2 <span class="token operator">=</span> np<span class="token punctuation">.</span>asarray<span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">#浅拷贝，指针指向同一对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#生成固定范围的数组</span><span class="token comment">#start, stop：序列的起始值和终止值</span><span class="token comment">#num：要生成的等间隔样例数量，默认为50</span><span class="token comment">#endpoint：是否包含stop值</span><span class="token comment">#retstep：是否显示间距</span>np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span>start<span class="token punctuation">,</span> stop<span class="token punctuation">,</span> num<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">,</span> endpoint<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> retstep<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span>np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">0.</span><span class="token punctuation">,</span> <span class="token number">10.</span><span class="token punctuation">,</span> <span class="token number">20.</span><span class="token punctuation">,</span> <span class="token number">30.</span><span class="token punctuation">,</span> <span class="token number">40.</span><span class="token punctuation">,</span> <span class="token number">50.</span><span class="token punctuation">,</span> <span class="token number">60.</span><span class="token punctuation">,</span> <span class="token number">70.</span><span class="token punctuation">,</span> <span class="token number">80.</span><span class="token punctuation">,</span> <span class="token number">90.</span><span class="token punctuation">,</span> <span class="token number">100.</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#step：步长，默认为1</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>start<span class="token punctuation">,</span> stop<span class="token punctuation">,</span> step<span class="token punctuation">,</span> dtype<span class="token punctuation">)</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">38</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">46</span><span class="token punctuation">,</span> <span class="token number">48</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#num:要生成的等比数列数量，默认为50</span>np<span class="token punctuation">.</span>logspace<span class="token punctuation">(</span>start<span class="token punctuation">,</span> stop<span class="token punctuation">,</span> num<span class="token punctuation">)</span>np<span class="token punctuation">.</span>logspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">1.</span><span class="token punctuation">,</span> <span class="token number">10.</span><span class="token punctuation">,</span> <span class="token number">100.</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/06/25/hello-world/"/>
      <url>/2023/06/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP学习记录(1)</title>
      <link href="/2023/06/25/csapp-xue-xi-ji-lu/"/>
      <url>/2023/06/25/csapp-xue-xi-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="CSAPP——第二章"><a href="#CSAPP——第二章" class="headerlink" title="CSAPP——第二章"></a>CSAPP——第二章</h1><h2 id="2-2整数表示"><a href="#2-2整数表示" class="headerlink" title="2.2整数表示"></a>2.2整数表示</h2><h3 id="2-2-2无符号数的编码"><a href="#2-2-2无符号数的编码" class="headerlink" title="2.2.2无符号数的编码"></a>2.2.2无符号数的编码</h3><p>无符号数编码的定义</p><p>对向量$ \vec{x} $:<br>$$<br>B2U_{w}(\vec{x})&#x3D;\sum_{i&#x3D;0}^{w-1} x_{i}2^{i} \text(Binary to Unsigned)<br>$$<br>函数$ B2U_w $将一个长度为w的0、1串映射到非负整数。</p><p>函数$  B2U_w $是一个双射。</p><h3 id="2-2-3补码编码"><a href="#2-2-3补码编码" class="headerlink" title="2.2.3补码编码"></a>2.2.3补码编码</h3><p>最常见的有符号数的计算机表示方式就是__补码__。在这个定义中，将字的最高有效为解释为负权。用函数$ B2T_w $表示。</p><p>补码编码的定义</p><p>对向量$ \vec{x} $:<br>$$<br>B2T_w(\vec{x})&#x3D;-x_{w-1}+\sum_{i&#x3D;0}^{w-2} x_i2^i \text(BinarytoTwo’s-complement)<br>$$<br>最高有效位成为符号位，权重为$ -2_{w-1} $。</p><p>符号位被设置为1，表示值为负；设置为0，值为正。</p><p>最小整数值是<br>$$<br>TMin_w&#x3D;-2^{w-1}<br>$$<br>最大整数值是<br>$$<br>TMax_w&#x3D;2^{w-1}-1<br>$$<br>补码的范围是不对称的<br>$$<br>|TMin|&#x3D;|TMax|+1<br>$$<br>也就是说，TMin没有与之对应的正数。</p><p>最大的无符号数值刚好比补码的最大值的两倍大一点<br>$$<br>UMax_w&#x3D;2TMax_w+1<br>$$<br>-1是一个全1的串，0是一个全0的串。</p><p>C库中的文件&lt;limit.h&gt;定义了常量INT_MAX,INT_MIN,UINT_MAX。对于一个补码的机器，这些常量就对应TMax,TMin,UMax的值。</p><blockquote><p>有符号数的其他表示方法</p><p>反码<br>$$<br>B2O_w(\vec{x})&#x3D;-x_{w-1}(2_{w-1}-1)+\sum_{i&#x3D;0}^{w-2}x_{i}2^i<br>$$<br>原码<br>$$<br>B2S_w(\vec{x})&#x3D;(-1)^{x_{w-1}}*(\sum_{i&#x3D;0}^{w-2}x_i2^i)<br>$$</p></blockquote><h3 id="2-2-4有符号数与无符号数的转换"><a href="#2-2-4有符号数与无符号数的转换" class="headerlink" title="2.2.4有符号数与无符号数的转换"></a>2.2.4有符号数与无符号数的转换</h3><p>强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。</p><p>对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。</p><p>补码转换为无符号数</p><p>对满足TMin&lt;&#x3D;x&lt;&#x3D;TMax的x有<br>$$<br>T2U_w(x)&#x3D;x+2^w,x&lt;0<br>$$</p><p>$$<br>T2U_w(x)&#x3D;x,x&gt;&#x3D;0<br>$$</p><p>当一个有符号数映射为它相应的无符号数时，负数就被转换成了大的正数，而非负数会保持不变。</p><p>无符号数转换为补码</p><p>对满足0&lt;&#x3D;u&lt;&#x3D;UMax的u有<br>$$<br>U2T_w(u)&#x3D;u,u&lt;&#x3D;TMax_w<br>$$</p><p>$$<br>U2T_w(u)&#x3D;u-2^w,u&gt;TMax_w<br>$$</p><p>对于小的数(&lt;&#x3D;TMax),从无符号数到有符号数的转换将保留数字的原值。</p><p>对于大的数( &gt;TMax),数字将被转换为一个负数值。</p><p><strong>考虑无符号与补码表示之间相互转换的结果</strong></p><p>对于在范围0&lt;&#x3D;x&lt;&#x3D;TMax之内的值x而言，我们得到T2U(x)&#x3D;x和U2T(x)&#x3D;x。也就是说，在这个范围内的数字有相同的无符号和补码表示。</p><p>对于这个范围以外的数字，转换需要加上或者减去$ 2_w $</p><h3 id="2-2-5C语言中的有符号数与无符号数"><a href="#2-2-5C语言中的有符号数与无符号数" class="headerlink" title="2.2.5C语言中的有符号数与无符号数"></a>2.2.5C语言中的有符号数与无符号数</h3><p>当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。</p><p>这种方法对于标准的算数运算来说并无多大差异，但是对于&lt;&gt;这样的关系运算符来说，它会导致非直观的结果。</p><h3 id="2-2-6扩展一个数字的位表示"><a href="#2-2-6扩展一个数字的位表示" class="headerlink" title="2.2.6扩展一个数字的位表示"></a>2.2.6扩展一个数字的位表示</h3><p>要将一个无符号数转换为一个更大的数据类型，只要简单的在表示的开头添加0，这种运算被称为零扩展。</p><p>要将补码数字转换为一个更大的数据类型，可以执行一个符号扩展（将符号位填补前面空余位）。</p><p>数据类型转换时，要先转换大小，再完成符号的转换。</p><h3 id="2-2-7截断数字"><a href="#2-2-7截断数字" class="headerlink" title="2.2.7截断数字"></a>2.2.7截断数字</h3><p>截断无符号数<br>$$<br>x^<code>=xmod2^k $$ 截断补码数值 $$ x^</code>&#x3D;U2T_k(xmod2^k)<br>$$</p><h3 id="2-2-8关于有符号数与无符号数的建议"><a href="#2-2-8关于有符号数与无符号数的建议" class="headerlink" title="2.2.8关于有符号数与无符号数的建议"></a>2.2.8关于有符号数与无符号数的建议</h3><h2 id="2-3整数运算"><a href="#2-3整数运算" class="headerlink" title="2.3整数运算"></a>2.3整数运算</h2><h3 id="2-3-1无符号加法"><a href="#2-3-1无符号加法" class="headerlink" title="2.3.1无符号加法"></a>2.3.1无符号加法</h3><p><strong>无符号加法</strong></p><p>对满足$ 0&lt;&#x3D;x,y&lt;2_w $的x和y有：<br>$$<br>x+y&#x3D;x+y,  x+y&lt;2^w<br>$$</p><p>$$<br>x+y&#x3D;x+y-2^w,2^w&lt;&#x3D;x+y&lt;&#x3D;2^{w+1}<br>$$</p><p><strong>检测无符号数加法中的溢出</strong></p><p>对在范围0&lt;&#x3D;x,y&lt;&#x3D;UMax,中的x和y，令s&#x3D;x+y。当且仅当s&lt;x(或者等价的s&lt;y)时发生了溢出。   </p><h3 id="2-3-2补码加法"><a href="#2-3-2补码加法" class="headerlink" title="2.3.2补码加法"></a>2.3.2补码加法</h3><p>当和x+y超过TMax时，我们说发生了正溢出，截断的结果是从和数中减去$ 2_w $；当和x+y小于TMin时，我们说发生了负溢出，截断的结果是把和数加上$ 2_w $。</p><p><strong>检测补码加法中的溢出</strong></p><p>对满足TMin&lt;&#x3D;x,y&lt;&#x3D;TMax的x和y，令s&#x3D;x+y，当且仅当x&gt;0,y&gt;0,但s&lt;&#x3D;0时，计算s发生了正溢出。当且仅当x&lt;0,y&lt;0,但s&gt;&#x3D;0时，计算s发生了负溢出。</p><h3 id="2-3-3补码的非"><a href="#2-3-3补码的非" class="headerlink" title="2.3.3补码的非"></a>2.3.3补码的非</h3><p>对w位的补码加法来说，TMin是自己的加法的逆。而对其他任何数值x都有-x作为其加法的逆。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
