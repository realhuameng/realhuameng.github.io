<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>汇编语言（第三版）王爽——实验一</title>
      <link href="/2023/03/04/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-yi/"/>
      <url>/2023/03/04/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="查看CPU和内存，用机器指令和汇编指令编程"><a href="#查看CPU和内存，用机器指令和汇编指令编程" class="headerlink" title="查看CPU和内存，用机器指令和汇编指令编程"></a>查看CPU和内存，用机器指令和汇编指令编程</h1><h2 id="debug的使用"><a href="#debug的使用" class="headerlink" title="debug的使用"></a>debug的使用</h2><h3 id="安装DOSBOX进行实验"><a href="#安装DOSBOX进行实验" class="headerlink" title="安装DOSBOX进行实验"></a>安装DOSBOX进行实验</h3><p><strong>R命令查看改变CPU寄存器内容</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_193445.png" alt="DOSBOX界面"></p><p>在所有寄存器的下方，debug还列出了CS:IP所指向的内存单元处所存放的机器码，并将它翻译为机器指令。</p><p>此处CS:IP所指向的内存单元为073F:0100.此处存放的及机器码为 0000 ，对应的汇编指令为 ADD [BX+SI],AL。</p><p>还可以利用R指令修改寄存器中的内容</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_194422.png" alt="使用R命令修改AX中的内容"></p><p><strong>D命令查看内存中的内容</strong></p><p>d 段地址：偏移地址</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_195008.png" alt="D命令查看内存1000:0处的内容"></p><p>debug将列出从指定内存单元往后128个内存单元的内容（1000:0~1000:F）</p><p>也可以指定查看的范围 d 段地址:起始偏移地址 结尾偏移地址</p><p><strong>用D命令改写内存内容</strong></p><p>e 起始地址 数据 数据 数据 数据…</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_200320.png" alt="用E指令修改1000：0开始的4个单元的内容"></p><p>也可以采用提问的方式来逐个的修改内存的内容</p><p><strong>用E命令向内存中写入机器码，用U命令查看内存中机器码的含义，用T命令执行内存中的机器码</strong></p><p>写入机器码</p><p>mov ax,0001</p><p>mov cx,0002</p><p>add ax,cx</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_202323.png" alt="将机器码写入内存"></p><p>使用U命令翻译</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_202645.png" alt="用U命令将内存单元中的内容翻译为汇编指令显示"></p><p>简单的使用T命令可以执行CS:IP指向的指令</p><p>若要用T命令控制CPU执行某个指令，必须先让CS:IP指向该指令</p><p>可用R命令修改CS:IP中的内容，使CS:IP指向指定的内容</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_203550.png" alt="修改CS:IP指向的内容"></p><p>再使用T命令执行指令</p><p>注意，指令执行后，AX中的内容被改写为1，IP改变为IP+3，CS:IP指向下一条指令</p><p><strong>A命令以汇编指令的形式在内存中写入机器指令</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_204150.png" alt="用A命令向从1000：0开始的内存单元中写入指令"></p><h3 id="本次实验中需要用到的命令"><a href="#本次实验中需要用到的命令" class="headerlink" title="本次实验中需要用到的命令"></a>本次实验中需要用到的命令</h3><p>查看修改CPU寄存器的内容：R命令</p><p>查看内存中的内容：D命令</p><p>修改内存中的内容：E命令（可以写入数据指令）</p><p>将内存中的内容解释为机器指令和对应的汇编指令：U命令</p><p>执行CS:IP指向的内存单元处的指令：T命令</p><p>以汇编指令的形式向内存中写入指令：A命令</p><h3 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h3><p>（1）使用debug，将下面的程序写入内存，逐条执行，观察每条指令(此处指令省略)执行后CPU中相关寄存器中内容的变化。</p><p>提示：可用E命令和A命令以两种方式将指令写入内存</p><p>（2）将下面3条指令写入从2000：0开始的内存单元中，利用这3条指令计算2的8次方。</p><p>mov ax,1</p><p>add ax,ax</p><p>jmp 2000:0003</p><p>（3）查看内存中的内容</p><p>（4）向内存从B8100H开始的单元中填写数据</p><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p>（1）使用debug，将下面的程序写入内存，逐条执行，观察每条指令(此处指令省略)执行后CPU中相关寄存器中内容的变化。</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_205601.png" alt="写入内存"></p><p>（2）将下面3条指令写入从2000：0开始的内存单元中，利用这3条指令计算2的8次方。</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_210154.png" alt="用A命令写入指令"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_211335.png"></p><p>执行八次即可得到2的8次方</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录—字符串</title>
      <link href="/2023/02/24/suan-fa-shua-ti-ji-lu-zi-fu-chuan/"/>
      <url>/2023/02/24/suan-fa-shua-ti-ji-lu-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="算法刷题记录—字符串"><a href="#算法刷题记录—字符串" class="headerlink" title="算法刷题记录—字符串"></a>算法刷题记录—字符串</h1><h3 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h3><p>关键代码：</p><p>去掉多余的空格</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void removeExtraSpaces(string&amp; s)&#123;    int slow&#x3D;0;    for(int i&#x3D;0;i&lt;s.size();++i)    &#123;        if(s[i]!&#x3D;&#39; &#39;)        &#123;            if(slow!&#x3D;0) s[slow++]&#x3D;&#39; &#39;;            while(i&lt;s.size() &amp;&amp; s[i]!&#x3D;&#39; &#39;)                s[slow++] &#x3D; s[i++];        &#125;    &#125;    s.resize(slow);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="剑指offer-58-左旋转字符串"><a href="#剑指offer-58-左旋转字符串" class="headerlink" title="剑指offer 58:左旋转字符串"></a>剑指offer 58:左旋转字符串</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string reverseLeftWords(string s,int n)&#123;    reverse(s.begin(), s.begin()+n);    reverse(s.begin()+n,s.end());    reverse(s.begin(),s.end());    return s;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p><strong>前缀表（prefix table）：记录了模式串与主串（文本串不匹配的时候，模式串应该从哪里开始匹配）</strong></p><p><strong>记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀</strong></p><h4 id="最长公共前后缀"><a href="#最长公共前后缀" class="headerlink" title="最长公共前后缀"></a>最长公共前后缀</h4><p>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</p><p>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</p><p>前缀表要求的就是相同前后缀的长度</p><h4 id="使用next数组来匹配"><a href="#使用next数组来匹配" class="headerlink" title="使用next数组来匹配"></a>使用next数组来匹配</h4><p><strong>初始化</strong></p><p>定义两个指针，j指向前缀末尾位置，i指向后缀末尾位置。</p><p><strong>处理前后缀不相同的情况</strong></p><p>遍历模式串下标j要从1开始</p><p>如果s[i] s[j+1]不相同，也就是 前后缀末尾不相同的情况，要向前回退。</p><p><strong>处理前后缀相同的情况</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(s[i] &#x3D;&#x3D; s[j+1])&#123;    j++:&#125;next[i]&#x3D;j;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>构建next数组的函数代码</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void getNext(int* next,const string&amp; s)&#123;    int j&#x3D;-1;    next[0]&#x3D;j;    for(int i&#x3D;1;i&lt;s.size();i++)&#123;        while(j&gt;&#x3D;0 &amp;&amp; s[i] !&#x3D; s[j+1])&#123;            j &#x3D; next[j];        &#125;        if(s[i] &#x3D;&#x3D; s[j+1])            j++;        next[i]&#x3D;j;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录-哈希表</title>
      <link href="/2023/02/12/suan-fa-shua-ti-ji-lu-ha-xi-biao/"/>
      <url>/2023/02/12/suan-fa-shua-ti-ji-lu-ha-xi-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="算法刷题记录-哈希表"><a href="#算法刷题记录-哈希表" class="headerlink" title="算法刷题记录-哈希表"></a>算法刷题记录-哈希表</h1><h3 id="哈希表理论基础"><a href="#哈希表理论基础" class="headerlink" title="哈希表理论基础"></a>哈希表理论基础</h3><p><strong>哈希函数 hash function</strong><br>$$<br>index &#x3D; hashFunction(name)<br>$$</p><p>$$<br>hashFunction &#x3D; hashCode(name)%tablesize<br>$$</p><p><strong>哈希碰撞的通常解决方法</strong>：</p><p><strong>拉链法和线性探测法</strong></p><h4 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h4><ul><li><p>数组</p></li><li><p>set</p></li><li><p>map</p></li></ul><p>unordered_set&#x2F;unordered_map底层实现为哈希表，set&#x2F;map和multiset&#x2F;multimap底层实现是红黑树，key值是有序的，只能删除和增加。</p><p>要使用集合解决哈希问题时，优先使用unordered_set，因为它的查询增删效率最优。</p><p>如果需要集合是有序的 ，那么就用set。</p><p>如果不仅要求有序还要有重复数据的话，那么就用multiset.</p><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><p><a href="https://leetcode.cn/problems/valid-anagram/">力扣题目链接</a></p><p>利用s[i]-‘a’来确定字母在数组中的位置。</p><h3 id="1002-查找常用字符"><a href="#1002-查找常用字符" class="headerlink" title="1002.查找常用字符"></a>1002.查找常用字符</h3><p><a href="https://leetcode.cn/problems/find-common-characters/">力扣题目链接</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;string&gt; commonChars(vector&lt;string&gt;&amp; A)&#123;    vector&lt;string&gt; result;    if(A.size()&#x3D;&#x3D;0) return result;    int hash[26]&#x3D;&#123;0&#125;;    for(int i&#x3D;0;i&lt;A[0].size();i++)&#123;        hash[A[0][i]-&#39;a&#39;]++;    &#125;    int hashOtherStr[26]&#x3D;&#123;0&#125;;    for(int i&#x3D;1;i&lt;A.size(),i++)&#123;        memset(hashOtherStr,0,26*sizeof(int));        for(int j&#x3D;0;j&lt;A[i].size();j++)&#123;            hashOtherStr[A[i][j]-&#39;a&#39;]++;        &#125;        for(int k&#x3D;0;k&lt;26;k++)&#123;            hash[k]&#x3D;min(hash[k],hashOtherStr[k]);        &#125;    &#125;    for(int i&#x3D;0;i&lt;26;i++)&#123;        while(hash[i]!&#x3D;0)&#123;            string s(1,i+&#39;a&#39;);            result.push_back(s);            hash[i]--;        &#125;    &#125;    return result;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349.两个数组的交集"></a>349.两个数组的交集</h3><p>使用unordered_set</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1,vector&lt;int&gt;&amp; nums2)&#123;    unordered_set result;    unordered_set nums(nums1.begin(),nums1.end())        for(int num:nums2)&#123;            if(nums.find(num)!&#x3D;nums.end())            &#123;                result.insert(num);            &#125;        &#125;    return vector&lt;int&gt;(result.begin(),result.end());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202.快乐数"></a>202.快乐数</h3><p>当我们要快速判断一个元素是否出现在集合中时，可以考虑哈希法。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int getsum(int n)&#123;    int sum&#x3D;0;    while(n)&#123;        sum+&#x3D;(n%10)*(n%10);        n&#x2F;&#x3D;10;    &#125;&#125;bool ishappy(int n)&#123;    unordered_set&lt;int&gt; set;    while(1)&#123;        int sum &#x3D; getsum(n);        if(sum&#x3D;&#x3D;1) return true;        if(set.find(sum)!&#x3D;set.end())&#123;            return false;        &#125;else&#123;            set.insert(sum);        &#125;        n&#x3D;sum;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::unordered_map map;for(int i&#x3D;0;i&lt;nums.size(),i++)&#123;    auto iter&#x3D;map.find(target&#x3D;nums[i]);    if(iter!&#x3D;map.end())    &#123;        return &#123;iter-&gt;second,i&#125;;    &#125;    map.insert(pair&lt;int,int&gt;(nums[i],i));&#125;return &#123;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="454-四数相加Ⅱ"><a href="#454-四数相加Ⅱ" class="headerlink" title="454.四数相加Ⅱ"></a>454.四数相加Ⅱ</h3><p>首先定义一个unordered_map，key放ab两数之和，value放出现次数。</p><p>遍历AB两数组，统计两数组元素之和和出现的次数。</p><p>遍历CD数组，找到如果0-(c+d)在map中出现过的话，统计次数。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int foursumcount(vector&lt;int&gt;&amp;A ,vector&lt;int&gt;&amp;B, vector&lt;int&gt;&amp;C ,vector&lt;int&gt;&amp;D)&#123;    unordered_map&lt;int,int&gt; map;    for(int a:A)    &#123;        for(int b:B)        &#123;            map[a+b]++;        &#125;                &#125;    int count&#x3D;0;    for(int c:C)    &#123;        for(int d:D)        &#123;            if(map.find(0-(c+d))!&#x3D;map.end())            &#123;                count+&#x3D;map[0-(c+d)];            &#125;                    &#125;    &#125;    return count;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool canConstruct(string ransomNote, string magazine)&#123;    int record[26]&#x3D;&#123;0&#125;;    if(ransomNote.size()&gt;magazine.size())        return false;    for(int i&#x3D;0;i&lt;magazine.size();i++)    &#123;        record[magazine[i]-&#39;a&#39;]++;    &#125;    for(int j&#x3D;0;j&lt;ransomNote.size();j++)    &#123;        record[ransomNote[j]-&#39;a&#39;]--;        if(record[ransomNote[j]-&#39;a&#39;]&lt;0)            return false;    &#125;    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums)&#123;    vector&lt;vector&lt;int&gt;&gt; result;    sort(nums.begin(),nums.end());    for(int i&#x3D;0;i&lt;nums.size();i++)    &#123;        if(nums[i]&gt;0) break;        if(i&gt;0 &amp;&amp; nums[i]&#x3D;&#x3D;nums[i-1]) contunue;        unordered_set&lt;int&gt; set;        for(int j&#x3D;i+1;j&lt;nums.size();j++)&#123;            if(j&gt;i+2&amp;&amp;nums[j]&#x3D;&#x3D;nums[j-1]&amp;&amp;nums[j-1]&#x3D;&#x3D;nums[j-2])                contunue;            int c&#x3D;0-(nums[i]+nums[j]);            if(set.find(c)!&#x3D;set.end())&#123;                result.push_back(&#123;nums[i],nums[j],c&#125;);                set.erese(c);            &#125;else&#123;                set.insert(nums[j]);            &#125;        &#125;    &#125;    return result;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>双指针法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums)&#123;    vector&lt;vector&lt;int&gt;&gt; result;    sort(nums.begin(),nums.end());    for(int i&#x3D;0;i&lt;nums.size();i++)    &#123;        if(nums[i]&gt;0&amp;&amp;i&#x3D;0) return result;        if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1]) continue;            &#125;    int left&#x3D;i+1;    int right&#x3D;nums.size()-1;    while(right&gt;left)    &#123;        if(nums[i]+nums[left]+nums[right]&gt;0) right--;        else if(nums[i]+nums[left]+nums[right]&lt;0) left++;        else&#123;            result.push_back(vector&lt;int&gt;&#123;nums[i],nums[left],nums[right]&#125;);            whlie(right&gt;left &amp;&amp; nums[right]&#x3D;&#x3D;nums[right-1]) right--;            whlie(right&gt;left &amp;&amp; nums[left]&#x3D;&#x3D;nums[left++]) left++;                        right--;            left++;                    &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录—链表</title>
      <link href="/2023/02/11/suan-fa-shua-ti-ji-lu-lian-biao/"/>
      <url>/2023/02/11/suan-fa-shua-ti-ji-lu-lian-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">力扣题目链接</a></p><ul><li><p><strong>直接使用原来的链表进行删除操作</strong></p></li><li><p><strong>设置一个虚拟头节点在进行操作</strong></p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        ListNode* dummyHead &#x3D; new ListNode(0); &#x2F;&#x2F; 设置一个虚拟头结点        dummyHead-&gt;next &#x3D; head; &#x2F;&#x2F; 将虚拟头结点指向head，这样方面后面做删除操作        ListNode* cur &#x3D; dummyHead;        while (cur-&gt;next !&#x3D; NULL) &#123;            if(cur-&gt;next-&gt;val &#x3D;&#x3D; val) &#123;                ListNode* tmp &#x3D; cur-&gt;next;                cur-&gt;next &#x3D; cur-&gt;next-&gt;next;                delete tmp;            &#125; else &#123;                cur &#x3D; cur-&gt;next;            &#125;        &#125;        head &#x3D; dummyHead-&gt;next;        delete dummyHead;        return head;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><p><a href="https://leetcode.cn/problems/design-linked-list/">力扣题目链接</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;定义链表结构体struct LinkedNode&#123;    int val;    LinkedNode* next;    LinkedNode(int val):val(val),next(nullptr)&#123;&#125;    &#125;;MyLinkedList()&#123;    _dummyhead &#x3D; new LinkedNode(0);    _size&#x3D;0;&#125;int get(int index)&#123;    if(index &gt; (_size - 1)||index&lt;0)&#123;        return -1;    &#125;    LinkedNode* cur &#x3D; _dummyhead-&gt;next;    while(index--)&#123;        cur &#x3D; cur-&gt;next;    &#125;    return cur-&gt;val;&#125;void addAtHead(int val)&#123;    LinkedNode* newnode &#x3D; new LinkedNode(val);    newnode-&gt;next&#x3D;_dummyhead-&gt;next;    _dummyhead-&gt;next&#x3D;newnode;    _size++;&#125;void addAtTail(int val)&#123;    LinkedNode* newnode &#x3D; new LinkedNode(val);    LinkedNode* cur &#x3D; _dummyhead;    whlie(cur-&gt;next !&#x3D; nullptr)&#123;        cur &#x3D; cur-&gt;next;    &#125;    cur-&gt;next &#x3D; newnode;   _size++; &#125;void addAtIndex(int index, int val)&#123;    if(index &gt; _size) return;    if(index &lt; 0) index&#x3D;0;    LinkedNode* newnode &#x3D; new LinkedNode(val);    LinkedNode* cur &#x3D; _dummyhead;    whlie(index--)&#123;        cur&#x3D;cur-&gt;next;    &#125;    newnode-&gt;next &#x3D; cur-&gt;next;    cur-&gt;next &#x3D; newnode;    _size++;    &#125;void deleteAtIndex(int index)&#123;    if(index &gt;&#x3D; _size || index &lt; 0)&#123;        return;    &#125;    LinkedNode* cur &#x3D; _dunnyhead;    while(index--)&#123;        cur&#x3D;cur-&gt;next;    &#125;    LinkedNode* tmp &#x3D; cur-&gt;next;    cur-&gt;next &#x3D; cur-&gt;next-&gt;next;    delete tmp;    _size--;&#125;private: int _size; LinkedNode* _dummyhead;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/">力扣题目链接</a></p><p><strong>双指针法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">LinkNode* reverseList(ListNode* head)&#123;    ListNode* temp;    ListNode* cur &#x3D; head;    ListNode* pre &#x3D; nullptr;    while(cur)&#123;        temp &#x3D; cur-&gt;next;        pre &#x3D; cur;        cur &#x3D; temp;    &#125;    return pre;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>递归法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode* reverse(ListNOde* pre, ListNode* cur)&#123;    if(cur&#x3D;&#x3D;nullptr) return pre    ListNode* temp &#x3D; cur-&gt;next;    cur-&gt;next &#x3D; pre;    return reverse(cur, temp);&#125;ListNode* reverseList(ListNode* head)&#123;    return reverse(nullptr,head);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="19-删除链表倒数第n个结点"><a href="#19-删除链表倒数第n个结点" class="headerlink" title="19.删除链表倒数第n个结点"></a>19.删除链表倒数第n个结点</h3><p><strong>双指针法</strong></p><p>添加虚拟头节点</p><p>fast指针向后移动n+1步</p><p>fast和slow同时移动至fast指针指向末尾</p><p>删除slow后面的节点</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode* dummyhead&#x3D;new ListNode(0);dummyhead-&gt;next&#x3D;head;ListNode* fast&#x3D;dummyhead;ListNode* slow&#x3D;dummyhead;while(n-- &amp;&amp; fast!&#x3D;nullptr)&#123;    fast&#x3D;fast-&gt;next;&#125;fast-fast-&gt;next;while(fast!&#x3D;nullptr)&#123;    fast&#x3D;fast-&gt;next;    slow&#x3D;slow-&gt;next;&#125;slow-&gt;next&#x3D;slow-&gt;next-&gt;next;return dummyhead-&gt;next;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h3><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">力扣题目链接</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode* dummyhead&#x3D;new ListNode(0);dummyhead-&gt;next&#x3D;head;ListNode* cur&#x3D;dummyhead;while(cur-&gt;next !&#x3D; nullptr &amp;&amp; cur-&gt;next-&gt;next !&#x3D; nuulptr)&#123;    ListNode* temp1&#x3D;cur-&gt;next;  ListNode* temp2&#x3D;cur-&gt;next-&gt;next-&gt;next;    cur-&gt;next&#x3D;cur-&gt;next-&gt;next;    cur-&gt;next-&gt;next&#x3D;temp1;    cur-&gt;next-&gt;next-&gt;next&#x3D;temp2;    &#125;return dummyhead-&gt;next;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="160-链表相交"><a href="#160-链表相交" class="headerlink" title="160.链表相交"></a>160.链表相交</h3><p>计算两链表的长度</p><p>求出长度差值</p><p>让指针移动到末尾对其的位置</p><p>比较两指针是否相同，不相同则后移</p><p>直至两指针相等</p><h3 id="142-环形链表"><a href="#142-环形链表" class="headerlink" title="142.环形链表"></a>142.环形链表</h3><p><strong>双指针法</strong></p><p>fast走两个节点，slow走一个节点</p><p><strong>fast指针先进入环中，fast与slow一定在换环中相遇。</strong></p><p><strong>相对于slow来说，fast是一步步靠近slow的</strong></p><h4 id="如何找到环的入口"><a href="#如何找到环的入口" class="headerlink" title="如何找到环的入口"></a>如何找到环的入口</h4><p>从头节点出发一个指针，从相遇节点也出发一个指针，每次均走一个节点，两个指针相遇时就是环形入口的节点。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode* fast&#x3D;head;ListNode* slow&#x3D;head;while(fast!&#x3D;nullptr&amp;&amp;fast-&gt;next!&#x3D;nullptr)&#123;    slow&#x3D;slow-&gt;next;    fast&#x3D;fast-&gt;next-&gt;next;    if(slow&#x3D;&#x3D;fast)    &#123;        ListNode* index1&#x3D;fast;        ListNode* index2&#x3D;head;        while(index1!&#x3D;index2)        &#123;            index1&#x3D;index1-&gt;next;            index2&#x3D;index2-&gt;next;        &#125;        return index2;    &#125;&#125;return NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题基础—数组</title>
      <link href="/2023/02/10/suan-fa-shua-ti-ji-lu-shu-zu/"/>
      <url>/2023/02/10/suan-fa-shua-ti-ji-lu-shu-zu/</url>
      
        <content type="html"><![CDATA[<h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h3><p><a href="https://leetcode.cn/problems/binary-search/">力扣题目链接</a></p><p>二分法的两种写法：</p><ul><li><p>定义target在左闭右闭的区间里</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int low &#x3D; 0;        int high &#x3D; nums.size() - 1;         while (low &lt;&#x3D; high)         &#123;             int middle &#x3D; low + ((high - low) &#x2F; 2);&#x2F;&#x2F; 防止溢出             if (nums[middle] &gt; target) &#123;                high &#x3D; middle - 1;            &#125; else if (nums[middle] &lt; target) &#123;                left &#x3D; middle + 1;             &#125; else            &#123;                return middle;             &#125;        &#125;                return -1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>定义target在一个左闭右开的区间里</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int low &#x3D; 0;        int high &#x3D; nums.size();         while (low &lt; high) &#123;             int middle &#x3D; low + ((high - low) &gt;&gt; 1);            if (nums[middle] &gt; target) &#123;                high &#x3D; middle;             &#125; else if (nums[middle] &lt; target) &#123;                low &#x3D; middle + 1;             &#125; else &#123;                 return middle;             &#125;        &#125;              return -1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="74-移除元素"><a href="#74-移除元素" class="headerlink" title="74.移除元素"></a>74.移除元素</h3><p><a href="https://leetcode.cn/problems/remove-element/">力扣题目链接</a></p><ul><li><p>暴力求解</p></li><li><p>双指针法：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作</p><p>快指针：寻找新数组的元素，新数组就是不含有目标元素的数组。</p><p>慢指针：指向更新新数组下标的位置。</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><p><strong>双指针法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int slowIndex &#x3D; 0;        for (int fastIndex &#x3D; 0; fastIndex &lt; nums.size(); fastIndex++) &#123;            if (val !&#x3D; nums[fastIndex]) &#123;                nums[slowIndex++] &#x3D; nums[fastIndex];            &#125;        &#125;        return slowIndex;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>相向双指针法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int leftIndex &#x3D; 0;        int rightIndex &#x3D; nums.size() - 1;        while (leftIndex &lt;&#x3D; rightIndex) &#123;            &#x2F;&#x2F; 找左边等于val的元素            while (leftIndex &lt;&#x3D; rightIndex &amp;&amp; nums[leftIndex] !&#x3D; val)&#123;                ++leftIndex;            &#125;            &#x2F;&#x2F; 找右边不等于val的元素            while (leftIndex &lt;&#x3D; rightIndex &amp;&amp; nums[rightIndex] &#x3D;&#x3D; val) &#123;                -- rightIndex;            &#125;            &#x2F;&#x2F; 将右边不等于val的元素覆盖左边等于val的元素            if (leftIndex &lt; rightIndex) &#123;                nums[leftIndex++] &#x3D; nums[rightIndex--];            &#125;        &#125;        return leftIndex;   &#x2F;&#x2F; leftIndex一定指向了最终数组末尾的下一个元素    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">力扣题目链接</a></p><p><strong>双指针法</strong></p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p><p>2</p><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">力扣题目链接</a></p><p><strong>滑动窗口</strong></p><p>不断的调节子序列的起始位置和终止位置，从而得出结果。</p><h3 id="59-螺旋矩阵"><a href="#59-螺旋矩阵" class="headerlink" title="59.螺旋矩阵"></a>59.螺旋矩阵</h3><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">力扣题目链接</a></p><p><strong>四条边要坚持左闭右开或者左开右闭的原则</strong></p><p>完整代码如下</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;        vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0)); &#x2F;&#x2F; 使用vector定义一个二维数组        int startx &#x3D; 0, starty &#x3D; 0; &#x2F;&#x2F; 定义每循环一个圈的起始位置        int loop &#x3D; n &#x2F; 2; &#x2F;&#x2F; 每个圈循环几次，例如n为奇数3，那么loop &#x3D; 1 只是循环一圈，矩阵中间的值需要单独处理        int mid &#x3D; n &#x2F; 2; &#x2F;&#x2F; 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)        int count &#x3D; 1; &#x2F;&#x2F; 用来给矩阵中每一个空格赋值        int offset &#x3D; 1; &#x2F;&#x2F; 需要控制每一条边遍历的长度，每次循环右边界收缩一位        int i,j;        while (loop --) &#123;            i &#x3D; startx;            j &#x3D; starty;            &#x2F;&#x2F; 下面开始的四个for就是模拟转了一圈            &#x2F;&#x2F; 模拟填充上行从左到右(左闭右开)            for (j &#x3D; starty; j &lt; n - offset; j++) &#123;                res[startx][j] &#x3D; count++;            &#125;            &#x2F;&#x2F; 模拟填充右列从上到下(左闭右开)            for (i &#x3D; startx; i &lt; n - offset; i++) &#123;                res[i][j] &#x3D; count++;            &#125;            &#x2F;&#x2F; 模拟填充下行从右到左(左闭右开)            for (; j &gt; starty; j--) &#123;                res[i][j] &#x3D; count++;            &#125;            &#x2F;&#x2F; 模拟填充左列从下到上(左闭右开)            for (; i &gt; startx; i--) &#123;                res[i][j] &#x3D; count++;            &#125;            &#x2F;&#x2F; 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)            startx++;            starty++;            &#x2F;&#x2F; offset 控制每一圈里每一条边遍历的长度            offset +&#x3D; 1;        &#125;        &#x2F;&#x2F; 如果n为奇数的话，需要单独给矩阵最中间的位置赋值        if (n % 2) &#123;            res[mid][mid] &#x3D; count;        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP学习记录(1)</title>
      <link href="/2023/02/05/csapp-xue-xi-ji-lu/"/>
      <url>/2023/02/05/csapp-xue-xi-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="CSAPP——第二章"><a href="#CSAPP——第二章" class="headerlink" title="CSAPP——第二章"></a>CSAPP——第二章</h1><h2 id="2-2整数表示"><a href="#2-2整数表示" class="headerlink" title="2.2整数表示"></a>2.2整数表示</h2><h3 id="2-2-2无符号数的编码"><a href="#2-2-2无符号数的编码" class="headerlink" title="2.2.2无符号数的编码"></a>2.2.2无符号数的编码</h3><p>无符号数编码的定义</p><p>对向量$ \vec{x} $:<br>$$<br>B2U_{w}(\vec{x})&#x3D;\sum_{i&#x3D;0}^{w-1} x_{i}2^{i} \text(Binary to Unsigned)<br>$$<br>函数$ B2U_w $将一个长度为w的0、1串映射到非负整数。</p><p>函数$  B2U_w $是一个双射。</p><h3 id="2-2-3补码编码"><a href="#2-2-3补码编码" class="headerlink" title="2.2.3补码编码"></a>2.2.3补码编码</h3><p>最常见的有符号数的计算机表示方式就是__补码__。在这个定义中，将字的最高有效为解释为负权。用函数$ B2T_w $表示。</p><p>补码编码的定义</p><p>对向量$ \vec{x} $:<br>$$<br>B2T_w(\vec{x})&#x3D;-x_{w-1}+\sum_{i&#x3D;0}^{w-2} x_i2^i \text(BinarytoTwo’s-complement)<br>$$<br>最高有效位成为符号位，权重为$ -2_{w-1} $。</p><p>符号位被设置为1，表示值为负；设置为0，值为正。</p><p>最小整数值是<br>$$<br>TMin_w&#x3D;-2^{w-1}<br>$$<br>最大整数值是<br>$$<br>TMax_w&#x3D;2^{w-1}-1<br>$$<br>补码的范围是不对称的<br>$$<br>|TMin|&#x3D;|TMax|+1<br>$$<br>也就是说，TMin没有与之对应的正数。</p><p>最大的无符号数值刚好比补码的最大值的两倍大一点<br>$$<br>UMax_w&#x3D;2TMax_w+1<br>$$<br>-1是一个全1的串，0是一个全0的串。</p><p>C库中的文件&lt;limit.h&gt;定义了常量INT_MAX,INT_MIN,UINT_MAX。对于一个补码的机器，这些常量就对应TMax,TMin,UMax的值。</p><blockquote><p>有符号数的其他表示方法</p><p>反码<br>$$<br>B2O_w(\vec{x})&#x3D;-x_{w-1}(2_{w-1}-1)+\sum_{i&#x3D;0}^{w-2}x_{i}2^i<br>$$<br>原码<br>$$<br>B2S_w(\vec{x})&#x3D;(-1)^{x_{w-1}}*(\sum_{i&#x3D;0}^{w-2}x_i2^i)<br>$$</p></blockquote><h3 id="2-2-4有符号数与无符号数的转换"><a href="#2-2-4有符号数与无符号数的转换" class="headerlink" title="2.2.4有符号数与无符号数的转换"></a>2.2.4有符号数与无符号数的转换</h3><p>强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。</p><p>对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。</p><p>补码转换为无符号数</p><p>对满足TMin&lt;&#x3D;x&lt;&#x3D;TMax的x有<br>$$<br>T2U_w(x)&#x3D;x+2^w,x&lt;0<br>$$</p><p>$$<br>T2U_w(x)&#x3D;x,x&gt;&#x3D;0<br>$$</p><p>当一个有符号数映射为它相应的无符号数时，负数就被转换成了大的正数，而非负数会保持不变。</p><p>无符号数转换为补码</p><p>对满足0&lt;&#x3D;u&lt;&#x3D;UMax的u有<br>$$<br>U2T_w(u)&#x3D;u,u&lt;&#x3D;TMax_w<br>$$</p><p>$$<br>U2T_w(u)&#x3D;u-2^w,u&gt;TMax_w<br>$$</p><p>对于小的数(&lt;&#x3D;TMax),从无符号数到有符号数的转换将保留数字的原值。</p><p>对于大的数( &gt;TMax),数字将被转换为一个负数值。</p><p><strong>考虑无符号与补码表示之间相互转换的结果</strong></p><p>对于在范围0&lt;&#x3D;x&lt;&#x3D;TMax之内的值x而言，我们得到T2U(x)&#x3D;x和U2T(x)&#x3D;x。也就是说，在这个范围内的数字有相同的无符号和补码表示。</p><p>对于这个范围以外的数字，转换需要加上或者减去$ 2_w $</p><h3 id="2-2-5C语言中的有符号数与无符号数"><a href="#2-2-5C语言中的有符号数与无符号数" class="headerlink" title="2.2.5C语言中的有符号数与无符号数"></a>2.2.5C语言中的有符号数与无符号数</h3><p>当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。</p><p>这种方法对于标准的算数运算来说并无多大差异，但是对于&lt;&gt;这样的关系运算符来说，它会导致非直观的结果。</p><h3 id="2-2-6扩展一个数字的位表示"><a href="#2-2-6扩展一个数字的位表示" class="headerlink" title="2.2.6扩展一个数字的位表示"></a>2.2.6扩展一个数字的位表示</h3><p>要将一个无符号数转换为一个更大的数据类型，只要简单的在表示的开头添加0，这种运算被称为零扩展。</p><p>要将补码数字转换为一个更大的数据类型，可以执行一个符号扩展（将符号位填补前面空余位）。</p><p>数据类型转换时，要先转换大小，再完成符号的转换。</p><h3 id="2-2-7截断数字"><a href="#2-2-7截断数字" class="headerlink" title="2.2.7截断数字"></a>2.2.7截断数字</h3><p>截断无符号数<br>$$<br>x^<code>=xmod2^k $$ 截断补码数值 $$ x^</code>&#x3D;U2T_k(xmod2^k)<br>$$</p><h3 id="2-2-8关于有符号数与无符号数的建议"><a href="#2-2-8关于有符号数与无符号数的建议" class="headerlink" title="2.2.8关于有符号数与无符号数的建议"></a>2.2.8关于有符号数与无符号数的建议</h3><h2 id="2-3整数运算"><a href="#2-3整数运算" class="headerlink" title="2.3整数运算"></a>2.3整数运算</h2><h3 id="2-3-1无符号加法"><a href="#2-3-1无符号加法" class="headerlink" title="2.3.1无符号加法"></a>2.3.1无符号加法</h3><p><strong>无符号加法</strong></p><p>对满足$ 0&lt;&#x3D;x,y&lt;2_w $的x和y有：<br>$$<br>x+y&#x3D;x+y,  x+y&lt;2^w<br>$$</p><p>$$<br>x+y&#x3D;x+y-2^w,2^w&lt;&#x3D;x+y&lt;&#x3D;2^{w+1}<br>$$</p><p><strong>检测无符号数加法中的溢出</strong></p><p>对在范围0&lt;&#x3D;x,y&lt;&#x3D;UMax,中的x和y，令s&#x3D;x+y。当且仅当s&lt;x(或者等价的s&lt;y)时发生了溢出。   </p><h3 id="2-3-2补码加法"><a href="#2-3-2补码加法" class="headerlink" title="2.3.2补码加法"></a>2.3.2补码加法</h3><p>当和x+y超过TMax时，我们说发生了正溢出，截断的结果是从和数中减去$ 2_w $；当和x+y小于TMin时，我们说发生了负溢出，截断的结果是把和数加上$ 2_w $。</p><p><strong>检测补码加法中的溢出</strong></p><p>对满足TMin&lt;&#x3D;x,y&lt;&#x3D;TMax的x和y，令s&#x3D;x+y，当且仅当x&gt;0,y&gt;0,但s&lt;&#x3D;0时，计算s发生了正溢出。当且仅当x&lt;0,y&lt;0,但s&gt;&#x3D;0时，计算s发生了负溢出。</p><h3 id="2-3-3补码的非"><a href="#2-3-3补码的非" class="headerlink" title="2.3.3补码的非"></a>2.3.3补码的非</h3><p>对w位的补码加法来说，TMin是自己的加法的逆。而对其他任何数值x都有-x作为其加法的逆。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>美赛绘图介绍</title>
      <link href="/2023/02/05/mei-sai-hui-tu-jie-shao/"/>
      <url>/2023/02/05/mei-sai-hui-tu-jie-shao/</url>
      
        <content type="html"><![CDATA[<h1 id="美赛绘图介绍"><a href="#美赛绘图介绍" class="headerlink" title="美赛绘图介绍"></a>美赛绘图介绍</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h3><p><a href="https://mycolor.space/">colorspace</a></p><h3 id="图片素材"><a href="#图片素材" class="headerlink" title="图片素材"></a>图片素材</h3><p><a href="https://www.freepik.com/">freepic</a></p><h3 id="python画图"><a href="#python画图" class="headerlink" title="python画图"></a>python画图</h3><p><a href="https://zhuanlan.zhihu.com/p/81553421?utm_source=wechat_session">seaborn库</a></p><h3 id="绘图网站"><a href="#绘图网站" class="headerlink" title="绘图网站"></a>绘图网站</h3><p><a href="https://www.bioladder.cn/web/#/pro/index">bioladder</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/02/03/hello-world/"/>
      <url>/2023/02/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
