<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法刷题记录—二叉树</title>
      <link href="/2023/04/17/suan-fa-shua-ti-ji-lu-er-cha-shu/"/>
      <url>/2023/04/17/suan-fa-shua-ti-ji-lu-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="二叉树理论基础"><a href="#二叉树理论基础" class="headerlink" title="二叉树理论基础"></a>二叉树理论基础</h3><h4 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h4><p>满二叉树：深度为k，有2^k-1个节点</p><p>完全二叉树：除最底层节点可能没填满外，其余每层节点数都达到最大值</p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>二叉搜索树是一个有序树</p><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值</p><p>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</p><p>它的左右子树也分别为二叉排序树</p><h4 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h4><p>AVL树</p><p>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</p><p>c++中map、set、multimap、multiset的底层实现都是平衡二叉搜索树</p><h4 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h4><p>二叉树既可以链式存储，也可以顺序存储</p><p>链式存储方式就用指针，顺序存储的方式就是用数组</p><p>遍历数组存储的二叉树：左孩子是i * 2+1，右孩子是i * 2+2</p><h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h4><p>1.深度优先遍历</p><p>前序遍历（递归法，迭代法）</p><p>中序遍历（递归法，迭代法）</p><p>后序遍历（递归法，迭代法）</p><p>2.广度优先遍历</p><p>层次遍历（迭代法）</p><h4 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h4><p>链式存储</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct TreeNode&#123;    int val;    TreeNode *left;    TreeNode *right;    TreeNode(int x) : val(x),left(NULL),right(NULL)&#123;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字节前端初阶训练营—shell脚本和编程</title>
      <link href="/2023/04/17/zi-jie-qian-duan-chu-jie-xun-lian-ying-shell-jiao-ben-he-bian-cheng/"/>
      <url>/2023/04/17/zi-jie-qian-duan-chu-jie-xun-lian-ying-shell-jiao-ben-he-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="01-课程介绍"><a href="#01-课程介绍" class="headerlink" title="01.课程介绍"></a>01.课程介绍</h1><p>学习shell的价值：</p><p>1.linux服务器的基本操作和管理</p><p>2.前端Node.js服务的进程管理、问题排查、资源监控等运维操作</p><p>3.使用shell编写TCE、SCM、Docker脚本完成服务编译和部署</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字节前端初阶训练营—Linux基础</title>
      <link href="/2023/04/14/zi-jie-qian-duan-chu-jie-xun-lian-ying-linux-ji-chu/"/>
      <url>/2023/04/14/zi-jie-qian-duan-chu-jie-xun-lian-ying-linux-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="01-计算机硬件"><a href="#01-计算机硬件" class="headerlink" title="01.计算机硬件"></a>01.计算机硬件</h1><p>计算机由五大基本单元组成</p><ul><li><p>控制器</p></li><li><p>运算器</p></li><li><p>存储器单元</p></li><li><p>输入单元</p></li><li><p>输出单元</p></li></ul><h1 id="02-操作系统"><a href="#02-操作系统" class="headerlink" title="02.操作系统"></a>02.操作系统</h1><p><strong>操作系统（Operating System，OS）</strong></p><p>管理和控制计算机系统中的硬件和软件资源，用于在用户与系统硬件之间传递信息</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20160350.png"></p><p>目前主流的操作系统有MacOS、Linux、Windows、安卓、HarmonyOS</p><p><strong>操作系统启动流程</strong></p><p>操作系统启动共有两种模式</p><ol><li>基于BIOS引导操作系统启动的传动模式</li><li>基于UEFI引导操作系统启动的主流模式</li></ol><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20160807.png"></p><p>BIOS和UEFI是固化在主板上的一段程序，当计算机开机时能够自动运行这段程序</p><p>当这段程序被启动以后，首先进行初始化等一系列的动作，找到并运行Bootloader（操作系统引导程序），通过Bootloader运行OS</p><p>UEFI优化了BIOS的自检流程，提高了启动速度</p><blockquote><p>BIOS（英文：Basic Input&#x2F;Output System），即基本输入输出系统，亦称为ROM BIOS、System BIOS、PC BIOS，是在通电启动阶段执行硬件初始化，以及为操作系统提供运行时服务的固件。BIOS最早随着CP&#x2F;M操作系统的推出在1975年出现。BIOS预安装在个人电脑的主板上，是个人电脑启动时加载的第一个软件。许多BIOS程序都只能在特定电脑型号或特定主板型号上执行。早年，BIOS存储于ROM芯片上；现在的BIOS多存储于闪存芯片上，这方便了BIOS的更新。</p><p>统一可扩展固件接口（英语：Unified Extensible Firmware Interface，缩写UEFI）是一种个人电脑系统规格，用来定义操作系统与系统固件之间的软件界面，作为BIOS的替代方案。可扩展固件接口负责加电自检（POST）、联系操作系统以及提供连接操作系统与硬件的接口。</p></blockquote><h1 id="03-Linux系统概览"><a href="#03-Linux系统概览" class="headerlink" title="03.Linux系统概览"></a>03.Linux系统概览</h1><p><strong>Linux发展简史</strong></p><p>1969年，Unix诞生于贝尔实验室</p><p>1984年，贝尔实验室将Unix商业化</p><p>1984年，Tanenbaum开发Mnix操作系统用于教学开发并开放源码</p><p>1984年，Richard M.Stallman发起自由软件（FSF）与GNU项目，起草GPL（通用公共许可）协议</p><p>1991年，Linus Torvalds受Mnix影响实现初版的Linux内核</p><p>1992年，Linux内核以GPL协议发行V1.0</p><p><strong>Linux版本</strong></p><ul><li>内核版本</li><li>发行版本</li></ul><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20162018.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20162130.png"></p><p><strong>查看Linux系统内核版本</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">uname</span> <span class="token parameter variable">-a</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /proc/version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /etc/os-release<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>Linux应用领域</strong></p><ul><li>IT服务器（操作系统、虚拟化和云计算）</li><li>嵌入式和智能设备</li><li>个人办公桌面</li><li>学术研究和软件开发</li></ul><p><strong>Linux基本组成</strong></p><ul><li>内核</li><li>shell（命令解释器）</li><li>文件系统</li><li>应用程序</li></ul><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20162725.png"></p><p><strong>Linux体系结构</strong></p><p>Linux系统分为用户空间和内核空间</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20162837.png"></p><ul><li>内核是硬件与软件之间的中间层</li><li>内核是一个资源管理程序</li><li>内核提供一组面向系统的命令</li></ul><h1 id="03-Linux系统结构——进程管理"><a href="#03-Linux系统结构——进程管理" class="headerlink" title="03.Linux系统结构——进程管理"></a>03.Linux系统结构——进程管理</h1><p><strong>进程管理</strong></p><ul><li>进程是正在执行的一个程序或命令</li><li>进程有自己的地址空间</li><li>一个CPU核同一时间只能运行一个进程</li><li>进程由它的进程ID（PID）和它父进程的进程ID（PPID）唯一识别</li></ul><p><strong>查看进程信息</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#查看启动的nginx进程</span><span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#查看某个进程</span><span class="token function">top</span> <span class="token parameter variable">-p</span> <span class="token number">93824</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#关闭指定的进程</span><span class="token function">kill</span> <span class="token number">93824</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#全部进程动态实时视图</span><span class="token function">top</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>进程调度</strong></p><p>进程调度是指操作系统按某种策略或规则选择进程占用CPU进行运行的过程</p><ul><li>R：可执行状态</li><li>S：可中断的睡眠状态</li><li>D：不可中断的睡眠状态</li><li>T：暂停状态或跟踪状态</li><li>Z：退出状态，进程成为僵尸进程</li><li>X：退出状态，进程即将被销毁</li></ul><p><strong>进程调度的原则</strong></p><ul><li>一个CPU核同一时间只能运行一个进程</li><li>每个进程有近乎相等的执行时间</li><li>对于逻辑CPU而言进程调度使用轮询的方式进行，当轮询完成则回到第一个进程反复</li><li>进程执行消耗时间和进程量成正比</li></ul><p><strong>进程的系统调用</strong></p><p>内核空间：系统内核运行的控件</p><p>用户空间：应用程序运行的空间</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20201132.png"></p><p>当任务切换到内核态，应用程序便有权限和底层的硬件平台进行交互</p><h1 id="04-Linux系统结构——文件系统"><a href="#04-Linux系统结构——文件系统" class="headerlink" title="04.Linux系统结构——文件系统"></a>04.Linux系统结构——文件系统</h1><p><strong>文件系统</strong></p><p>文件系统是操作系统中负责管理持久数据的子系统，负责把用户的文件存到磁盘赢家那中，持久化的保存文件</p><p>Linux中，文件可以是普通文件、目录、设备、套接字</p><p>Linux中一切皆文件</p><p>Linux文件系统是采用树状的目录结构</p><p>最上层的是&#x2F;（根）目录</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20201758.png"></p><p><strong>虚拟文件系统（VFS）</strong></p><p>对应用层提供一个标准的文件<strong>操作接口</strong></p><p>对文件系统提供一个标准的文件<strong>接入接口</strong></p><p>VFS抹平不同文件之间的差异</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20202041.png"></p><p><strong>查看文件系统类型</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#df命令报告文件系统磁盘空间利用率</span><span class="token function">df</span> <span class="token parameter variable">-T</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># mount命令是挂载文件系统用的，不带任何参数运行，会打印包含文件系统类型在内的磁盘分区的信息</span><span class="token function">mount</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>文件基本操作</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> <span class="token comment">#查看文件夹下的内容</span><span class="token function">mkdir</span> demo <span class="token comment">#创建文件夹</span><span class="token function">mv</span> demo /home <span class="token comment">#移动demo文件夹到 /home</span><span class="token function">rm</span> <span class="token parameter variable">-r</span> demo <span class="token comment">#删除demo文件夹</span><span class="token function">touch</span> file.txt <span class="token comment">#创建空文件</span><span class="token function">cp</span> file.txt file_bak.txt <span class="token comment">#复制文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>文件读取流程</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20202622.png"></p><h1 id="05-Linux系统结构——用户权限"><a href="#05-Linux系统结构——用户权限" class="headerlink" title="05.Linux系统结构——用户权限"></a>05.Linux系统结构——用户权限</h1><p><strong>用户账户</strong></p><ul><li>用户账户</li></ul><p>普通用户账户：在系统中进行普通作业</p><p>超级用户账户：在系统中对普通用户和整个系统进行管理</p><ul><li>组账户</li></ul><p>标准组：可以容纳多个用户</p><p>私有组：只有用户自己</p><p><strong>查看用户信息</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#查看当前登录用户信息</span>w<span class="token comment">#查看当前用户所属的组</span><span class="token function">groups</span><span class="token comment">#查看用户的uid信息</span><span class="token function">id</span> *** <span class="token comment">#用户名</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>文件权限</strong></p><p>所有者：文件的所有者</p><p>所在组：文件的所有者所在的组</p><p>其他人：除文件所有者及所在组外的其他人</p><p>每个用户对于文件都有不同的权限，包括读（R）、写（W）、执行（X）</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20203530.png"></p><p><strong>用户权限操作</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20203705.png"></p><h1 id="06-Linux软件包"><a href="#06-Linux软件包" class="headerlink" title="06.Linux软件包"></a>06.Linux软件包</h1><ul><li>软件包</li></ul><p>通常是一个应用程序，可以是一个GUI应用程序、命令行工具或（其他软件程序需要的）软件库</p><ul><li>软件包管理</li></ul><p>底层工具：主要用来处理安装和删除软件包文件等任务，DPKG，RPM</p><p>上层工具：主要用于数据的搜索任务和依赖解析任务，APT，YUM，DNF</p><p><strong>软件包管理工具</strong></p><p>RPM（Red Hat Package Manager），为Red hat操作系统的包管理系统</p><p>DPKG（Debian Package），为Debian操作系统的包管理系统</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20204327.png"></p><p><strong>Debian APT常用命令</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20204512.png"></p><p><strong>Debian配置软件源</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20204630.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字节前端初阶训练营—计算机网络概论</title>
      <link href="/2023/04/13/zi-jie-qian-duan-chu-jie-xun-lian-ying-ji-suan-ji-wang-luo-gai-lun/"/>
      <url>/2023/04/13/zi-jie-qian-duan-chu-jie-xun-lian-ying-ji-suan-ji-wang-luo-gai-lun/</url>
      
        <content type="html"><![CDATA[<h1 id="01-简介"><a href="#01-简介" class="headerlink" title="01.简介"></a>01.简介</h1><h3 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h3><p><strong>自底向上</strong></p><p>由简单到复杂</p><p>由局部到整体</p><p><strong>自顶向下</strong></p><p>由复杂到简单</p><p>将复杂的系统问题模块化处理</p><h1 id="02-通过蟹堡王案例来理解计算机网络系统"><a href="#02-通过蟹堡王案例来理解计算机网络系统" class="headerlink" title="02.通过蟹堡王案例来理解计算机网络系统"></a>02.通过蟹堡王案例来理解计算机网络系统</h1><p>蟹老板要管理遍布全国的蟹堡王分店需要很多基础设施，其中比较重要的一项为通信。</p><p>为了开通外卖服务，扩大服务范围，蟹堡王需要建立专属于蟹堡王的通信网络。</p><p>蟹堡王的服务模式与现实中的计算机网络系统有许多相近之处</p><ul><li><p>比奇堡外卖</p></li><li><p>北京和上海分店</p></li><li><p>全国分店和通信网络</p></li><li><p><strong>蟹堡王顾客：客户端</strong></p></li><li><p><strong>蟹堡王分店：服务端</strong></p></li><li><p><strong>小区转发点和蟹堡王城市转发分店：路由器</strong></p></li><li><p><strong>转发表格网络协议</strong></p></li></ul><h1 id="03-计算机网络基础"><a href="#03-计算机网络基础" class="headerlink" title="03.计算机网络基础"></a>03.计算机网络基础</h1><p><strong>网络组成部分</strong></p><ul><li><p>主机：客户端和服务端</p></li><li><p>路由器</p></li><li><p>网络协议</p></li></ul><p><strong>网络结构：网络的网络</strong></p><ul><li><p>比奇堡和小区网络：本地网络</p></li><li><p>北京和上海分店+比奇堡：三个本地网络节点的网络</p></li><li><p>全国通信网络：本地网络的网络</p></li></ul><p>以上三种网络可以称为区域网络，城域网，广域网</p><blockquote><p>区域网络（Local area network，简称LAN）是连接住宅、学校、实验室、大学校园或办公大楼等有限区域内计算机的计算机网络。</p><p>城域网又称都会网络，指大型的计算机网络，是介于LAN和WAN之间能传输语音与资料的公用网络，这些网络通常涵盖一个大学校园或一座城市。 一些常用于城市区网的技术包含：异步传输模式（ATM）、光纤分布数据接口（FDDI）、千兆乙太网。</p><p>广域网（英语：Wide Area Network，缩写为WAN），又称外网、公网。 是连接不同地区局域网或城域网计算机通信的远程网。 通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个地区、城市和国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。 广域网并不等同于互联网。</p></blockquote><p><strong>信息交换的方式一般有两种：电路交换&amp;分组交换</strong></p><blockquote><p>电路交换（Circuit Switching）是相对于封包交换（或称分组交换）的一个概念。 电路交换要求必须首先在通信双方之间建立连接通道。 在连接建立成功之后，双方的通信活动才能开始。 通信双方需要传递的信息都是通过已经建立好的连接来进行传递的，而且这个连接也将一直被维持到双方的通信结束。</p><p>分组交换（Packet switching）是一种相对于电路交换的通信范例，分组（又称消息、或消息碎片）在节点间单独路由，不需要在传输前先建立通信路径。 分组交换是数据通信中一种新的且重要的概念，现在是世界上互联网通讯、数据和语音通信中最重要的基础。</p></blockquote><p><strong>网络分层</strong></p><p>计算机网络分为五层</p><p>从低到高为</p><p>物理层 链路层 网络层 运输层 应用层</p><p>每一层都有各自的职责，并对自身层级的内容进行分装，这些内容对于上一层几乎是黑盒的</p><p>类比于现实中的例子</p><ul><li><p>快递员不关心包裹内容</p></li><li><p>卡车司机不关心车厢里拉的是什么</p></li><li><p>高速公路不关心开的什么车</p></li></ul><p><strong>协议</strong></p><p>协议的存在依赖于连接</p><p>协议定义了在两个或多个通信实体之间交换的<strong>报文格式和顺序</strong>，以及报文发送和&#x2F;或接受一条报文或其他事件所采取的动作</p><p><strong>标头(header)和载荷(payload)</strong></p><blockquote><p>HTTP 标头（header）允许客户端和服务器通过 HTTP 请求（request）或者响应（response）传递附加信息。一个 HTTP 标头由它的名称（不区分大小写）后跟随一个冒号（:），冒号后跟随它具体的值。该值之前的空格 (en-US)会被忽略。  </p></blockquote><p><strong>报文的组成：链路层头部+IP协议头部+TCP头部+HTTP头部+HTTP正文</strong></p><p><strong>http协议</strong></p><p>在http&#x2F;1.1中，头部和载荷通过两个换行符和两个回车符进行分割(\r\n\r\n)</p><p><strong>TCP协议</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20214828.png"></p><p>TCP协议中，最前面的2个字节是源端口号，往后的2个字节是目标端口号</p><p>接下来的8个字节分别是序列号（4字节）、ACK号（4字节）</p><p>TCP中头部和载荷的分割依靠图中Data offset部分（13~14字节）</p><p>在HTTP协议中，需要对ASCII码进行解析，得到二进制数据，发现有连续的换行符和回车符即为头部与载荷的分割</p><p><strong>小结</strong></p><ul><li><p>网络组成部分：由主机、路由器、交换机组成</p></li><li><p>网络结构：网络的网络</p></li><li><p>信息交换方式：电路交换和分组交换</p></li><li><p>网络分层：分清职责，物理层、链路层、网络层、运输层和应用层</p></li><li><p>网络协议：标头和载荷</p></li></ul><h1 id="04-Web中的网络"><a href="#04-Web中的网络" class="headerlink" title="04.Web中的网络"></a>04.Web中的网络</h1><p><strong>HTTP协议</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20220157.png"></p><p>在这个示例中，红色的是请求，蓝色的是响应</p><p><strong>HTTP请求</strong></p><ul><li>第一行：GET &#x2F; HTTP&#x2F;1.1</li></ul><p>这三项分别代表请求的方法、资源路径、HTTP版本</p><ul><li>其他几行：头部</li></ul><p>每一行代表一个头部，头部的名称和头部的值用冒号分割</p><p>头部名称不区分大小写</p><ul><li>正文与头部间隔一行（此示例中没有头部）</li></ul><p><strong>HTTP响应</strong></p><ul><li>第一行：HTTP&#x2F;1.1 200 OK</li></ul><p>状态行</p><p>这三项分别代表HTTP版本、状态码、状态信息（可以自定义）</p><ul><li><p>其他几行：头部（与HTTP请求类似）</p></li><li><p>正文与头部间隔一行</p></li></ul><p><strong>HTTP连接模型（请求响应模型）</strong></p><p>当客户端发起第一个请求后，需要等待服务端发送第一个的完整响应，客户端才可以发出第二个请求</p><p>缺点：无法进行多路复用</p><p>Short-lived connections（HTTP&#x2F;1.0）：</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20221026.png"></p><p>Persistent connection（HTTP&#x2F;1.1）:</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20221457.png"></p><p>HTTP Pipeling:</p><p>允许客户端发送多个请求，服务器按顺序响应</p><p>但对于解决队头堵塞几乎没有帮助</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20221617.png"></p><p>为解决队头堵塞问题，最常用的方案是同时建立多个HTTP连接，将请求分散在多个HTTP连接上</p><p>浏览器一般会限制HTTP连接的数量，通常是6个</p><p><strong>HTTP1.1：无法多路复用</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">body<span class="token punctuation">&#123;</span>    <span class="token literal-property property">color</span><span class="token operator">:</span> red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果按行交错发送，客户端收到的内容将会是</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">body<span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token literal-property property">color</span><span class="token operator">:</span> red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>无法判断流中的哪一行都是属于哪个请求，因此无法实现多路复用</p><p><strong>HTTP2：帧</strong></p><p>将多个HTTP请求拆分到帧中，每个帧可以携带来自不同HTTP请求的数据（此处的帧和链路层的帧并非同一种，只是原理类似）</p><p>可以标识哪个数据包来自哪个请求，进而实现多路复用</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">request=style.css<span class="token punctuation">,</span> content=<span class="token string">'body&#123;'</span>request=main.js<span class="token punctuation">,</span> content-<span class="token string">'console.log('</span>hello world<span class="token string">')'</span>request=style.css<span class="token punctuation">,</span> content=<span class="token string">' color: red;'</span>request=style.css<span class="token punctuation">,</span> content=<span class="token string">'&#125;'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>HTTP帧的结构</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20222953.png"></p><p>最开始的3个字节：帧的长度</p><p>第4个字节：帧的类型</p><p>第5个字节：当前帧的状态</p><p>第6个字节：第1位是保留位，后面的31位代表这个帧所属流的ID</p><p>后面为帧的载荷</p><p><strong>HTTP2：帧带来的额外好处</strong></p><ul><li><p>调整响应传输的优先级</p></li><li><p>头部压缩</p></li><li><p>Server Push</p></li></ul><p><strong>HTTP 2：队头堵塞，但是在TCP上</strong></p><p>由于TCP对上层数据缺乏必要的信息（包1不影响包0、2、3），导致队头堵塞</p><p>这个问题很难再已有的TCP协议上解决</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20224128.png"></p><p><strong>HTTP 2：3RTT启动</strong></p><p>TCP连接建立需要一个RTT</p><p>TLS连接建立需要两个RTT</p><p>效率很低</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20224317.png"></p><p><strong>HTTP 3：QUIC</strong></p><p>QUIC将TLS作为自身的一部分，吸取HTTP 2中流的概念</p><p>同时引入新的机制，实现首次1 RTT，后续连接0 RTT的特性</p><ul><li><p>Quick UDP Internet Connection</p></li><li><p>现存网络设备对TCP和UDP支持已经僵化</p></li><li><p>UDP不靠谱但是QUIC靠谱</p></li><li><p>QUIC可以为除HTTP协议以外的应用层协议提供支持</p></li></ul><p><strong>HTTP 3：QUIC-1 RTT</strong></p><p>QUIC实现首次1 RTT，后续连接0 RTT的过程</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20224949.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20225129.png"></p><p><strong>除HTTP外，还有很多因素会影响浏览器的性能</strong></p><p><strong>CDN：你无法突破的物理极限</strong></p><p>超远距离因素无法克服</p><p>流量越大，花销越大</p><p>服务器承载网络流量有限</p><p>CDN可以承担内容分发的任务</p><p><strong>CDN：DNS劫持</strong></p><ul><li><p>域名解析一般由网站自己处理</p></li><li><p>要加速的域名则重定向到CDN厂商的域名解析服务处理</p></li><li><p>CDN厂商根据来源确定最近的CDN服务器的IP</p></li><li><p>用户直接访问最近的CDN服务器</p></li></ul><p><strong>CDN：如何选择CDN服务器</strong></p><p>一种比较简单的策略是，根据DNS查询来源IP的地理位置，确定最近的CDN服务器</p><p>但这并不是最好的策略</p><p><strong>CDN：拉策略和推策略</strong></p><blockquote><p>CDN 加速策略有两种方式，分别是<strong>「推模式」和「拉模式」</strong>。   </p><p> 大部分 CDN 加速策略采用的是「拉模式」，当用户就近访问的 CDN 节点没有缓存请求的数据时，CDN 会主动从源服务器下载数据，并更新到这个 CDN 节点的缓存中。    </p><p>可以看出，拉模式属于被动缓存的方式，与之相反的 「推模式」就属于主动缓存的方式。   </p><p> 如果想要把资源在还没有用户访问前缓存到 CDN 节点，则可以采用「推模式」，这种方式也叫 CDN 预热。   </p><p> 通过 CDN 服务提供的 API 接口，把需要预热的资源地址和需要预热的区域等信息提交上去，CDN 收到后，就会触发这些区域的 CDN 节点进行回源来实现资源预热。</p></blockquote><p>CDN可以从物理层面解决HTTP无法解决的问题，进而提升web应用的性能</p><p><strong>WebSocket</strong></p><p>WebSocket有以下特点：</p><ul><li><p>有状态的持久连接</p></li><li><p>服务端可以主动推送消息</p></li><li><p>发送消息延迟比HTTP低</p></li></ul><p>使用websocket协议需要在HTTP协议的基础上，双方进行协商</p><p><strong>WebSocket：示例</strong></p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">//服务端代码const</span> <span class="token punctuation">&#123;</span> WebSocketServer <span class="token punctuation">&#125;</span> = <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'ws'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token selector">const wss = new WebSocketServer(</span><span class="token punctuation">&#123;</span> <span class="token property">port</span><span class="token punctuation">:</span> 8080<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token selector">wss.on('connection', function connection(ws)</span> <span class="token punctuation">&#123;</span>    <span class="token selector">//有新连接时监听来自客户端的消息    ws.on('message', function message(data)</span> <span class="token punctuation">&#123;</span>        //打印收到的消息，再把消息原封不动地发回客户端        console.<span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'received: %s'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>        ws.<span class="token function">send</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css" data-language="css"><code class="language-css">//客户端代码const WebSocket = <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'ws'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>const ws = new <span class="token function">WebSocket</span><span class="token punctuation">(</span><span class="token string">'ws://localhost:8080'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token selector">ws.on('open', function open()</span> <span class="token punctuation">&#123;</span>    //当连接建立时，向服务器端发送一条消息    ws.<span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'something'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token selector">ws.on('message', function message(data)</span> <span class="token punctuation">&#123;</span>    //当收到来自服务器端的消息时，打印出来    console.<span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'received: %s'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>升级HTTP为WebSocket</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20233020.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20233056.png"></p><p><strong>WebSocket：发送消息</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20233231.png"></p><p><strong>小结</strong></p><ul><li><p>HTTP1、2、3的演进历史</p></li><li><p>CDN解决了HTTP协议以外的问题</p></li><li><p>WebSocket从HTTP协议升级而来</p></li></ul><h1 id="05-网络安全"><a href="#05-网络安全" class="headerlink" title="05.网络安全"></a>05.网络安全</h1><p><strong>网络安全：三要素</strong></p><ul><li><p>机密性</p></li><li><p>完整性</p></li><li><p>身份验证</p></li></ul><p><strong>网络安全：对称加密和非对称加密</strong></p><ul><li><p>对称加密：加密、解密用同样的密钥</p></li><li><p>非对称加密：加密、解密使用不同的密钥（公钥和私钥），而且公钥加密只能用私钥解密、私钥加密只能用公钥解密</p></li></ul><p><strong>网络安全：密码散列函数（哈希函数）</strong></p><ul><li><p>输入：任意长度的内容</p></li><li><p>输出：固定长度的哈希值</p></li><li><p>性质：找到两个不同输入使之经过密码散列函数后有相同的哈希值，在计算上是不可能的</p></li></ul><p><strong>网络安全：机密性</strong></p><ul><li><p>加密需要加密算法和密钥等信息（秘密信息）</p></li><li><p>网络是明文的，不安全</p></li></ul><p><strong>网络安全：完整性和身份验证</strong></p><p>完整性和身份验证相关联</p><p><strong>网络安全：如何实现机密性</strong></p><p>想要通过明文通信交换秘密信息，通信双方需要先有秘密信息</p><p><strong>网络安全：如何实现完整性</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20234140.png"><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20234149.png"></p><p><strong>网络安全：如何实现身份验证</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20234252.png"></p><p>（未完待续）</p><p>让我先把当天的笔记发上去，有时间补上后面的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络：自顶向下—Wireshark实验：HTTP和DNS</title>
      <link href="/2023/04/10/ji-suan-ji-wang-luo-zi-ding-xiang-xia-wireshark-shi-yan-http-he-dns/"/>
      <url>/2023/04/10/ji-suan-ji-wang-luo-zi-ding-xiang-xia-wireshark-shi-yan-http-he-dns/</url>
      
        <content type="html"><![CDATA[<h1 id="Wireshark实验：HTTP"><a href="#Wireshark实验：HTTP" class="headerlink" title="Wireshark实验：HTTP"></a>Wireshark实验：HTTP</h1><p><strong>执行操作：</strong></p><p>1.启动浏览器</p><p>2.启动wireshark数据包嗅探器，在display-filter-specification窗口中输入http，这样就在稍后的分组列表中只捕获http消息</p><p>3.稍等一会开始wireshark数据包捕获</p><p>4.4. 在浏览器中输入以下内容 <a href="http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html">http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html</a> ，您的浏览器应显示非常简单的单行HTML文件</p><ol start="5"><li>停止Wireshark数据包捕获。</li></ol><p>捕获到的http数据包如下图所示</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-11%20202941.png" alt="wireshark截图"></p><p>捕获的消息截图</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-11%20204459.png" alt="wireashark截图"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-11%20204538.png"></p><p>回答下列问题：</p><p>1.您的浏览器是否运行HTTP版本1.0或1.1？服务器运行什么版本的HTTP？</p><p>均匀运行http&#x2F;1.1</p><p>2.您的浏览器会从服务器接收哪种语言？</p><p>无</p><p>3.您的计算机的IP地址是什么？gaia.cs.umass.edu服务器地址呢？</p><p>我的计算机IP地址192.168.31.81</p><p>gaia.cs.umass.edu服务器地址是1.62.64.77</p><p>4.服务器返回到浏览器的状态代码是什么？</p><p>200 OK</p><p>5.服务器上的HTML文件的最近一次修改是什么时候？</p><p>Last-Modified: Thu, 16 Mar 2023 00:28:56</p><p>6.服务器返回多少字节的内容到您的浏览器？</p><p>352</p><p>7.通过检查数据包内容窗口中的原始书就，你是否看到有协议头在数据包列表窗口中未显示？如果是，请举一个例子</p><p>不到有没有</p><p>应该没有</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python-numpy库详解</title>
      <link href="/2023/04/03/python-numpy-ku-xiang-jie/"/>
      <url>/2023/04/03/python-numpy-ku-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>参考CSDN博主「ZSYL」的原创文章，遵循CC 4.0 BY-SA版权协议</p><p> 原文链接：<a href="https://blog.csdn.net/qq_46092061/article/details/118410838">https://blog.csdn.net/qq_46092061/article/details/118410838</a></p><h1 id="numpy介绍"><a href="#numpy介绍" class="headerlink" title="numpy介绍"></a>numpy介绍</h1><p>Numpy（Numerical Python）是一个开源的Python科学计算库，用于快速处理任意维度的数组，并且支持常见的数组和矩阵操作。</p><h2 id="ndarray"><a href="#ndarray" class="headerlink" title="ndarray"></a>ndarray</h2><p>ndarray是numpy提供的一个N维数组类型，它描述了相同类型的 items 的集合</p><p>使用示例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> nptestarray <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>   <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>testarray<span class="token comment">#返回结果</span>testarray<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ndarray比python原生的list计算速度要快很多</strong></p><h3 id="创建array"><a href="#创建array" class="headerlink" title="创建array"></a>创建array</h3><p>numpy中的array函数可以生成多维数组</p><p>通过ndarray类的shape属性可以获得每一维的元素个数，也可以通过shape[n]形式获得每一维的元素个数（n是维度，从0开始）</p><blockquote><p>常用array参数：</p><p>ndmin：指定生成数组的最小维度</p><p>dtype：数组元素的数据类型</p></blockquote><h3 id="ndarray的属性"><a href="#ndarray的属性" class="headerlink" title="ndarray的属性"></a>ndarray的属性</h3><blockquote><p>ndarray.shape：数组维度的元组</p><p>ndarray.ndim：数组维数</p><p>ndarray.size：数组中元素的数量</p><p>ndarray.itemsize：一个数组元素的长度（字节）</p><p>ndarray.dtype：数组元素的类型</p></blockquote><h3 id="ndarray的shape函数"><a href="#ndarray的shape函数" class="headerlink" title="ndarray的shape函数"></a>ndarray的shape函数</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>a<span class="token punctuation">.</span>shapeb<span class="token punctuation">.</span>shape<span class="token comment">#输出结果</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="生成数组"><a href="#生成数组" class="headerlink" title="生成数组"></a>生成数组</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#生成0 1数组</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span>shape<span class="token punctuation">,</span> dtype<span class="token punctuation">)</span>np<span class="token punctuation">.</span>ones_like<span class="token punctuation">(</span>a<span class="token punctuation">,</span> dtype<span class="token punctuation">)</span>np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>shape<span class="token punctuation">,</span> dtype<span class="token punctuation">)</span>np<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>a<span class="token punctuation">,</span> dtype<span class="token punctuation">)</span><span class="token comment">#np.empty():创建一个指定形状、数据类型且未初始化的数组，里面的元素的值是之前内存的值</span><span class="token comment">#order中，C表示行优先，F表示列优先</span>np<span class="token punctuation">.</span>empty<span class="token punctuation">(</span>shape<span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token builtin">float</span><span class="token punctuation">,</span> order<span class="token operator">=</span><span class="token string">'C'</span><span class="token punctuation">)</span><span class="token comment"># 从现有的数组当中创建 </span>a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>   a1 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">#深拷贝，在地址中重新创建对象  </span>a2 <span class="token operator">=</span> np<span class="token punctuation">.</span>asarray<span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">#浅拷贝，指针指向同一对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#生成固定范围的数组</span><span class="token comment">#start, stop：序列的起始值和终止值</span><span class="token comment">#num：要生成的等间隔样例数量，默认为50</span><span class="token comment">#endpoint：是否包含stop值</span><span class="token comment">#retstep：是否显示间距</span>np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span>start<span class="token punctuation">,</span> stop<span class="token punctuation">,</span> num<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">,</span> endpoint<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> retstep<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span>np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">0.</span><span class="token punctuation">,</span> <span class="token number">10.</span><span class="token punctuation">,</span> <span class="token number">20.</span><span class="token punctuation">,</span> <span class="token number">30.</span><span class="token punctuation">,</span> <span class="token number">40.</span><span class="token punctuation">,</span> <span class="token number">50.</span><span class="token punctuation">,</span> <span class="token number">60.</span><span class="token punctuation">,</span> <span class="token number">70.</span><span class="token punctuation">,</span> <span class="token number">80.</span><span class="token punctuation">,</span> <span class="token number">90.</span><span class="token punctuation">,</span> <span class="token number">100.</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#step：步长，默认为1</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>start<span class="token punctuation">,</span> stop<span class="token punctuation">,</span> step<span class="token punctuation">,</span> dtype<span class="token punctuation">)</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">38</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">46</span><span class="token punctuation">,</span> <span class="token number">48</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#num:要生成的等比数列数量，默认为50</span>np<span class="token punctuation">.</span>logspace<span class="token punctuation">(</span>start<span class="token punctuation">,</span> stop<span class="token punctuation">,</span> num<span class="token punctuation">)</span>np<span class="token punctuation">.</span>logspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">1.</span><span class="token punctuation">,</span> <span class="token number">10.</span><span class="token punctuation">,</span> <span class="token number">100.</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录-动态规划</title>
      <link href="/2023/03/27/suan-fa-shua-ti-ji-lu-dong-tai-gui-hua/"/>
      <url>/2023/03/27/suan-fa-shua-ti-ji-lu-dong-tai-gui-hua/</url>
      
        <content type="html"><![CDATA[<h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><h4 id="什么是动态规划（Dynamic-Programming）"><a href="#什么是动态规划（Dynamic-Programming）" class="headerlink" title="什么是动态规划（Dynamic Programming）"></a>什么是动态规划（Dynamic Programming）</h4><p>动态规划用于解决有很多子问题的问题</p><p>动态规划中每一个状态一定是由上一个状态推导出来的</p><h4 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h4><p>1.确定dp数组以及下标的含义</p><p>2.确定递推公式</p><p>3.dp数组如何初始化</p><p>4.确定遍历顺序</p><p>5.举例推导dp数组</p><h3 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509.斐波那契数"></a>509.斐波那契数</h3><p><strong>动态规划</strong></p><p>1.确定dp数组以及下标的含义</p><p>dp[i]的定义是：第i个数的斐波那契数值是dp[i]</p><p>2.确定递推公式</p><p><strong>状态转移方程 dp[i] &#x3D; dp[i-1] + dp[i-2]</strong></p><p>3.dp数组如何初始化</p><p>本题初始化条件 dp[0]&#x3D;0, dp[1]&#x3D;1</p><p>4.确定遍历顺序</p><p>dp[i]依赖dp[i-1], dp[i-2]</p><p>那么遍历的顺序一定是从前向后遍历的</p><p>5.举例推导dp数组</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int fib(int n)&#123;    if(n&lt;&#x3D;1) return n;    vector&lt;int&gt; dp(n+1);    dp[0]&#x3D;0; dp[1]&#x3D;1;    for(int i&#x3D;1;i&lt;&#x3D;n;i++)    &#123;        dp[i] &#x3D; dp[i-1]+dp[i-2];    &#125;    return dp[n];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h3><p>1.确定dp数组以及下标的含义</p><p>dp[i]:爬到第i层楼梯由dp[i]种方法</p><p>2.确定递推公式</p><p>若要上到第i阶台阶，最后一步一定是从第i-1阶或第i-2阶上到第i阶</p><p>那么可知</p><p>递推公式为dp[i] &#x3D; dp[i-1] dp[i-2]</p><p>3.dp数组如何初始化</p><p>dp[1] &#x3D; 1</p><p>dp[2] &#x3D; 2</p><p>4.确定遍历顺序</p><p>从前向后</p><p>5.举例推导dp数组</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int climbStairs(int n)&#123;    if(n &lt;&#x3D; 1) return n;    vector&lt;int&gt; dp(n+1);    dp[1] &#x3D; 1;    dp[2] &#x3D; 2;    for(int i&#x3D;3;i&lt;&#x3D;n;i++)    &#123;        dp[i] &#x3D; dp[i-1] - dp[i-2];    &#125;    return dp[n];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746.使用最小花费爬楼梯"></a>746.使用最小花费爬楼梯</h3><p>1.确定dp数组以及下标的含义</p><p>到达第i台阶所花费最少体力为dp[i]</p><p>2.确定递推公式</p><p>dp[i] &#x3D; min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])</p><p>3.dp数组初始化</p><p>dp[0] &#x3D; 0</p><p>dp[1] &#x3D; 0</p><p>4.确定遍历顺序</p><p>5.举例推导dp数组</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int minCostClimbingStairs(vecror&lt;int&gt;&amp; cost)&#123;    vector&lt;int&gt; dp(cost,size());    dp[0] &#x3D; 0;    dp[1] &#x3D; 0;    for(int i&#x3D;2;i&lt;cost.size();i++)    &#123;        dp[i] &#x3D; min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]);    &#125;    return dp[cost.size()];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h3><p>1.确定dp数组以及下标含义</p><p>从（0，0）出发，到（i，j）的路径数</p><p>2.确定递推公式</p><p>dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]</p><p>3.dp数组初始化</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i&#x3D;0;i&lt;m;i++) dp[i][0] &#x3D; 1;for(int j&#x3D;0;j&lt;n;j++) dp[0][j] &#x3D; 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>4.确定遍历顺序</p><p>从左至右一层一层遍历</p><p>5.举例推导</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int uniquePath(int m, int n)&#123;    vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n, 0));    for(int i&#x3D;0;i&lt;m;i++) dp[i][0] &#x3D; 1;    for(int j&#x3D;0;j&lt;n;j++) dp[0][j] &#x3D; 1;    for(int i&#x3D;1;i&lt;m;i++)    &#123;        for(int j&#x3D;1;j&lt;n;j++)        &#123;            dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];        &#125;        return dp[m-1][n-1];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="63-不同路径Ⅱ"><a href="#63-不同路径Ⅱ" class="headerlink" title="63.不同路径Ⅱ"></a>63.不同路径Ⅱ</h3><p>1.确定dp数组以及下标含义</p><p>含义与上一题相同</p><p>2.确定递推公式</p><p>如果有障碍，路径数应为0</p><p>3.dp数组初始化</p><p>与上一题类似，障碍前的路径数都为1，障碍后的都为0</p><p>4.确定遍历顺序</p><p>从左到右一层一层遍历</p><p>5.举例推导dp数组</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid)&#123;    int m &#x3D; obstacleGrid.size();    int n &#x3D; obstacleGrid[0].size();    if (obstacleGrid[m - 1][n - 1] &#x3D;&#x3D; 1 || obstacleGrid[0][0] &#x3D;&#x3D; 1) &#x2F;&#x2F;如果在起点或终点出现了障碍，直接返回0                return 0;        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n,0));    for(int i&#x3D;0;i&lt;m &amp;&amp; obstacleGrid[i][0]&#x3D;&#x3D;0;i++) dp[i][0] &#x3D; 1;    for(int j&#x3D;0lj&lt;n &amp;&amp; obstacleGrid[0][j]&#x3D;&#x3D;0;j++) dp[0][j] &#x3D; 1;    for(int i&#x3D;1;i&lt;m;i++)    &#123;        for(int j&#x3D;1;j&lt;n;j++)        &#123;            if(obstacleGrid[i][j]&#x3D;&#x3D;1) contine;            dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];        &#125;    &#125;    return dp[m-1][n-1];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343.整数拆分"></a>343.整数拆分</h3><ol><li></li></ol><p>2.确定递推公式</p><p>从1遍历j，有两种渠道得到dp[i]</p><p>一个是j*(i-j)直接相乘</p><p>一个是j*dp[i-j],相当于拆分(i-j)</p><p>3.dp初始化</p><p>dp[2] &#x3D; 1</p><p>4.确定遍历顺序</p><p>从前向后</p><p>5.举例推导</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int integerBreak(int n)&#123;    vector&lt;int&gt; dp(n+1);    dp[2] &#x3D; 1;    for(int i&#x3D;3;i&lt;&#x3D;n;i++)    &#123;        for(int j&#x3D;1;j&lt;&#x3D;i&#x2F;2;j++)        &#123;            dp[i]&#x3D;max(dp[i],max((i-j)*j, dp[i-j]*j));&#125;    &#125;    return dp[n];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="01背包理论基础"><a href="#01背包理论基础" class="headerlink" title="01背包理论基础"></a>01背包理论基础</h3><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p>有n件物品和一个最多能背重量为w的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。每件物品只能使用一次，求解将哪些物品装入背包里价值总和最大。</p><h4 id="二维dp数组01背包"><a href="#二维dp数组01背包" class="headerlink" title="二维dp数组01背包"></a>二维dp数组01背包</h4><p>1.确定dp数组以及下标含义</p><p><strong>dp[i] [j]表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong></p><p>2.确定递推公式</p><p>可以有两个方向推出dp[i] [j]</p><p><strong>不放物品i：</strong>由dp[i-1] [j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i] [j]就是dp[i-1] [j]。</p><p><strong>放物品i：</strong>由dp[i-1] [j-weight[i]]推出，**dp[i-1] [j-weight[i]]<strong>为背包容量为</strong>j-weight[i]<strong>的时候不放物品i的最大价值，那么</strong>dp[i-1] [j-weight[i]+value[i]]**，就是背包放物品i得到的最大价值。</p><p>所以递推公式为</p><p><strong>dp[i] [j] &#x3D; max(dp[i-1] [j], dp[i-1] [j-weight[i]]+value[i])</strong></p><p>3.dp数组如何初始化</p><p>背包容量j为0的话，即dp[i] [0]，无论选取哪些物品，背包价值总和一定为0</p><p>当i为零时</p><p>j&lt;weight[0]时，dp[0] [j]应该是0</p><p>当j &gt;&#x3D; weight[0]时，dp[0] [j]应该是value[0]</p><p>4.确定遍历顺序</p><p>先遍历物品或者先遍历背包都可以</p><p>先遍历物品的代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i&#x3D;1;i&lt;weight.size();i++)&#123;    for(int j&#x3D;0;j &lt;&#x3D; bagweight;j++)    &#123;        if(j&lt;weight)            dp[i][j] &#x3D; dp[i-1][j];                else            dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i]);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先遍历背包的代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int j&#x3D;0;j &lt;&#x3D; bagweight;j++)&#123;    for(int i&#x3D;1;i &lt; weight.size();i++)    &#123;        if(j &lt; weight[i])            dp[i][j] &#x3D; dp[i-1][j];        else            dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i]);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完整代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void bag01()&#123;    vector&lt;int&gt; weight &#x3D; &#123;1,3,4&#125;;    vector&lt;int&gt; value &#x3D; &#123;15,20,30&#125;;    int bagweight &#x3D;  4;        vector&lt;vector&lt;int&gt;&gt; dp(weight.size(), vector&lt;int&gt;(bagweight + 1, 0));        for(int j &#x3D; weight[0];j &lt;&#x3D; bagweight;j++)    &#123;        dp[0][j] &#x3D; value[0];    &#125;        for(int i&#x3D;1;i&lt;weight.size();i++)    &#123;        for(int j&#x3D;0;j&lt;&#x3D;bagweight;j++)        &#123;         if(j &lt; weight[i])                   dp[i][j] &#x3D; dp[i-1][j];            else                dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i]);        &#125;    &#125;    cout&lt;&lt;dp[weight.size() - 1][bagweight]&lt;&lt;endl;&#125;int main()&#123;    bag01();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="01背包理论基础（滚动数组）"><a href="#01背包理论基础（滚动数组）" class="headerlink" title="01背包理论基础（滚动数组）"></a>01背包理论基础（滚动数组）</h3><h4 id="一维dp数组（滚动数组）"><a href="#一维dp数组（滚动数组）" class="headerlink" title="一维dp数组（滚动数组）"></a>一维dp数组（滚动数组）</h4><p> 如果把dp[i-1]那一层拷贝到dp[i]上，表达式可以是：dp[i] [j] &#x3D; max(dp[i] [j], dp[i] [j - weight[i]] + value[i])</p><p>可以直接改为一个一维数组</p><p>1.确定dp数组的定义 </p><p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p><p>2.一维数组的递推公式</p><p>dp[j]为容量为j的背包所背的最大价值</p><p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值</p><p>dp[j - weight[i]] + value[i]表示容量为j - 物品i重量的背包 + 物品i的价值</p><p>即 容量为j的背包，放入了物品i了之后的价值即：dp[j]</p><p>此时，dp[j]有两个选择，</p><p>一个是 不放物品i，值取自己，相当于dp[i-1] [j]</p><p>一个是 放入物品i，值取dp[j - weight[i]] + value[i]</p><p>递推公式为</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.一维dp数组如何初始化</p><p>dp[0] &#x3D; 0</p><p>dp数组在推导的时候一定是取价值最大的数，要比题目给的价值小，这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖</p><p>4.一维dp数组遍历顺序</p><p><strong>一维dp遍历背包应该从大到小遍历（倒序遍历）</strong></p><p>在二维数组中，右下角的值依赖上一层左上角的值，因此需要保证左边的值仍是上一层的，从右向左覆盖</p><p><strong>倒序遍历保证物品i只被放入一次</strong></p><p><strong>必须先遍历物品再遍历背包容量</strong></p><p>如果背包遍历放在上一层，那么每个dp[j]就只会放入一个物品</p><p>5.举例推导</p><p>完整代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void bag01_Onedimensional()&#123;    vector&lt;int&gt; weight &#x3D; &#123;1,3,4&#125;;    vector&lt;int&gt; value - &#123;15,20,30&#125;;    int bagweight &#x3D; 4;        vector&lt;int&gt; dp(bagweight +1,0);    for(int i&#x3D;0;i &lt; weight.size();i++)    &#123;        for(int j&#x3D;bagweight;j &gt;&#x3D; weight[i];j--)        &#123;            dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);        &#125;    &#125;    cout&lt;&lt;dp[bagweight]&lt;&lt;endl;&#125;int main()&#123;    baag01_Onedimensional();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络自顶向下—第二章—套接字编程作业</title>
      <link href="/2023/03/24/ji-suan-ji-wang-luo-zi-ding-xiang-xia-di-er-zhang-tao-jie-zi-bian-cheng-zuo-ye/"/>
      <url>/2023/03/24/ji-suan-ji-wang-luo-zi-ding-xiang-xia-di-er-zhang-tao-jie-zi-bian-cheng-zuo-ye/</url>
      
        <content type="html"><![CDATA[<p><strong>网站<a href="http://www.pearsonhighered.com/cs-resource%E5%8F%AF%E4%BB%A5%E6%89%BE%E5%88%B0%E4%BD%9C%E4%B8%9A%E7%9A%84%E5%85%A8%E9%9D%A2%E7%BB%86%E8%8A%82">http://www.pearsonhighered.com/cs-resource可以找到作业的全面细节</a></strong></p><p>作业文档翻译以及解答参考</p><p><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer">https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer</a></p><h1 id="作业1：Web服务器"><a href="#作业1：Web服务器" class="headerlink" title="作业1：Web服务器"></a>作业1：Web服务器</h1><p><strong>在这个编程作业中，你将用Python语言开发一个简单的Web服务器，它仅能处理一个请求。具体而言，你的Web服务器将：（1）当一个客户（浏览器）联系时创建一个连接套接字；（2）从这个连接接收HTTP请求；（3）解释该请求以确定所请求的特定文件；（4）从服务器的文件系统获得请求的文件；（5）创建一个由请求的文件组成的HTTP响应报文，报文前面有首部行；（6）经TCP连接向请求的浏览器发送响应。如果浏览器请求一个在该服务器中不存在的文件，服务器应当返回一个“404 Not Found”差错报文。在配套网站中，我们提供了用于该服务器的框架代码。你的任务是完善该代码，运行你的服务器，通过在不同主机上运行的浏览器发送请求来测试服务器。如果运行你服务器的主机上已经有一个Web服务器在运行，你应当为该Web服务器使用一个不同于80端口的其他端口。</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span>serverSocket <span class="token operator">=</span>socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span> <span class="token comment">#socket类实例化，第一个参数是地址族（默认是socket.AF_INET,指定使用IPv4协议）；第二个参数是流（默认是socket.SOCK_STREAM,指定面向流的TCP协议）；第三个参数默认是0</span>serverPort<span class="token operator">=</span><span class="token number">6789</span><span class="token comment">#设置端口号为6789</span>serverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#将服务器套接字与端口号6789绑定</span>serverSocket<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#聆听来自客户端的请求，参数定义请求最大数（至少为1）</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Ready to serve...'</span><span class="token punctuation">)</span>    connectionSocket<span class="token punctuation">,</span> addr <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">#调用accept方法，创建名为connectionSocket的新的套接字供特定的客户使用</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        message <span class="token operator">=</span> connectionSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token comment">#获得客户端发送的报文，设定要发送的字节数</span>        filename <span class="token operator">=</span> message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment">#获得客户请求的文件名</span>        f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        outputdata <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#向客户端发送http首部</span>        header <span class="token operator">=</span> <span class="token string">'http/1.1 200 OK\nConnection: close\nContent-Type: text/html\nContent-Length: %d\n\n'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span>        connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>header<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>outputdata<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        connectionSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#报文发送完毕后关闭连接</span>    <span class="token keyword">except</span> IOError<span class="token punctuation">:</span><span class="token comment">#错误提示</span>        outputdata <span class="token operator">=</span> <span class="token string">'http/1.1 404 Not Found\r\n\r\n'</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>outputdata<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>emcode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    connectionSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>severSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在本地浏览器输入localhost:6789&#x2F;f.html</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-24%20174512.png" alt="发送成功"></p><p><strong>可选练习</strong></p><p><strong>1.目前，这个Web服务器一次只处理一个HTTP请求。请实现一个能够同时处理多个请求的多线程服务器。使用线程，首先创建一个主线程，在固定端口监听客户端请求。当从客户端收到TCP连接请求时，它将通过另一个端口建立TCP连接，并在另外的单独线程中为客户端请求提供服务。这样在每个请求&#x2F;响应对的独立线程中将有一个独立的TCP连接。</strong></p><p>程序中需要用到python的threading模块进行多线程编程</p><blockquote><p>在代码中引用threading模块</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="创建thread对象"><a href="#创建thread对象" class="headerlink" title="创建thread对象"></a>创建thread对象</h3><p>每个thread对象代表一个线程，在每个线程中我们可以让程序处理不同的任务</p><p>1.直接创建thread对象</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">threading</span><span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>group<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> target<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> kwargs<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> daemon<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>thread构造方法中，需要将一个callable对象赋值给target，线程才能正常运行</p><p>调用start()方法启动thread对象</p><p><strong>thread的名字</strong></p><p>每个thread都有一个name的属性，代表的就是线程的名字，可以在构造方法中赋值</p><p>默认为“Thread-number”的形式</p><p>可以通过is_alive的方法查询线程是否还在运行</p><p>在主线程结束时，若要使子线程也立即结束，可在子线程调用start()方法之前设置deamon的值为true</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">import</span> threading serverSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_IENT<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span><span class="token comment">#实例化socket类 </span><span class="token comment">#设置接收请求的端口号 </span>serverPort <span class="token operator">=</span> <span class="token number">1111</span> serverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#绑定 </span>serverSocekt<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>  <span class="token keyword">def</span> <span class="token function">function</span><span class="token punctuation">(</span>connectionSocket<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">try</span><span class="token punctuation">:</span>                 message <span class="token operator">=</span> connectionSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>                 filename <span class="token operator">=</span> message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                 f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                 outputdata <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>                 header <span class="token operator">=</span> <span class="token string">' HTTP/1.1 200 OK\nConnection: close\nContent-Type: text/html\nContent-Length: %d\n\n'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span>                       connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>header<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                 connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>outputdata<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                         connectionSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token keyword">except</span> IOError<span class="token punctuation">:</span>                 outputdata <span class="token operator">=</span> <span class="token string">'HTTP/1.1 404 Not Found\r\n\r\n'</span>                 <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                         connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>outputdata<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                      connectionSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span> <span class="token string">'Ready to serve...'</span><span class="token punctuation">)</span>         connectionSocket<span class="token punctuation">,</span> addr <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>         thread <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>webProcess<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>connectionSocket<span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#多线程     </span>    thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>   serverSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**2.不使用浏览器，编写自己的HTTP客户端来测试你的服务器。您的客户端将使用一个TCP连接用于连接到服务器，向服务器发送HTTP请求，并将服务器响应显示出来。您可以假定发送的HTTP请求将使用GET方法。    客户端应使用命令行参数指定服务器IP地址或主机名，服务器正在监听的端口，以及被请求对象在服务器上的路径。以下是运行客户端的输入命令格式。 **</p><blockquote><p>client.py server_host server_port filename</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span> serverName <span class="token operator">=</span> <span class="token string">'192.0.0.0'</span> serverPort <span class="token operator">=</span> <span class="token number">6789</span> clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_IENT<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span> clientSocket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>serverName<span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>  outputdata <span class="token operator">=</span> <span class="token string">'GET /f.html HTTP/1.1\r\n Host: 192.168.137.1\r\n\r\n'</span> clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>outputdata<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> data <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">while</span> data<span class="token punctuation">:</span>         data <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">)</span>      clientSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="作业2：UDP-ping程序"><a href="#作业2：UDP-ping程序" class="headerlink" title="作业2：UDP ping程序"></a>作业2：UDP ping程序</h1><p><strong>在这个编程作业中，你将用python编写一个客户ping程序。该客户将发送一个简单的ping报文，接受一个从服务器返回的对应pong报文，并确定从该客户发送ping报文到接收到pong报文为止的时延。该时延称为往返时延（RTT）。由该客户和服务器提供的功能类似于在现代操作系统中可用的标准ping程序。然而，标准的ping使用互联网控制报文协议（ICMP）。此时我们将创建一个非标准（但简单的）基于UDP的ping程序。</strong></p><p><strong>你的ping程序经UDP向目标服务器发送10个ping报文。对于每个报文，当对应的pong报文返回时，你的客户要确定和打印RTT。因为UDP是一个不可靠的协议，由客户发送的分组可能会丢失。为此，客户不能无限期地等待对ping报文的回答。客户等待服务器回答的时间至多为一秒；如果没有收到回答，客户假定该分组丢失并相应的打印一条报文。</strong></p><p><strong>在此作业中，你将给出服务器的完整代码，你的任务是编写客户代码，可以随意地从服务器代码中剪贴代码行。</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#UDPserver.py</span><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> random <span class="token comment">#随机数生成</span>serverSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">)</span>serverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> <span class="token number">1111</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>                  rand <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>                  message<span class="token punctuation">,</span> address <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>                  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"收到来自 %s 的报文：（%s）"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>address<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">)</span>                  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"随机数是：%d"</span> <span class="token operator">%</span> rand<span class="token punctuation">)</span>                  message <span class="token operator">=</span> message<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span>                                    <span class="token keyword">if</span> rand <span class="token operator">&lt;</span> <span class="token number">4</span>                     comtinue                  serverSocket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>message<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#UDPclient.py</span><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> timeserverName <span class="token operator">=</span> <span class="token string">'localhost'</span>serverPort <span class="token operator">=</span> <span class="token number">1111</span>clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        time_start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#开始计时</span>        message <span class="token operator">=</span> <span class="token string">'Ping *'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>time_start<span class="token punctuation">)</span> <span class="token comment">#要发送的ping报文</span>        clientSocket<span class="token punctuation">.</span>settimeout<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">#超时处理时间设置为1s</span>        clientSocket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>message<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">,</span><span class="token number">1111</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">try</span><span class="token punctuation">:</span>            modified<span class="token punctuation">,</span> serveraddress <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>            Time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> time_start <span class="token comment">#计算RTT</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cost'</span><span class="token punctuation">,</span> Time<span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">)</span>        <span class="token keyword">except</span> timeout<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Request Time Out'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>            clientSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写程序时遇到的问题与解决方法：</p><p>1.将服务器端代码与客户端代码运行后，客户端收到的消息一直为“Request Time Out”，将except后错误类型改为timeout解决</p><p><strong>可选练习</strong></p><p>**1.目前，程序计算每个数据包的往返时间（RTT），并单独打印出来。请按照标准ping程序的模式修改。您需要在客户端每次ping后显示最小，最大和平均RTT。另外，还需计算丢包率（百分比）。 **</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">import</span> time  serverName <span class="token operator">=</span> <span class="token string">'localhost'</span> serverPort <span class="token operator">=</span> <span class="token number">1111</span> recvnum<span class="token operator">=</span><span class="token number">0</span> <span class="token builtin">max</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token builtin">min</span> <span class="token operator">=</span> <span class="token number">2</span> aver <span class="token operator">=</span> <span class="token number">0</span> clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">)</span> <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>         <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                      time_start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>                     message <span class="token operator">=</span> <span class="token string">'Ping *'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>time_start<span class="token punctuation">)</span>                    clientSocket<span class="token punctuation">.</span>settimeout<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                     clientSocket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>message<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> <span class="token number">1111</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                      <span class="token keyword">try</span><span class="token punctuation">:</span>                             modified<span class="token punctuation">,</span> serveraddress <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>                               Time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span> time_start                             <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cost'</span><span class="token punctuation">,</span> Time<span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">)</span>                             recvnum<span class="token operator">+=</span><span class="token number">1</span>                             aver <span class="token operator">+=</span>Time                            <span class="token keyword">if</span><span class="token punctuation">(</span>Time<span class="token operator">></span><span class="token builtin">max</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                                     <span class="token builtin">max</span><span class="token operator">=</span>Time                             <span class="token keyword">if</span><span class="token punctuation">(</span>Time<span class="token operator">&lt;</span><span class="token builtin">min</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                                     <span class="token builtin">min</span><span class="token operator">=</span>Time                       <span class="token keyword">except</span> timeout<span class="token punctuation">:</span>                             <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Request Time Out'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"丢失率"</span><span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">-</span>recvnum<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">100</span><span class="token operator">/</span>recvnum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"%"</span><span class="token punctuation">)</span> <span class="token keyword">if</span><span class="token punctuation">(</span>recvnum<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"最短"</span><span class="token punctuation">,</span> <span class="token builtin">min</span><span class="token punctuation">,</span> <span class="token string">"最长"</span><span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token punctuation">,</span> <span class="token string">"平均"</span><span class="token punctuation">,</span> aver<span class="token operator">/</span>recvnum<span class="token punctuation">)</span>  clientSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.  UDP Ping的另一个类似的应用是UDP Heartbeat。心跳可用于检查应用程序是否已启动并运行，并报告单向丢包。客户端在UDP数据包中将一个序列号和当前时间戳发送给正在监听客户端心跳的服务器。服务器收到数据包后，计算时差，报告丢包（若发生）。如果心跳数据包在指定的一段时间内丢失，我们可以假设客户端应用程序已经停止。实现UDP Heartbeat（客户端和服务器端）。您需要修改给定的UDPPingerServer.py和您自己的UDP ping客户端。</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#server</span><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span>serverSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">)</span>serverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> <span class="token number">1111</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    message<span class="token punctuation">,</span> address <span class="token operator">=</span> serverSocekt<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    message <span class="token operator">=</span> message<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    message <span class="token operator">=</span> message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    timeDiff <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token builtin">float</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"RTT is"</span><span class="token punctuation">,</span> timeDiff<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#client</span><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> timeserverName <span class="token operator">=</span> <span class="token string">'localhost'</span>serverPort <span class="token operator">=</span> <span class="token number">1111</span>clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    time1 <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    outputdata <span class="token operator">=</span> <span class="token string">'Heartbeat'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>time1<span class="token punctuation">)</span>    clientSocket<span class="token punctuation">.</span>seendto<span class="token punctuation">(</span>outputdata<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>serverName<span class="token punctuation">,</span> serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="作业三：邮件客户"><a href="#作业三：邮件客户" class="headerlink" title="作业三：邮件客户"></a>作业三：邮件客户</h1><p><strong>这个编程作业的目的是创建一个向任何接收方发送电子邮件的简单邮件客户。你的客户将必须与邮件服务器（如谷歌的电子邮件服务器）创建一个TCP连接，使用SMTP协议与邮件服务器进行交谈，经该邮件服务器向某接收方（如你的朋友）发送一个电子邮件报文，最后关闭与该邮件服务器的TCP连接。</strong></p><p><strong>对本作业，配套的web站点为你的客户提供了框架代码。你的任务是完善该代码并通过向不同的用户账户发送电子邮件来测试你的客户。你也可以尝试通过不同的服务器（例如谷歌的邮件服务器和你所在的大学的邮件服务器）进行发送</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socekt <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> base64mailserver <span class="token operator">=</span> <span class="token string">'smtp.qq.com'</span> <span class="token comment">#你所用邮件服务器的地址</span>mailUser <span class="token operator">=</span> <span class="token string">'aaa'</span>mailFromAddress <span class="token operator">=</span> <span class="token string">'aaa@qq.com'</span>mailPassword <span class="token operator">=</span> <span class="token string">'******'</span> <span class="token comment">#可以在邮箱设置授权码，使用授权码登录</span>mailToAddress <span class="token operator">=</span> <span class="token string">'bbb@163.com'</span>clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>mailserver<span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#qq的smtp端口号</span>recv <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>recv<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span><span class="token keyword">if</span> recv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'220'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"220 reply not received from server"</span><span class="token punctuation">)</span>        helloCommand <span class="token operator">=</span> <span class="token string">'HELO mailserver\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>helloCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    recv1 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv1 <span class="token operator">=</span> recv1<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv1<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv1<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'250'</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>        loginCommand <span class="token operator">=</span> <span class="token string">'AUTH LOGIN\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>loginCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    recv <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv <span class="token operator">=</span> recv<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'334'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>                userCommand <span class="token operator">=</span> base64<span class="token punctuation">.</span>b64encode<span class="token punctuation">(</span>mailUser<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">b'\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span>：clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>userCommand<span class="token punctuation">)</span>    recv <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv <span class="token operator">=</span> recv<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'334'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>                passCommand <span class="token operator">=</span> base64<span class="token punctuation">.</span>b64encode<span class="token punctuation">(</span>mailPassword<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">b'\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>passCommand<span class="token punctuation">)</span>    recv <span class="token operator">=</span> client<span class="token punctuation">.</span>socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>recv <span class="token operator">=</span> recv<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'235'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>                mailfromCommand <span class="token operator">=</span> <span class="token string">'MAIL FROM: &lt;aaa@qq.com>\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>mailfromCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    recv2 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv2 <span class="token operator">=</span> recv2<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv2<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'250'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>                rcptCommand <span class="token operator">=</span> <span class="token string">'RCPT TO: &lt;bbb@163.com>\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>rcptCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    recv3 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv3 <span class="token operator">=</span> recv3<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv3<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv3<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'250'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>                dataCommand <span class="token operator">=</span> <span class="token string">'DATA\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>DataCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    recv4 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv4 <span class="token operator">=</span> recv4<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv4<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv4<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'354'</span>    <span class="token keyword">break</span>                messageCommand <span class="token operator">=</span> <span class="token string">'\r\ni am doing my computer networking homework\r\n:)\r\n'</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>messageCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>endCommand <span class="token operator">=</span> <span class="token string">'\r\n.\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>endCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    recv5 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv5 <span class="token operator">=</span> recv5<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv5<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv5<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'250'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>                quitCommand <span class="token operator">=</span> <span class="token string">'QUIT\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocekt<span class="token punctuation">.</span>send<span class="token punctuation">(</span>quitCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    recv6 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv6 <span class="token operator">=</span> recv6<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv6<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv5<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'221'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>clientSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-25%20230712.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-25%20233953.png"></p><p><strong>可选练习：</strong></p><p><strong>1.类似Google邮件的服务器（如地址：smtp.gmail.com，端口：587））要求您的客户端在发送MAIL FROM命令之前，需要为了身份验证和安全原因添加传输层安全（TLS）或安全套接字层（SSL）。将TLS &#x2F; SSL命令添加到现有的命令中，并使用上述地址和端口为Google邮件服务器实现客户端。</strong></p><p>代码部分只需在上一题基础上稍作更改</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#导入ssl模块</span><span class="token keyword">import</span> ssl<span class="token comment">#创建套接字</span>context <span class="token operator">=</span> ssl<span class="token punctuation">.</span>create_default_context<span class="token punctuation">(</span><span class="token punctuation">)</span>clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>mailserver<span class="token punctuation">,</span> <span class="token number">465</span><span class="token punctuation">)</span><span class="token punctuation">)</span>clientSocketSSL <span class="token operator">=</span> context<span class="token punctuation">.</span>wrap_socket<span class="token punctuation">(</span>clientSocket<span class="token punctuation">,</span> server_hostname<span class="token operator">=</span>mailserver<span class="token punctuation">)</span><span class="token comment">#套接字变成clientSocketSSL</span><span class="token comment">#需要更改的部分</span>recv <span class="token operator">=</span> clientSocketSSL<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>clientSocketSSL<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token operator">**</span><span class="token operator">*</span>Command<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>clientSocketSSL<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.您当前的SMTP邮件客户端只能在电子邮件正文中发送文本消息。修改您的客户端，使其可以发送包含文本和图像的电子邮件。</strong></p><h1 id="作业四：多线程web代理服务器"><a href="#作业四：多线程web代理服务器" class="headerlink" title="作业四：多线程web代理服务器"></a>作业四：多线程web代理服务器</h1><p><strong>在这个编程作业中，你将研发一个简单的web代理服务器。当你的代理服务器从一个浏览器接收到对某对象的HTTP请求，它生成对相同对象的一个新的HTTP请求并向初始服务器发送。当该代理服务器从初始服务器接收到具有该对象的HTTP响应时，它生成一个包括该对象的新HTTP响应，并发送给该客户。这个代理将是多线程的，使其在相同时间能够处理多个请求。</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os <span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">import</span> sys  <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Usage : "python ProxyServer.py server_ip"\n[server_ip : It is the IP Address Of Proxy Server'</span> <span class="token punctuation">)</span>         sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">#创建服务器套接字，与端口绑定，保持倾听 </span>tcpSerSock <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span> tcpSerPort <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>tcpSerSock<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> tcpSerPort<span class="token punctuation">)</span><span class="token punctuation">)</span> tcpSerSock<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>  <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'ready to serve...'</span><span class="token punctuation">)</span>         tcpCliSock<span class="token punctuation">,</span> addr <span class="token operator">=</span> tcpSerSock<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'received a connection from:'</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>        message <span class="token operator">=</span> tcpCliSock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"message: "</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>message <span class="token operator">==</span> <span class="token string">''</span><span class="token punctuation">)</span>             <span class="token keyword">continue</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        filename <span class="token operator">=</span> message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>partition<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span>         fileExist <span class="token operator">=</span> <span class="token string">'false'</span>         filetouse <span class="token operator">=</span> <span class="token string">"/"</span> <span class="token operator">+</span> filename         <span class="token keyword">print</span><span class="token punctuation">(</span>filetouse<span class="token punctuation">)</span>         <span class="token keyword">try</span><span class="token punctuation">:</span>                 f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"WEB/"</span><span class="token punctuation">,</span> filetouse<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span>                 outputdata <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>                 fileExist <span class="token operator">=</span> <span class="token string">"true"</span>                tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"HTTP/1.0 200 OK \r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                 tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"Content-type:text/html\r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                 tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span>                 <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'read from cache'</span><span class="token punctuation">)</span>          <span class="token keyword">except</span> IOError<span class="token punctuation">:</span>                 <span class="token keyword">if</span> fileExist <span class="token operator">==</span> <span class="token string">'false'</span><span class="token punctuation">:</span>                         c <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span>                        hosten <span class="token operator">=</span> filename<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"www."</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>                         <span class="token keyword">print</span><span class="token punctuation">(</span>hosten<span class="token punctuation">)</span>                         <span class="token keyword">try</span><span class="token punctuation">:</span>                                 serverName <span class="token operator">=</span> hosten<span class="token punctuation">.</span>partition<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                                 serverPort <span class="token operator">=</span> <span class="token number">80</span>                                 c<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>serverName<span class="token punctuation">,</span> serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>                                 askfile <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>filename<span class="token punctuation">.</span>partition<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                                 fileobj <span class="token operator">=</span> c<span class="token punctuation">.</span>makefile<span class="token punctuation">(</span><span class="token string">'rwb'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>                                 fileobj<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> askfile<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"HTTP/1.0\r\nHost: "</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\r\n\r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                 serverRespnse <span class="token operator">=</span> fileobj<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>                                  filename <span class="token operator">=</span> <span class="token string">"WEB/"</span> <span class="token operator">+</span> filename                                 filesplit <span class="token operator">=</span> filename<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>                                 <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>filesplit<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                                        <span class="token keyword">if</span> notos<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>filesplit<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>filesplit<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                  tmpFile <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">"wb"</span><span class="token punctuation">)</span>                                  <span class="token keyword">print</span><span class="token punctuation">(</span>serverResponse<span class="token punctuation">)</span>                                  serverResponse <span class="token operator">=</span> serverResponse<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">b'\r\n\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                                  <span class="token keyword">print</span><span class="token punctuation">(</span>serverResponse<span class="token punctuation">)</span>                                  tmpFile<span class="token punctuation">.</span>write<span class="token punctuation">(</span>serverResponse<span class="token punctuation">)</span>                                  tmpFile<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>                                  tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"HTTP/1.1 200 OK\r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                  tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"Content-Type:text/html\r\n\r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                     tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span>serverResponse<span class="token punctuation">)</span>                           <span class="token keyword">except</span><span class="token punctuation">:</span>                                 <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"illegal request"</span><span class="token punctuation">)</span>                             c<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>                     <span class="token keyword">else</span><span class="token punctuation">:</span>                             <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"net error"</span><span class="token punctuation">)</span>               tcpCliSock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>   tcpCliSock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络自顶向下—第二章部分习题</title>
      <link href="/2023/03/22/ji-suan-ji-wang-luo-zi-ding-xiang-xia-di-er-zhang-bu-fen-xi-ti/"/>
      <url>/2023/03/22/ji-suan-ji-wang-luo-zi-ding-xiang-xia-di-er-zhang-bu-fen-xi-ti/</url>
      
        <content type="html"><![CDATA[<p><strong>P7.假定你在浏览器中点击一条超链接获得web页面。相关联的URL的IP地址没有缓存在本地主机上，因此必须使用DNSlookup以获得该IP地址。如果主机从DNS得到IP地址之前已经访问了n个DNS服务器；相继产生的RTT依次为RTT1,…,RTTn。进一步假定与链路相关的web页面只包含一个对象，即由少量的HTML文本组成。令RTT0表示本地主机和包含对象的服务器之间的RTT值。假定该对象传输时间为零，则从该客户点击该超链接到它接收到该对象需要多长时间？</strong></p><p>从DNS获得服务器的IP地址所需要的时间：<br>$$<br>RTT_1+…+RTT_n<br>$$<br>建立TCP连接，发送对象所需的时间<br>$$<br>2RTT_0<br>$$<br><strong>P8.参照习题P7，假定在同一服务器上某HTML文件引用了8个非常小的对象。忽略发送时间，在下列情况下需要多长时间</strong></p><p><strong>a.没有并行TCP连接的非持续HTTP</strong></p><p><strong>b.配置有5个并行连接的非持续HTTP</strong>、</p><p><strong>c.持续HTTP</strong></p><p>a.传输引用对象<br>$$<br>2<em>8RTT_0<br>$$<br>传输HTML基本文件<br>$$<br>2RTT_0<br>$$<br>总时间<br>$$<br>18RTT_0+RTT_1+…+RTT_n<br>$$<br>b.传输引用对象<br>$$<br>2</em>2RTT_0<br>$$<br>传输HTML基本文件<br>$$<br>2RTT_0<br>$$<br>总时间<br>$$<br>6RTT_0+RTT_1+…+RTT_n<br>$$<br>c.有管线连接<br>$$<br>RTT_0+RTT_1+…+RTT_n<br>$$<br>无管线连接<br>$$<br>10RTT_0+RTT_1+…+RTT_n<br>$$</p><p><strong>P9.考虑图2-12，其中有一个机构的网络和因特网相连。假定对象的平均长度为850 000比特，从这个机构网的浏览器到初始服务器的平均请求是每秒16个请求。还假定从接入链路的因特网一侧的路由器转发一个HTTP请求开始，到接收到其响应的平均时间是3秒。将总的平均响应时间建模为平均接入时延（即从因特网路由器到机构路由器的时延）和平均因特网时延之和了。对于平均接入时延，使用∆&#x2F;（1-∆β），∆是跨越接入链路发送一个对象的平均时间，β是对象对该接入链路的平均到达率。</strong></p><p><strong>a.求出总的平均响应时间</strong></p><p><strong>b.现在假定在这个机构LAN中安装了一个缓存器。假定命中率为0.4，求出总的响应时间</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230322223604.jpg"></p><p>a.<br>$$<br>∆&#x3D;0.85Mb&#x2F;15Mbps&#x3D;0.0567s<br>$$</p><p>$$<br>β&#x3D;16&#x2F;s<br>$$</p><p>$$<br>平均接入时延&#x3D;0.0567&#x2F;(1-0.0567*16)&#x3D;0.611s<br>$$</p><p>$$<br>总平均响应时间&#x3D;3+0.611&#x3D;3.611s<br>$$</p><p>b.<br>$$<br>β&#x3D;16*0.6<br>$$</p><p>$$<br>平均接入时延&#x3D;0.0567&#x2F;(1-0.0567*9.6)&#x3D;0.124s<br>$$</p><p>$$<br>命中总响应时间&#x3D;0.85Mb&#x2F;100Mb&#x3D;0.0085s<br>$$</p><p>$$<br>总平均响应时间&#x3D;0.0085<em>0.4+3.124</em>0.6&#x3D;1.8778s<br>$$</p><p><strong>P10.考虑一条10米短链路，某发送方经过它能够以150bps速率双向传输。假定包含数据的分组是100 000比特长，仅包含控制（如ACK或握手）的分组是200比特长。假定N个并行连接每个都获得1&#x2F;N的链路带宽。现在考虑HTTP协议，并且假定每个下载对象是100kb长，这些初始下载对象包含10个来自相同发送方的引用对象。在这种情况下，经非持续HTTP的并行实例的并行下载有意义吗？现在考虑持续HTTP。你期待这比非持续的情况有很大增益吗？评价并解释你的答案。</strong></p><p>发送方需与对方进行三次握手</p><p>若利用非持续HTTP进行下载：</p><p>前两次握手：<br>$$<br>控制分组传输+RTT<br>$$<br>总时间：<br>$$<br>(200&#x2F;150+Tp+200&#x2F;150+Tp+200&#x2F;150+Tp+100000&#x2F;150+Tp)+((200&#x2F;(150&#x2F;10)+Tp)*3+100000&#x2F;(150&#x2F;10)+Tp)<br>$$</p><p>若利用持续HTTP进行下载：</p><p>前两次握手所需时间与非持续HTTP相同</p><p>总时间为：<br>$$<br>(200&#x2F;150+Tp+200&#x2F;150+Tp+200&#x2F;150+Tp+100000&#x2F;150+Tp)+10*(200&#x2F;150+Tp+100000&#x2F;150+Tp)<br>$$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录—栈与队列</title>
      <link href="/2023/03/19/suan-fa-shua-ti-ji-lu-zhan-yu-dui-lie/"/>
      <url>/2023/03/19/suan-fa-shua-ti-ji-lu-zhan-yu-dui-lie/</url>
      
        <content type="html"><![CDATA[<h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说，我们可以控制使用哪种容器来实现栈的功能）</p><p>栈不提供走访功能，不提供迭代器</p><p>我们常用的SGI STL，如果没有指定其底层实现的话，默认是以deque为缺省情况下的底层结构</p><p>也可以指定vector为栈的底层实现</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::stack&lt;int, std::vector&lt;int&gt; &gt; third;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>队列的情况也是一样的</p><p>不允许有遍历行为，不提供迭代器</p><p>SGI STL中也是以deque缺省情况下的底部结构</p><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    bool isValid(string s)    &#123;        stack&lt;char&gt; ss;        if(s.size()%2 !&#x3D; 0) return false;                for(int i&#x3D;0;i&lt;s.size();i++)        &#123;            if(s[i]&#x3D;&#x3D;&#39;(&#39;) ss.push(&#39;)&#39;);            else if(s[i]&#x3D;&#x3D;&#39;[&#39;) ss.push(&#39;]&#39;);            else if(s[i]&#x3D;&#x3D;&#39;&#123;&#39;) ss.push(&#39;&#125;&#39;);            else if(ss.empty() || ss.top!&#x3D;s[i]) return false;            else ss.pop();        &#125;        return ss.empty();                &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1047-删除字符串中的相邻重复项"><a href="#1047-删除字符串中的相邻重复项" class="headerlink" title="1047.删除字符串中的相邻重复项"></a>1047.删除字符串中的相邻重复项</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123; public:         string removeDuplicates(string s)     &#123;                 stack&lt;char&gt; ss;                 for(char a:s)                 &#123;                         if(ss.empty() || a!&#x3D;ss.top())                        &#123;          ss.push(a);          &#125;              else                         &#123;                                ss.pop();             &#125;                     &#125;                  string result&#x3D;&quot;&quot;;                 while(!ss.empty())                 &#123;                     result+&#x3D;ss.top();                         ss.pop();                 &#125;                 reverse(result.begin(),result.end());                 return result;           &#125; &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="150-逆波兰表达式"><a href="#150-逆波兰表达式" class="headerlink" title="150.逆波兰表达式"></a>150.逆波兰表达式</h3><blockquote><p>字符串有关的函数</p><p>1.stoi()</p><p>将字符串转换为整型</p><p>2.stoll()</p><p>将字符串转换为long long</p><p>3.stof()</p><p>将字符串转换为float</p><p>4.stod()</p><p>将字符串转换为double<a href="https://www.comap-math.com/mcm/2023Certs/2303164.pdf">https://www.comap-math.com/mcm/2023Certs/2303164.pdf</a></p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    int evalRPN(vector&lt;string&gt;&amp; tokens)&#123;stack&lt;long long&gt; st;        for(int i&#x3D;0;i &lt; tokens.size();i++)        &#123;            if(tokens[i] &#x3D;&#x3D; &quot;+&quot; || tokens[i] &#x3D;&#x3D; &quot;-&quot; || tokens &#x3D;&#x3D; &quot;*&quot; || tokens &#x3D;&#x3D; &quot;&#x2F;&quot;)&#123;                long long num1 &#x3D; st.top();                st.pop();                long long num2 &#x3D; st.top();                st.pop();                if(tokens[i] &#x3D;&#x3D; &quot;+&quot;) st.push(num1 + num2);                if(tokens[i] &#x3D;&#x3D; &quot;-&quot;) st.push(num2 - num1);                if(tokens[i] &#x3D;&#x3D; &quot;*&quot;) st.push(num2 * num1);                if(tokens[i] &#x3D;&#x3D; &quot;&#x2F;&quot;) st.push(num2 &#x2F; num1);                            &#125;            else&#123;                st.push(stoll(tokens[i]));            &#125;&#125;        int result &#x3D; st.top();        st.pop();        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h3><p>对于此题，我们需要一个队列，随着窗口移动，队列一进一出，每次移动调用que.pop()（滑动窗口移除元素）、que.push()（滑动窗口添加元素）、que.front()（返回最大值）</p><p><strong>该队列只维护有可能成为窗口里最大值的元素（单调队列）</strong></p><p>单调队列如何配合窗口进行移动：</p><ol><li><p>pop(value)：<strong>窗口移除的元素value &#x3D; 队列出口元素，则弹出元素，否则不进行任何操作</strong></p></li><li><p>push(value)：<strong>push的元素value &gt; 入口元素的值，弹出入口元素，直到push元素的数值 &lt;&#x3D; 队列入口元素的数值</strong></p></li><li><p>que.front()返回窗口最大值</p></li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;private:    class Myqueue&#123;        public:        deque&lt;int&gt; que;        void pop(int value)            &#123;                if(!que.empty &amp;&amp; value &#x3D;&#x3D; que.front())                    que.pop_front();            &#125;        void push(int value)            &#123;                while(!que.empty &amp;&amp; value &gt; que.front())                &#123;                    que.pop_back();                &#125;                que.push_back(value);            &#125;        int front()        &#123;            return que.front();        &#125;            &#125;;public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k)    &#123;        Myqueue que;        vector&lt;int&gt; result;        for(int i&#x3D;0;i &lt; k;i++)        &#123;            que.push(nums[i]);        &#125;        result.push_back(que.front());        for(int i&#x3D;k;i &lt; nums.size();i++)        &#123;            que.pop(nums[i-k]);            que.push(nums[i]);            result.push_back(que.front());        &#125;        return result;    &#125;    &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="347-前k个高频元素"><a href="#347-前k个高频元素" class="headerlink" title="347.前k个高频元素"></a>347.前k个高频元素</h3><ol><li>利用map进行元素频率的统计</li><li>利用priority_queue对频率进行排列</li></ol><blockquote><p>优先级队列内部元素自动依照元素的权值排列</p><p>缺省情况下priority_queue利用max_heap完成对元素的排列，该大顶堆是以vector为表现形式的complete binary tree</p><p>本题利用小顶堆来实现</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    class mycomparison&#123;        public:        bool operator()(const pair&lt;int,int&gt;&amp; lhs, const pair&lt;int,int&gt;&amp; rhs)            &#123;                return lhs.second &gt; rhs.second;            &#125;    &#125;;        vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k)    &#123;        unordered_map&lt;int, int&gt; map;        for(int i&#x3D;0;i  &lt; nums.size();i++)        &#123;            map[nums[i]]++;        &#125;        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; ,mycomparison&gt; que;        for(unordered_map&lt;int, int&gt;::iterator it&#x3D;map.begin();it!&#x3D;map.end();it++)        &#123;            que.push(*it);            if(que.size()&gt;k)                que.pop();        &#125;        vector&lt;int&gt; result(k);        for(int i&#x3D;k-1;i&gt;&#x3D;0;i--)        &#123;            result[i] &#x3D; que.top().first;            que.pop()        &#125;                return result;            &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><p>匹配左括号时，右括号先入栈，只需要比较当前元素和栈顶相不相等</p><h4 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h4><p>将字符串顺序放到一个栈中，如果相同的话栈就弹出</p><h4 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h4><p>相邻字符串的消除问题</p><h4 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h4><p>队列没有必要维护窗口里的所有元素，只需要维护可能成为窗口里最大值的元素，同时保证队列里的元素数值时由大到小的</p><p>设计单调队列时，pop和push的操作要保持以下原则：</p><ol><li>pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用进行任何操作</li><li>push(value)：如果push的元素value大于入口元素的数值，那么就将队列出口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</li></ol><h4 id="求前K个高频元素"><a href="#求前K个高频元素" class="headerlink" title="求前K个高频元素"></a>求前K个高频元素</h4><p>unordered_map计算频率</p><p>利用priority_queue完成对元素的排序</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言（第三版）王爽—实验4</title>
      <link href="/2023/03/17/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-4/"/>
      <url>/2023/03/17/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-4/</url>
      
        <content type="html"><![CDATA[<h1 id="BX-和loop的使用"><a href="#BX-和loop的使用" class="headerlink" title="[BX]和loop的使用"></a>[BX]和loop的使用</h1><h3 id="（1）编程，向内存0-2000-23F依次传送数据063-3FH"><a href="#（1）编程，向内存0-2000-23F依次传送数据063-3FH" class="headerlink" title="（1）编程，向内存0:2000:23F依次传送数据063(3FH)"></a>（1）编程，向内存0:200<del>0:23F依次传送数据0</del>63(3FH)</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-17%20161753.png" alt="源程序"></p><p>编译后查看寄存器存储情况</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-17%20162152.png"></p><h3 id="（2）编程，向内存0-2000-23F依次传送数据063-3FH-，程序中只能使用9条指令，包括mov-ax-4c00h-int-21h"><a href="#（2）编程，向内存0-2000-23F依次传送数据063-3FH-，程序中只能使用9条指令，包括mov-ax-4c00h-int-21h" class="headerlink" title="（2）编程，向内存0:2000:23F依次传送数据063(3FH)，程序中只能使用9条指令，包括mov ax,4c00h,int 21h"></a>（2）编程，向内存0:200<del>0:23F依次传送数据0</del>63(3FH)，程序中只能使用9条指令，包括mov ax,4c00h,int 21h</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-17%20162633.png" alt="源程序"></p><h3 id="（3）补全程序，调试程序（程序略），跟踪运行结果"><a href="#（3）补全程序，调试程序（程序略），跟踪运行结果" class="headerlink" title="（3）补全程序，调试程序（程序略），跟踪运行结果"></a>（3）补全程序，调试程序（程序略），跟踪运行结果</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录—双指针法</title>
      <link href="/2023/03/13/suan-fa-shua-ti-ji-lu-shuang-zhi-zhen-fa/"/>
      <url>/2023/03/13/suan-fa-shua-ti-ji-lu-shuang-zhi-zhen-fa/</url>
      
        <content type="html"><![CDATA[<p><strong>本文只给出代码过程，具体分析见对应类别的文章</strong></p><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int removeElement(vector&lt;int&gt;&amp; nums,int val)&#123;    int slow&#x3D;0;    for(int fast&#x3D;0;fast&lt;nums.size();fast++)    &#123;        if(val!&#x3D;nums[fast])            nums[slow++]&#x3D;nums[fast];    &#125;    return slow;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void reverseString(vector&lt;char&gt;&amp; s)&#123;    for(int i&#x3D;0,j&#x3D;s.size()-1;i&lt;s.size()&#x2F;2;i++,j--)    &#123;        swap(s[i],s[j]);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="剑指offer05-替换空格"><a href="#剑指offer05-替换空格" class="headerlink" title="剑指offer05.替换空格"></a>剑指offer05.替换空格</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string replaceSpace(string s)&#123;    int count&#x3D;0;    int oldsize&#x3D;s.size();    for(int i&#x3D;0;i&lt;s.size();i++)    &#123;        if(s[i]&#x3D;&#x3D;&#39; &#39;)            count++;    &#125;    s.resize(s.size()+count*2);    int newsize&#x3D;s.size();    for(int i&#x3D;newsize-1,j&#x3D;oldsize-1;j&lt;i;i--,j--)    &#123;        if(s[j]!&#x3D;&#39; &#39;)            s[i]&#x3D;s[j];        else&#123;            s[i]&#x3D;&#39;0&#39;;            s[i-1]&#x3D;&#39;2&#39;;            s[i-2]&#x3D;&#39;%&#39;;            i-&#x3D;2;        &#125;    &#125;    return s;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="206-翻转链表"><a href="#206-翻转链表" class="headerlink" title="206.翻转链表"></a>206.翻转链表</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode* reverseList(ListNode* head)&#123;    ListNode* temp;    ListNode* cur&#x3D;head;    ListNode* pre&#x3D;NULL;    while(cur)    &#123;        temp&#x3D;cur-&gt;next;        cur-&gt;next&#x3D;pre;        pre&#x3D;cur;        cur&#x3D;temp;    &#125;    return pre;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="19-删除链表倒数第N个结点"><a href="#19-删除链表倒数第N个结点" class="headerlink" title="19.删除链表倒数第N个结点"></a>19.删除链表倒数第N个结点</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode* removeNthFromEnd(ListNode* head,int n)&#123;    ListNode* dummyhead &#x3D; new ListNode(0);    dummyhead-&gt;next&#x3D;head;    ListNode* slow&#x3D;dummyhead;    ListNode* fast&#x3D;dummyhead;    while(n-- &amp;&amp; fast!&#x3D;null)    &#123;        fast&#x3D;fast-&gt;next;    &#125;    fast&#x3D;fast-&gt;next;    while(fast!&#x3D;null)    &#123;        fast&#x3D;fast-&gt;next;        slow&#x3D;slow-&gt;next;            &#125;    slow-&gt;next&#x3D;slow-&gt;next-&gt;next;        return dummyhead-&gt;next;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题02-07-链表相交"><a href="#面试题02-07-链表相交" class="headerlink" title="面试题02.07.链表相交"></a>面试题02.07.链表相交</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    ListNode* curA &#x3D; headA;    ListNode* curB &#x3D; headB;    int lenA &#x3D; 0,lenB &#x3D; 0;    while(curA!&#x3D;null)&#123;        lenA++;        curA&#x3D;curA-&gt;next;    &#125;    while(curB!&#x3D;null)&#123;        lenB++;        curB&#x3D;curB-&gt;next;    &#125;    curA&#x3D;headA; curB&#x3D;headB;        if(lenB&gt;lenA)&#123;        swap(lenA,lenB);        swap(curA,curB);    &#125;    int gap &#x3D; lenA-lenB;    while(gap--)&#123;        curA&#x3D;curA-&gt;next;    &#125;    while(curA!&#x3D;null)&#123;        if(curA &#x3D;&#x3D; curB)            return curA;    &#125;    curA&#x3D;curA-&gt;next;    curB&#x3D;curB-&gt;next;        return null;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="142-环形链表Ⅱ"><a href="#142-环形链表Ⅱ" class="headerlink" title="142.环形链表Ⅱ"></a>142.环形链表Ⅱ</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    ListNode* fast &#x3D; head;    ListNode* slow &#x3D; head;    while(fast!&#x3D;null &amp;&amp; fast-&gt;next!+null)&#123;        slow&#x3D;slow-&gt;next;        fast&#x3D;fast-&gt;next-&gt;next;    &#125;    if(slow &#x3D;&#x3D; fast)&#123;        ListNode* index1 &#x3D; fast;        ListNode* index2 &#x3D; slow;        while(index1!&#x3D;index2)&#123;            index1 &#x3D; index1-&gt;next;            index2 &#x3D; index2-&gt;next;                        &#125;        return index2;    &#125;    return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="0015-三数之和"><a href="#0015-三数之和" class="headerlink" title="0015.三数之和"></a>0015.三数之和</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums)&#123;        vector&lt;vector&lt;int&gt;&gt; result;        sort(nums.begin(),nums.end());                for(int i&#x3D;0;i&lt;nums.size();i++)        &#123;            if(nums[i]&gt;0)                return result;            if(i&gt;0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i-1])                continue;            int left&#x3D;i+1;            int right&#x3D;nums.size()-1;            while(right&gt;left)&#123;                if(numns[i]+nums[left]+nums[right]&gt;0)                    right--;                else if(nums[i]+nums[left]+nums[right]&lt;0)                    left++;                else&#123;                    result.push_back(vector&lt;int&gt;&#123;nums[i],nums[left],nums[right]&#125;);                    while(right&gt;left &amp;&amp; nums[right] &#x3D;&#x3D; nums[right-1]) right--;                    while(right&gt;left &amp;&amp; nums[left] &#x3D;&#x3D; nums[left-1]) left++;                    right--;                    left++;                &#125;            &#125;        &#125;                            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言（第三版）王爽—实验三</title>
      <link href="/2023/03/13/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-san/"/>
      <url>/2023/03/13/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-san/</url>
      
        <content type="html"><![CDATA[<h1 id="实验3-编程、编译、连接"><a href="#实验3-编程、编译、连接" class="headerlink" title="实验3 编程、编译、连接"></a>实验3 编程、编译、连接</h1><p>（1）将书中给出的程序保存为t1.asm文件，将其生成可执行文件t1.exe</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20203934.png" alt="在edit中输入程序"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20204305.png" alt="编译t1.asm文件"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20204454.png" alt="连接目标文件，生成可执行文件"></p><p>（2）用debug跟踪t1.exe的执行过程，写出每一步执行后，相关寄存器中的内容和栈顶的内容</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20204616.png" alt="查看各个寄存器的设置情况"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20204725.png" alt="分别执行每一条指令"></p><p><strong>执行至int 21H时，用p指令结束程序</strong></p><p><strong>显示”program terminated normally”表示程序已正常执行完毕</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20204818.png" alt="所有指令执行完毕"></p><p>（3）PSP的头两个字节是CD20，用debug加载t1.exe，查看PSP的内容</p><p>利用r命令查看寄存器内容</p><p>查看075a</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20205248.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言（第三版）王爽—第四章</title>
      <link href="/2023/03/13/hui-bian-yu-yan-di-san-ban-wang-shuang-di-si-zhang/"/>
      <url>/2023/03/13/hui-bian-yu-yan-di-san-ban-wang-shuang-di-si-zhang/</url>
      
        <content type="html"><![CDATA[<h1 id="4-3编辑源程序"><a href="#4-3编辑源程序" class="headerlink" title="4.3编辑源程序"></a>4.3编辑源程序</h1><p>（1）进入DOS，运行edit</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20190805.png"></p><p>（2）在edit中编辑程序</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20191012.png"></p><p>（3）将程序保存为c:\1.asm后退出edit</p><h1 id="4-4编译"><a href="#4-4编译" class="headerlink" title="4.4编译"></a>4.4编译</h1><p><strong>（1）进入DOS，c:\masm，运行masm.exe</strong></p><p>默认文件扩展名为ASM，如果源程序不是以asm为扩展名，就要输入它的全名</p><p>输入文件名时还要指明路径</p><p><strong>（2）输入源程序文件名后，系统提示输入目标文件名</strong></p><p>默认目标文件名与源程序名相同</p><p>也可指定目标文件所在的目录</p><p><strong>（3）忽略列表文件和交叉引用文件的生成</strong></p><p><strong>（4）对源程序的编译结束</strong></p><p>最后两行提示我们无警告和必须要改正的错误</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20191453.png"></p><p>编译过程中，我们提供了一个输入，即源程序文件。</p><p>最多可得到三个输出文件：目标文件(.obj)，列表文件(.lst)，交叉引用文件(.crf)</p><h1 id="4-5连接"><a href="#4-5连接" class="headerlink" title="4.5连接"></a>4.5连接</h1><p>  对源程序进行编译得到目标文件后，我们需要对目标文件进行连接，从而得到可执行文件</p><p>（1）进入DOS，运行link</p><p>（2）输入目标文件名</p><p>（3）忽略可执行文件名，忽略映像生成文件</p><p>（4）连接程序提示输入库文件的名称，这里直接忽略</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20192525.png"></p><p><strong>连接的作用</strong></p><p>（1）连接多个源程序</p><p>（2）连接库文件和目标文件</p><h1 id="4-6以简化的方式进行编译和连接"><a href="#4-6以简化的方式进行编译和连接" class="headerlink" title="4.6以简化的方式进行编译和连接"></a>4.6以简化的方式进行编译和连接</h1><p><strong>简化的编译：</strong></p><p>masm + 源程序文件的路径和文件名，并在结尾加上分号</p><p>过程中自动忽略中间文件的生成</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20193339.png" alt="简化编译"></p><p><strong>简化的连接：</strong></p><p>link + 目标文件的路径和文件名，并在结尾加上分号</p><p>过程中自动忽略中间文件的生成</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20193554.png" alt="简化连接"></p><h1 id="4-9程序执行过程的跟踪"><a href="#4-9程序执行过程的跟踪" class="headerlink" title="4.9程序执行过程的跟踪"></a>4.9程序执行过程的跟踪</h1><p>输入debug 1.exe跟踪程序的执行</p><p>使用R命令查看各个寄存器的设置情况</p><p>cx中存放的是程序的长度</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20200013.png" alt="debug的过程"></p><p><strong>DOS系统中.exe文件的加载</strong></p><p>找到一段起始地址SA:1000</p><p>在这段内存的前256个字节中，创建一个程序段前缀(PSP)</p><p>从这段内存区的256字节处开始，将程序装入，地址为SA+10H:0</p><p>将段地址存入ds中，初始化其它相关寄存器后，设置CS:IP指向程序的入口</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言（第三版）王爽—实验二</title>
      <link href="/2023/03/11/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-er/"/>
      <url>/2023/03/11/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-er/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="debug的使用"><a href="#debug的使用" class="headerlink" title="debug的使用"></a>debug的使用</h2><p><strong>关于D命令</strong></p><p>debug在执行如d 段地址：偏移地址这种D命令时，将段地址送入ds中比较方便</p><p><strong>在E,A,U命令中使用段寄存器</strong></p><p>debug的T命令在执行修改寄存器SS的指令时，下一条指令也紧接着被执行</p><h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><p>(1)使用debug将程序段写入内存中，并逐条执行</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_211335.png" alt="输入指令"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言（第三版）王爽——实验一</title>
      <link href="/2023/03/04/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-yi/"/>
      <url>/2023/03/04/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="查看CPU和内存，用机器指令和汇编指令编程"><a href="#查看CPU和内存，用机器指令和汇编指令编程" class="headerlink" title="查看CPU和内存，用机器指令和汇编指令编程"></a>查看CPU和内存，用机器指令和汇编指令编程</h1><h2 id="debug的使用"><a href="#debug的使用" class="headerlink" title="debug的使用"></a>debug的使用</h2><h3 id="安装DOSBOX进行实验"><a href="#安装DOSBOX进行实验" class="headerlink" title="安装DOSBOX进行实验"></a>安装DOSBOX进行实验</h3><p><strong>R命令查看改变CPU寄存器内容</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_193445.png" alt="DOSBOX界面"></p><p>在所有寄存器的下方，debug还列出了CS:IP所指向的内存单元处所存放的机器码，并将它翻译为机器指令。</p><p>此处CS:IP所指向的内存单元为073F:0100.此处存放的及机器码为 0000 ，对应的汇编指令为 ADD [BX+SI],AL。</p><p>还可以利用R指令修改寄存器中的内容</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_194422.png" alt="使用R命令修改AX中的内容"></p><p><strong>D命令查看内存中的内容</strong></p><p>d 段地址：偏移地址</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_195008.png" alt="D命令查看内存1000:0处的内容"></p><p>debug将列出从指定内存单元往后128个内存单元的内容（1000:0~1000:F）</p><p>也可以指定查看的范围 d 段地址:起始偏移地址 结尾偏移地址</p><p><strong>用D命令改写内存内容</strong></p><p>e 起始地址 数据 数据 数据 数据…</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_200320.png" alt="用E指令修改1000：0开始的4个单元的内容"></p><p>也可以采用提问的方式来逐个的修改内存的内容</p><p><strong>用E命令向内存中写入机器码，用U命令查看内存中机器码的含义，用T命令执行内存中的机器码</strong></p><p>写入机器码</p><p>mov ax,0001</p><p>mov cx,0002</p><p>add ax,cx</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_202323.png" alt="将机器码写入内存"></p><p>使用U命令翻译</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_202645.png" alt="用U命令将内存单元中的内容翻译为汇编指令显示"></p><p>简单的使用T命令可以执行CS:IP指向的指令</p><p>若要用T命令控制CPU执行某个指令，必须先让CS:IP指向该指令</p><p>可用R命令修改CS:IP中的内容，使CS:IP指向指定的内容</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_203550.png" alt="修改CS:IP指向的内容"></p><p>再使用T命令执行指令</p><p>注意，指令执行后，AX中的内容被改写为1，IP改变为IP+3，CS:IP指向下一条指令</p><p><strong>A命令以汇编指令的形式在内存中写入机器指令</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_204150.png" alt="用A命令向从1000：0开始的内存单元中写入指令"></p><h3 id="本次实验中需要用到的命令"><a href="#本次实验中需要用到的命令" class="headerlink" title="本次实验中需要用到的命令"></a>本次实验中需要用到的命令</h3><p>查看修改CPU寄存器的内容：R命令</p><p>查看内存中的内容：D命令</p><p>修改内存中的内容：E命令（可以写入数据指令）</p><p>将内存中的内容解释为机器指令和对应的汇编指令：U命令</p><p>执行CS:IP指向的内存单元处的指令：T命令</p><p>以汇编指令的形式向内存中写入指令：A命令</p><h3 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h3><p>（1）使用debug，将下面的程序写入内存，逐条执行，观察每条指令(此处指令省略)执行后CPU中相关寄存器中内容的变化。</p><p>提示：可用E命令和A命令以两种方式将指令写入内存</p><p>（2）将下面3条指令写入从2000：0开始的内存单元中，利用这3条指令计算2的8次方。</p><p>mov ax,1</p><p>add ax,ax</p><p>jmp 2000:0003</p><p>（3）查看内存中的内容</p><p>（4）向内存从B8100H开始的单元中填写数据</p><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p>（1）使用debug，将下面的程序写入内存，逐条执行，观察每条指令(此处指令省略)执行后CPU中相关寄存器中内容的变化。</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_205601.png" alt="写入内存"></p><p>（2）将下面3条指令写入从2000：0开始的内存单元中，利用这3条指令计算2的8次方。</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_210154.png" alt="用A命令写入指令"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_211335.png"></p><p>执行八次即可得到2的8次方</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录—字符串</title>
      <link href="/2023/02/24/suan-fa-shua-ti-ji-lu-zi-fu-chuan/"/>
      <url>/2023/02/24/suan-fa-shua-ti-ji-lu-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="算法刷题记录—字符串"><a href="#算法刷题记录—字符串" class="headerlink" title="算法刷题记录—字符串"></a>算法刷题记录—字符串</h1><h3 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h3><p>关键代码：</p><p>去掉多余的空格</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void removeExtraSpaces(string&amp; s)&#123;    int slow&#x3D;0;    for(int i&#x3D;0;i&lt;s.size();++i)    &#123;        if(s[i]!&#x3D;&#39; &#39;)        &#123;            if(slow!&#x3D;0) s[slow++]&#x3D;&#39; &#39;;            while(i&lt;s.size() &amp;&amp; s[i]!&#x3D;&#39; &#39;)                s[slow++] &#x3D; s[i++];        &#125;    &#125;    s.resize(slow);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="剑指offer-58-左旋转字符串"><a href="#剑指offer-58-左旋转字符串" class="headerlink" title="剑指offer 58:左旋转字符串"></a>剑指offer 58:左旋转字符串</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string reverseLeftWords(string s,int n)&#123;    reverse(s.begin(), s.begin()+n);    reverse(s.begin()+n,s.end());    reverse(s.begin(),s.end());    return s;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p><strong>前缀表（prefix table）：记录了模式串与主串（文本串不匹配的时候，模式串应该从哪里开始匹配）</strong></p><p><strong>记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀</strong></p><h4 id="最长公共前后缀"><a href="#最长公共前后缀" class="headerlink" title="最长公共前后缀"></a>最长公共前后缀</h4><p>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</p><p>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</p><p>前缀表要求的就是相同前后缀的长度</p><h4 id="使用next数组来匹配"><a href="#使用next数组来匹配" class="headerlink" title="使用next数组来匹配"></a>使用next数组来匹配</h4><p><strong>初始化</strong></p><p>定义两个指针，j指向前缀末尾位置，i指向后缀末尾位置。</p><p><strong>处理前后缀不相同的情况</strong></p><p>遍历模式串下标j要从1开始</p><p>如果s[i] s[j+1]不相同，也就是 前后缀末尾不相同的情况，要向前回退。</p><p><strong>处理前后缀相同的情况</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(s[i] &#x3D;&#x3D; s[j+1])&#123;    j++:&#125;next[i]&#x3D;j;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>构建next数组的函数代码</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void getNext(int* next,const string&amp; s)&#123;    int j&#x3D;-1;    next[0]&#x3D;j;    for(int i&#x3D;1;i&lt;s.size();i++)&#123;        while(j&gt;&#x3D;0 &amp;&amp; s[i] !&#x3D; s[j+1])&#123;            j &#x3D; next[j];        &#125;        if(s[i] &#x3D;&#x3D; s[j+1])            j++;        next[i]&#x3D;j;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用next数组来匹配</strong></p><p>在文本串s里找是否出现过模式串t</p><p>定义两个下标</p><p>j：指向模式串起始位置（初始值为-1，因为next数组里记录的起始位       置为-1</p><p>i：指向文本串起始位置</p><p>i从0开始，遍历文本串</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i&#x3D;0;i&lt;s.size();i++)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>s[i]与t[j+1]进行比较</p><p><strong>不相同：j从next数组里寻找下一个匹配的位置</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while(j &gt;&#x3D; 0 &amp;&amp; s[i] !&#x3D; t[j+1])&#123;    j &#x3D; next[j];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>相同：i，j同时向后移动</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(s[i] &#x3D;&#x3D; t[j+1])&#123;    j++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>如果j指向了模式串t的末尾，说明已经完全匹配</strong></p><p><strong>完全匹配后，要找出文本串中模式串出现的第一个位置，所以返回</strong></p><p><strong>当前在文本串匹配模式串的位置i 减去 模式串的长度</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(j &#x3D;&#x3D; (t.size() - 1))&#123;return (i - t.size() + 1)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="前缀表统一减一代码实现"><a href="#前缀表统一减一代码实现" class="headerlink" title="前缀表统一减一代码实现"></a>前缀表统一减一代码实现</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    void getnext(int *next, const string &amp;s)&#123;        int j&#x3D;-1;        next[0]&#x3D;j;        for(int i&#x3D;1;i&lt;s.size();i++)        &#123;            while(j&gt;&#x3D;0&amp;&amp;s[i]!&#x3D;s[j+1])&#123;&#x2F;&#x2F;前后缀不同的情况                j&#x3D;next[j];&#x2F;&#x2F;回退            &#125;            if(s[i]&#x3D;&#x3D;s[j+1])&#123;&#x2F;&#x2F;前后缀相同                j++;            &#125;            next[i]&#x3D;j;&#x2F;&#x2F;j此时为前缀的长度，赋给next[i]        &#125;    &#125;        int strStr(string haystack, string needle)&#123;        if(neddle.size() &#x3D;&#x3D; 0)        &#123;            return 0;        &#125;        int next[needle,size()];        getnext(next,needle);        int j&#x3D;-1;        for(int i&#x3D;0;i&lt;haystack.size();i++)&#x2F;&#x2F;i从0开始        &#123;            while(j&gt;&#x3D;0&amp;&amp;haystack[i]!&#x3D;needle[j+1])&#x2F;&#x2F;不匹配            &#123;                j&#x3D;next[j];            &#125;            if(haystack[i] &#x3D;&#x3D; needle[j+1])&#x2F;&#x2F;匹配，同时移动            &#123;                j++;            &#125;            if(j&#x3D;&#x3D;(needle.size()-1))&#x2F;&#x2F;出现模式串            &#123;                return (i-needle.size()+1);            &#125;        &#125;        return -1;    &#125;        &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="459-重复的字符串"><a href="#459-重复的字符串" class="headerlink" title="459.重复的字符串"></a>459.重复的字符串</h3><h4 id="移动匹配"><a href="#移动匹配" class="headerlink" title="移动匹配"></a>移动匹配</h4><p>如果字符串由重复的子串组成，则s+s中必定出现一个s</p><p>其中需要用到find库函数</p><p>下面是使用方法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20215137.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123; public:         bool repeatedSubstringPattern(string s) &#123;                 string t&#x3D;s+s;                 t.erase(t.begin());                 t.erase(t.end()-1);                        if(t.find(s)!&#x3D;std::string::npos)                     return true;                  return false;         &#125; &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="KMP解法"><a href="#KMP解法" class="headerlink" title="KMP解法"></a>KMP解法</h4><p>当一个字符串由重复子串组成，最长相等前后缀不包含的字串就是最小重复子串</p><p>假设字符串s使用多个重复字串组成，重复出现的子字符串长度是x</p><p>所以s由n*x组成</p><p>因为字符串的最长相同前后缀长度一定是不包含s本身</p><p>所以最长相同前后缀长度必然是m*x</p><p>且n-m&#x3D;1</p><p>如果nx%(n-m)x&#x3D;0</p><p>就可以判定由重复出现的字符串</p><p>如果len%(len-(next[len-1]+1))&#x3D;&#x3D;0</p><p>说明数组长度可以被（数组长度-最长相等前后缀长度）整除</p><p><strong>数组长度减去最长相同前后缀的长度相当于是一个周期的长度</strong></p><p>前缀表统一减一的代码实现</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    void getNext(int* next,string&amp; s)    &#123;        next[0]&#x3D;-1;        int j&#x3D;-1;        for(int i&#x3D;1;i&lt;s.size();i++)        &#123;            while(j&gt;&#x3D;0 &amp;&amp; s[i]!&#x3D;s[j+1])            &#123;                j&#x3D;next[j];            &#125;            if(s[i]&#x3D;&#x3D;s[j+1])            &#123;                j++;            &#125;            next[i]&#x3D;j;   bool repeatSubstringPattern(string s)   &#123;       if(s.size()&#x3D;&#x3D;0)       &#123;           return false;       &#125;       int next[s.size()-1];       int len&#x3D;s.size()-1;       getNext(next,s);       if(next[len-1]!&#x3D;-1 &amp;&amp; len%(len-(next[len-1]+1)&#x3D;&#x3D;0)          &#123;              return true;          &#125;          return false;   &#125;                        &#125;               &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录-哈希表</title>
      <link href="/2023/02/12/suan-fa-shua-ti-ji-lu-ha-xi-biao/"/>
      <url>/2023/02/12/suan-fa-shua-ti-ji-lu-ha-xi-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="算法刷题记录-哈希表"><a href="#算法刷题记录-哈希表" class="headerlink" title="算法刷题记录-哈希表"></a>算法刷题记录-哈希表</h1><h3 id="哈希表理论基础"><a href="#哈希表理论基础" class="headerlink" title="哈希表理论基础"></a>哈希表理论基础</h3><p><strong>哈希函数 hash function</strong><br>$$<br>index &#x3D; hashFunction(name)<br>$$</p><p>$$<br>hashFunction &#x3D; hashCode(name)%tablesize<br>$$</p><p><strong>哈希碰撞的通常解决方法</strong>：</p><p><strong>拉链法和线性探测法</strong></p><h4 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h4><ul><li><p>数组</p></li><li><p>set</p></li><li><p>map</p></li></ul><p>unordered_set&#x2F;unordered_map底层实现为哈希表，set&#x2F;map和multiset&#x2F;multimap底层实现是红黑树，key值是有序的，只能删除和增加。</p><p>要使用集合解决哈希问题时，优先使用unordered_set，因为它的查询增删效率最优。</p><p>如果需要集合是有序的 ，那么就用set。</p><p>如果不仅要求有序还要有重复数据的话，那么就用multiset.</p><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><p><a href="https://leetcode.cn/problems/valid-anagram/">力扣题目链接</a></p><p>利用s[i]-‘a’来确定字母在数组中的位置。</p><h3 id="1002-查找常用字符"><a href="#1002-查找常用字符" class="headerlink" title="1002.查找常用字符"></a>1002.查找常用字符</h3><p><a href="https://leetcode.cn/problems/find-common-characters/">力扣题目链接</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;string&gt; commonChars(vector&lt;string&gt;&amp; A)&#123;    vector&lt;string&gt; result;    if(A.size()&#x3D;&#x3D;0) return result;    int hash[26]&#x3D;&#123;0&#125;;    for(int i&#x3D;0;i&lt;A[0].size();i++)&#123;        hash[A[0][i]-&#39;a&#39;]++;    &#125;    int hashOtherStr[26]&#x3D;&#123;0&#125;;    for(int i&#x3D;1;i&lt;A.size(),i++)&#123;        memset(hashOtherStr,0,26*sizeof(int));        for(int j&#x3D;0;j&lt;A[i].size();j++)&#123;            hashOtherStr[A[i][j]-&#39;a&#39;]++;        &#125;        for(int k&#x3D;0;k&lt;26;k++)&#123;            hash[k]&#x3D;min(hash[k],hashOtherStr[k]);        &#125;    &#125;    for(int i&#x3D;0;i&lt;26;i++)&#123;        while(hash[i]!&#x3D;0)&#123;            string s(1,i+&#39;a&#39;);            result.push_back(s);            hash[i]--;        &#125;    &#125;    return result;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349.两个数组的交集"></a>349.两个数组的交集</h3><p>使用unordered_set</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1,vector&lt;int&gt;&amp; nums2)&#123;    unordered_set result;    unordered_set nums(nums1.begin(),nums1.end())        for(int num:nums2)&#123;            if(nums.find(num)!&#x3D;nums.end())            &#123;                result.insert(num);            &#125;        &#125;    return vector&lt;int&gt;(result.begin(),result.end());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202.快乐数"></a>202.快乐数</h3><p>当我们要快速判断一个元素是否出现在集合中时，可以考虑哈希法。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int getsum(int n)&#123;    int sum&#x3D;0;    while(n)&#123;        sum+&#x3D;(n%10)*(n%10);        n&#x2F;&#x3D;10;    &#125;&#125;bool ishappy(int n)&#123;    unordered_set&lt;int&gt; set;    while(1)&#123;        int sum &#x3D; getsum(n);        if(sum&#x3D;&#x3D;1) return true;        if(set.find(sum)!&#x3D;set.end())&#123;            return false;        &#125;else&#123;            set.insert(sum);        &#125;        n&#x3D;sum;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::unordered_map map;for(int i&#x3D;0;i&lt;nums.size(),i++)&#123;    auto iter&#x3D;map.find(target&#x3D;nums[i]);    if(iter!&#x3D;map.end())    &#123;        return &#123;iter-&gt;second,i&#125;;    &#125;    map.insert(pair&lt;int,int&gt;(nums[i],i));&#125;return &#123;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="454-四数相加Ⅱ"><a href="#454-四数相加Ⅱ" class="headerlink" title="454.四数相加Ⅱ"></a>454.四数相加Ⅱ</h3><p>首先定义一个unordered_map，key放ab两数之和，value放出现次数。</p><p>遍历AB两数组，统计两数组元素之和和出现的次数。</p><p>遍历CD数组，找到如果0-(c+d)在map中出现过的话，统计次数。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int foursumcount(vector&lt;int&gt;&amp;A ,vector&lt;int&gt;&amp;B, vector&lt;int&gt;&amp;C ,vector&lt;int&gt;&amp;D)&#123;    unordered_map&lt;int,int&gt; map;    for(int a:A)    &#123;        for(int b:B)        &#123;            map[a+b]++;        &#125;                &#125;    int count&#x3D;0;    for(int c:C)    &#123;        for(int d:D)        &#123;            if(map.find(0-(c+d))!&#x3D;map.end())            &#123;                count+&#x3D;map[0-(c+d)];            &#125;                    &#125;    &#125;    return count;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool canConstruct(string ransomNote, string magazine)&#123;    int record[26]&#x3D;&#123;0&#125;;    if(ransomNote.size()&gt;magazine.size())        return false;    for(int i&#x3D;0;i&lt;magazine.size();i++)    &#123;        record[magazine[i]-&#39;a&#39;]++;    &#125;    for(int j&#x3D;0;j&lt;ransomNote.size();j++)    &#123;        record[ransomNote[j]-&#39;a&#39;]--;        if(record[ransomNote[j]-&#39;a&#39;]&lt;0)            return false;    &#125;    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums)&#123;    vector&lt;vector&lt;int&gt;&gt; result;    sort(nums.begin(),nums.end());    for(int i&#x3D;0;i&lt;nums.size();i++)    &#123;        if(nums[i]&gt;0) break;        if(i&gt;0 &amp;&amp; nums[i]&#x3D;&#x3D;nums[i-1]) contunue;        unordered_set&lt;int&gt; set;        for(int j&#x3D;i+1;j&lt;nums.size();j++)&#123;            if(j&gt;i+2&amp;&amp;nums[j]&#x3D;&#x3D;nums[j-1]&amp;&amp;nums[j-1]&#x3D;&#x3D;nums[j-2])                contunue;            int c&#x3D;0-(nums[i]+nums[j]);            if(set.find(c)!&#x3D;set.end())&#123;                result.push_back(&#123;nums[i],nums[j],c&#125;);                set.erese(c);            &#125;else&#123;                set.insert(nums[j]);            &#125;        &#125;    &#125;    return result;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>双指针法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums)&#123;    vector&lt;vector&lt;int&gt;&gt; result;    sort(nums.begin(),nums.end());    for(int i&#x3D;0;i&lt;nums.size();i++)    &#123;        if(nums[i]&gt;0&amp;&amp;i&#x3D;0) return result;        if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1]) continue;            &#125;    int left&#x3D;i+1;    int right&#x3D;nums.size()-1;    while(right&gt;left)    &#123;        if(nums[i]+nums[left]+nums[right]&gt;0) right--;        else if(nums[i]+nums[left]+nums[right]&lt;0) left++;        else&#123;            result.push_back(vector&lt;int&gt;&#123;nums[i],nums[left],nums[right]&#125;);            whlie(right&gt;left &amp;&amp; nums[right]&#x3D;&#x3D;nums[right-1]) right--;            whlie(right&gt;left &amp;&amp; nums[left]&#x3D;&#x3D;nums[left++]) left++;                        right--;            left++;                    &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录—链表</title>
      <link href="/2023/02/11/suan-fa-shua-ti-ji-lu-lian-biao/"/>
      <url>/2023/02/11/suan-fa-shua-ti-ji-lu-lian-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">力扣题目链接</a></p><ul><li><p><strong>直接使用原来的链表进行删除操作</strong></p></li><li><p><strong>设置一个虚拟头节点在进行操作</strong></p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        ListNode* dummyHead &#x3D; new ListNode(0); &#x2F;&#x2F; 设置一个虚拟头结点        dummyHead-&gt;next &#x3D; head; &#x2F;&#x2F; 将虚拟头结点指向head，这样方面后面做删除操作        ListNode* cur &#x3D; dummyHead;        while (cur-&gt;next !&#x3D; NULL) &#123;            if(cur-&gt;next-&gt;val &#x3D;&#x3D; val) &#123;                ListNode* tmp &#x3D; cur-&gt;next;                cur-&gt;next &#x3D; cur-&gt;next-&gt;next;                delete tmp;            &#125; else &#123;                cur &#x3D; cur-&gt;next;            &#125;        &#125;        head &#x3D; dummyHead-&gt;next;        delete dummyHead;        return head;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><p><a href="https://leetcode.cn/problems/design-linked-list/">力扣题目链接</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;定义链表结构体struct LinkedNode&#123;    int val;    LinkedNode* next;    LinkedNode(int val):val(val),next(nullptr)&#123;&#125;    &#125;;MyLinkedList()&#123;    _dummyhead &#x3D; new LinkedNode(0);    _size&#x3D;0;&#125;int get(int index)&#123;    if(index &gt; (_size - 1)||index&lt;0)&#123;        return -1;    &#125;    LinkedNode* cur &#x3D; _dummyhead-&gt;next;    while(index--)&#123;        cur &#x3D; cur-&gt;next;    &#125;    return cur-&gt;val;&#125;void addAtHead(int val)&#123;    LinkedNode* newnode &#x3D; new LinkedNode(val);    newnode-&gt;next&#x3D;_dummyhead-&gt;next;    _dummyhead-&gt;next&#x3D;newnode;    _size++;&#125;void addAtTail(int val)&#123;    LinkedNode* newnode &#x3D; new LinkedNode(val);    LinkedNode* cur &#x3D; _dummyhead;    whlie(cur-&gt;next !&#x3D; nullptr)&#123;        cur &#x3D; cur-&gt;next;    &#125;    cur-&gt;next &#x3D; newnode;   _size++; &#125;void addAtIndex(int index, int val)&#123;    if(index &gt; _size) return;    if(index &lt; 0) index&#x3D;0;    LinkedNode* newnode &#x3D; new LinkedNode(val);    LinkedNode* cur &#x3D; _dummyhead;    whlie(index--)&#123;        cur&#x3D;cur-&gt;next;    &#125;    newnode-&gt;next &#x3D; cur-&gt;next;    cur-&gt;next &#x3D; newnode;    _size++;    &#125;void deleteAtIndex(int index)&#123;    if(index &gt;&#x3D; _size || index &lt; 0)&#123;        return;    &#125;    LinkedNode* cur &#x3D; _dunnyhead;    while(index--)&#123;        cur&#x3D;cur-&gt;next;    &#125;    LinkedNode* tmp &#x3D; cur-&gt;next;    cur-&gt;next &#x3D; cur-&gt;next-&gt;next;    delete tmp;    _size--;&#125;private: int _size; LinkedNode* _dummyhead;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/">力扣题目链接</a></p><p><strong>双指针法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">LinkNode* reverseList(ListNode* head)&#123;    ListNode* temp;    ListNode* cur &#x3D; head;    ListNode* pre &#x3D; nullptr;    while(cur)&#123;        temp &#x3D; cur-&gt;next;        pre &#x3D; cur;        cur &#x3D; temp;    &#125;    return pre;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>递归法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode* reverse(ListNOde* pre, ListNode* cur)&#123;    if(cur&#x3D;&#x3D;nullptr) return pre    ListNode* temp &#x3D; cur-&gt;next;    cur-&gt;next &#x3D; pre;    return reverse(cur, temp);&#125;ListNode* reverseList(ListNode* head)&#123;    return reverse(nullptr,head);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="19-删除链表倒数第n个结点"><a href="#19-删除链表倒数第n个结点" class="headerlink" title="19.删除链表倒数第n个结点"></a>19.删除链表倒数第n个结点</h3><p><strong>双指针法</strong></p><p>添加虚拟头节点</p><p>fast指针向后移动n+1步</p><p>fast和slow同时移动至fast指针指向末尾</p><p>删除slow后面的节点</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode* dummyhead&#x3D;new ListNode(0);dummyhead-&gt;next&#x3D;head;ListNode* fast&#x3D;dummyhead;ListNode* slow&#x3D;dummyhead;while(n-- &amp;&amp; fast!&#x3D;nullptr)&#123;    fast&#x3D;fast-&gt;next;&#125;fast-fast-&gt;next;while(fast!&#x3D;nullptr)&#123;    fast&#x3D;fast-&gt;next;    slow&#x3D;slow-&gt;next;&#125;slow-&gt;next&#x3D;slow-&gt;next-&gt;next;return dummyhead-&gt;next;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h3><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">力扣题目链接</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode* dummyhead&#x3D;new ListNode(0);dummyhead-&gt;next&#x3D;head;ListNode* cur&#x3D;dummyhead;while(cur-&gt;next !&#x3D; nullptr &amp;&amp; cur-&gt;next-&gt;next !&#x3D; nuulptr)&#123;    ListNode* temp1&#x3D;cur-&gt;next;  ListNode* temp2&#x3D;cur-&gt;next-&gt;next-&gt;next;    cur-&gt;next&#x3D;cur-&gt;next-&gt;next;    cur-&gt;next-&gt;next&#x3D;temp1;    cur-&gt;next-&gt;next-&gt;next&#x3D;temp2;    &#125;return dummyhead-&gt;next;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="160-链表相交"><a href="#160-链表相交" class="headerlink" title="160.链表相交"></a>160.链表相交</h3><p>计算两链表的长度</p><p>求出长度差值</p><p>让指针移动到末尾对其的位置</p><p>比较两指针是否相同，不相同则后移</p><p>直至两指针相等</p><h3 id="142-环形链表"><a href="#142-环形链表" class="headerlink" title="142.环形链表"></a>142.环形链表</h3><p><strong>双指针法</strong></p><p>fast走两个节点，slow走一个节点</p><p><strong>fast指针先进入环中，fast与slow一定在换环中相遇。</strong></p><p><strong>相对于slow来说，fast是一步步靠近slow的</strong></p><h4 id="如何找到环的入口"><a href="#如何找到环的入口" class="headerlink" title="如何找到环的入口"></a>如何找到环的入口</h4><p>从头节点出发一个指针，从相遇节点也出发一个指针，每次均走一个节点，两个指针相遇时就是环形入口的节点。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode* fast&#x3D;head;ListNode* slow&#x3D;head;while(fast!&#x3D;nullptr&amp;&amp;fast-&gt;next!&#x3D;nullptr)&#123;    slow&#x3D;slow-&gt;next;    fast&#x3D;fast-&gt;next-&gt;next;    if(slow&#x3D;&#x3D;fast)    &#123;        ListNode* index1&#x3D;fast;        ListNode* index2&#x3D;head;        while(index1!&#x3D;index2)        &#123;            index1&#x3D;index1-&gt;next;            index2&#x3D;index2-&gt;next;        &#125;        return index2;    &#125;&#125;return NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题基础—数组</title>
      <link href="/2023/02/10/suan-fa-shua-ti-ji-lu-shu-zu/"/>
      <url>/2023/02/10/suan-fa-shua-ti-ji-lu-shu-zu/</url>
      
        <content type="html"><![CDATA[<h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h3><p><a href="https://leetcode.cn/problems/binary-search/">力扣题目链接</a></p><p>二分法的两种写法：</p><ul><li><p>定义target在左闭右闭的区间里</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int low &#x3D; 0;        int high &#x3D; nums.size() - 1;         while (low &lt;&#x3D; high)         &#123;             int middle &#x3D; low + ((high - low) &#x2F; 2);&#x2F;&#x2F; 防止溢出             if (nums[middle] &gt; target) &#123;                high &#x3D; middle - 1;            &#125; else if (nums[middle] &lt; target) &#123;                left &#x3D; middle + 1;             &#125; else            &#123;                return middle;             &#125;        &#125;                return -1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>定义target在一个左闭右开的区间里</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int low &#x3D; 0;        int high &#x3D; nums.size();         while (low &lt; high) &#123;             int middle &#x3D; low + ((high - low) &gt;&gt; 1);            if (nums[middle] &gt; target) &#123;                high &#x3D; middle;             &#125; else if (nums[middle] &lt; target) &#123;                low &#x3D; middle + 1;             &#125; else &#123;                 return middle;             &#125;        &#125;              return -1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="74-移除元素"><a href="#74-移除元素" class="headerlink" title="74.移除元素"></a>74.移除元素</h3><p><a href="https://leetcode.cn/problems/remove-element/">力扣题目链接</a></p><ul><li><p>暴力求解</p></li><li><p>双指针法：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作</p><p>快指针：寻找新数组的元素，新数组就是不含有目标元素的数组。</p><p>慢指针：指向更新新数组下标的位置。</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><p><strong>双指针法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int slowIndex &#x3D; 0;        for (int fastIndex &#x3D; 0; fastIndex &lt; nums.size(); fastIndex++) &#123;            if (val !&#x3D; nums[fastIndex]) &#123;                nums[slowIndex++] &#x3D; nums[fastIndex];            &#125;        &#125;        return slowIndex;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>相向双指针法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int leftIndex &#x3D; 0;        int rightIndex &#x3D; nums.size() - 1;        while (leftIndex &lt;&#x3D; rightIndex) &#123;            &#x2F;&#x2F; 找左边等于val的元素            while (leftIndex &lt;&#x3D; rightIndex &amp;&amp; nums[leftIndex] !&#x3D; val)&#123;                ++leftIndex;            &#125;            &#x2F;&#x2F; 找右边不等于val的元素            while (leftIndex &lt;&#x3D; rightIndex &amp;&amp; nums[rightIndex] &#x3D;&#x3D; val) &#123;                -- rightIndex;            &#125;            &#x2F;&#x2F; 将右边不等于val的元素覆盖左边等于val的元素            if (leftIndex &lt; rightIndex) &#123;                nums[leftIndex++] &#x3D; nums[rightIndex--];            &#125;        &#125;        return leftIndex;   &#x2F;&#x2F; leftIndex一定指向了最终数组末尾的下一个元素    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">力扣题目链接</a></p><p><strong>双指针法</strong></p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p><p>2</p><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">力扣题目链接</a></p><p><strong>滑动窗口</strong></p><p>不断的调节子序列的起始位置和终止位置，从而得出结果。</p><h3 id="59-螺旋矩阵"><a href="#59-螺旋矩阵" class="headerlink" title="59.螺旋矩阵"></a>59.螺旋矩阵</h3><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">力扣题目链接</a></p><p><strong>四条边要坚持左闭右开或者左开右闭的原则</strong></p><p>完整代码如下</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;        vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0)); &#x2F;&#x2F; 使用vector定义一个二维数组        int startx &#x3D; 0, starty &#x3D; 0; &#x2F;&#x2F; 定义每循环一个圈的起始位置        int loop &#x3D; n &#x2F; 2; &#x2F;&#x2F; 每个圈循环几次，例如n为奇数3，那么loop &#x3D; 1 只是循环一圈，矩阵中间的值需要单独处理        int mid &#x3D; n &#x2F; 2; &#x2F;&#x2F; 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)        int count &#x3D; 1; &#x2F;&#x2F; 用来给矩阵中每一个空格赋值        int offset &#x3D; 1; &#x2F;&#x2F; 需要控制每一条边遍历的长度，每次循环右边界收缩一位        int i,j;        while (loop --) &#123;            i &#x3D; startx;            j &#x3D; starty;            &#x2F;&#x2F; 下面开始的四个for就是模拟转了一圈            &#x2F;&#x2F; 模拟填充上行从左到右(左闭右开)            for (j &#x3D; starty; j &lt; n - offset; j++) &#123;                res[startx][j] &#x3D; count++;            &#125;            &#x2F;&#x2F; 模拟填充右列从上到下(左闭右开)            for (i &#x3D; startx; i &lt; n - offset; i++) &#123;                res[i][j] &#x3D; count++;            &#125;            &#x2F;&#x2F; 模拟填充下行从右到左(左闭右开)            for (; j &gt; starty; j--) &#123;                res[i][j] &#x3D; count++;            &#125;            &#x2F;&#x2F; 模拟填充左列从下到上(左闭右开)            for (; i &gt; startx; i--) &#123;                res[i][j] &#x3D; count++;            &#125;            &#x2F;&#x2F; 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)            startx++;            starty++;            &#x2F;&#x2F; offset 控制每一圈里每一条边遍历的长度            offset +&#x3D; 1;        &#125;        &#x2F;&#x2F; 如果n为奇数的话，需要单独给矩阵最中间的位置赋值        if (n % 2) &#123;            res[mid][mid] &#x3D; count;        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP学习记录(1)</title>
      <link href="/2023/02/05/csapp-xue-xi-ji-lu/"/>
      <url>/2023/02/05/csapp-xue-xi-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="CSAPP——第二章"><a href="#CSAPP——第二章" class="headerlink" title="CSAPP——第二章"></a>CSAPP——第二章</h1><h2 id="2-2整数表示"><a href="#2-2整数表示" class="headerlink" title="2.2整数表示"></a>2.2整数表示</h2><h3 id="2-2-2无符号数的编码"><a href="#2-2-2无符号数的编码" class="headerlink" title="2.2.2无符号数的编码"></a>2.2.2无符号数的编码</h3><p>无符号数编码的定义</p><p>对向量$ \vec{x} $:<br>$$<br>B2U_{w}(\vec{x})&#x3D;\sum_{i&#x3D;0}^{w-1} x_{i}2^{i} \text(Binary to Unsigned)<br>$$<br>函数$ B2U_w $将一个长度为w的0、1串映射到非负整数。</p><p>函数$  B2U_w $是一个双射。</p><h3 id="2-2-3补码编码"><a href="#2-2-3补码编码" class="headerlink" title="2.2.3补码编码"></a>2.2.3补码编码</h3><p>最常见的有符号数的计算机表示方式就是__补码__。在这个定义中，将字的最高有效为解释为负权。用函数$ B2T_w $表示。</p><p>补码编码的定义</p><p>对向量$ \vec{x} $:<br>$$<br>B2T_w(\vec{x})&#x3D;-x_{w-1}+\sum_{i&#x3D;0}^{w-2} x_i2^i \text(BinarytoTwo’s-complement)<br>$$<br>最高有效位成为符号位，权重为$ -2_{w-1} $。</p><p>符号位被设置为1，表示值为负；设置为0，值为正。</p><p>最小整数值是<br>$$<br>TMin_w&#x3D;-2^{w-1}<br>$$<br>最大整数值是<br>$$<br>TMax_w&#x3D;2^{w-1}-1<br>$$<br>补码的范围是不对称的<br>$$<br>|TMin|&#x3D;|TMax|+1<br>$$<br>也就是说，TMin没有与之对应的正数。</p><p>最大的无符号数值刚好比补码的最大值的两倍大一点<br>$$<br>UMax_w&#x3D;2TMax_w+1<br>$$<br>-1是一个全1的串，0是一个全0的串。</p><p>C库中的文件&lt;limit.h&gt;定义了常量INT_MAX,INT_MIN,UINT_MAX。对于一个补码的机器，这些常量就对应TMax,TMin,UMax的值。</p><blockquote><p>有符号数的其他表示方法</p><p>反码<br>$$<br>B2O_w(\vec{x})&#x3D;-x_{w-1}(2_{w-1}-1)+\sum_{i&#x3D;0}^{w-2}x_{i}2^i<br>$$<br>原码<br>$$<br>B2S_w(\vec{x})&#x3D;(-1)^{x_{w-1}}*(\sum_{i&#x3D;0}^{w-2}x_i2^i)<br>$$</p></blockquote><h3 id="2-2-4有符号数与无符号数的转换"><a href="#2-2-4有符号数与无符号数的转换" class="headerlink" title="2.2.4有符号数与无符号数的转换"></a>2.2.4有符号数与无符号数的转换</h3><p>强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。</p><p>对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。</p><p>补码转换为无符号数</p><p>对满足TMin&lt;&#x3D;x&lt;&#x3D;TMax的x有<br>$$<br>T2U_w(x)&#x3D;x+2^w,x&lt;0<br>$$</p><p>$$<br>T2U_w(x)&#x3D;x,x&gt;&#x3D;0<br>$$</p><p>当一个有符号数映射为它相应的无符号数时，负数就被转换成了大的正数，而非负数会保持不变。</p><p>无符号数转换为补码</p><p>对满足0&lt;&#x3D;u&lt;&#x3D;UMax的u有<br>$$<br>U2T_w(u)&#x3D;u,u&lt;&#x3D;TMax_w<br>$$</p><p>$$<br>U2T_w(u)&#x3D;u-2^w,u&gt;TMax_w<br>$$</p><p>对于小的数(&lt;&#x3D;TMax),从无符号数到有符号数的转换将保留数字的原值。</p><p>对于大的数( &gt;TMax),数字将被转换为一个负数值。</p><p><strong>考虑无符号与补码表示之间相互转换的结果</strong></p><p>对于在范围0&lt;&#x3D;x&lt;&#x3D;TMax之内的值x而言，我们得到T2U(x)&#x3D;x和U2T(x)&#x3D;x。也就是说，在这个范围内的数字有相同的无符号和补码表示。</p><p>对于这个范围以外的数字，转换需要加上或者减去$ 2_w $</p><h3 id="2-2-5C语言中的有符号数与无符号数"><a href="#2-2-5C语言中的有符号数与无符号数" class="headerlink" title="2.2.5C语言中的有符号数与无符号数"></a>2.2.5C语言中的有符号数与无符号数</h3><p>当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。</p><p>这种方法对于标准的算数运算来说并无多大差异，但是对于&lt;&gt;这样的关系运算符来说，它会导致非直观的结果。</p><h3 id="2-2-6扩展一个数字的位表示"><a href="#2-2-6扩展一个数字的位表示" class="headerlink" title="2.2.6扩展一个数字的位表示"></a>2.2.6扩展一个数字的位表示</h3><p>要将一个无符号数转换为一个更大的数据类型，只要简单的在表示的开头添加0，这种运算被称为零扩展。</p><p>要将补码数字转换为一个更大的数据类型，可以执行一个符号扩展（将符号位填补前面空余位）。</p><p>数据类型转换时，要先转换大小，再完成符号的转换。</p><h3 id="2-2-7截断数字"><a href="#2-2-7截断数字" class="headerlink" title="2.2.7截断数字"></a>2.2.7截断数字</h3><p>截断无符号数<br>$$<br>x^<code>=xmod2^k $$ 截断补码数值 $$ x^</code>&#x3D;U2T_k(xmod2^k)<br>$$</p><h3 id="2-2-8关于有符号数与无符号数的建议"><a href="#2-2-8关于有符号数与无符号数的建议" class="headerlink" title="2.2.8关于有符号数与无符号数的建议"></a>2.2.8关于有符号数与无符号数的建议</h3><h2 id="2-3整数运算"><a href="#2-3整数运算" class="headerlink" title="2.3整数运算"></a>2.3整数运算</h2><h3 id="2-3-1无符号加法"><a href="#2-3-1无符号加法" class="headerlink" title="2.3.1无符号加法"></a>2.3.1无符号加法</h3><p><strong>无符号加法</strong></p><p>对满足$ 0&lt;&#x3D;x,y&lt;2_w $的x和y有：<br>$$<br>x+y&#x3D;x+y,  x+y&lt;2^w<br>$$</p><p>$$<br>x+y&#x3D;x+y-2^w,2^w&lt;&#x3D;x+y&lt;&#x3D;2^{w+1}<br>$$</p><p><strong>检测无符号数加法中的溢出</strong></p><p>对在范围0&lt;&#x3D;x,y&lt;&#x3D;UMax,中的x和y，令s&#x3D;x+y。当且仅当s&lt;x(或者等价的s&lt;y)时发生了溢出。   </p><h3 id="2-3-2补码加法"><a href="#2-3-2补码加法" class="headerlink" title="2.3.2补码加法"></a>2.3.2补码加法</h3><p>当和x+y超过TMax时，我们说发生了正溢出，截断的结果是从和数中减去$ 2_w $；当和x+y小于TMin时，我们说发生了负溢出，截断的结果是把和数加上$ 2_w $。</p><p><strong>检测补码加法中的溢出</strong></p><p>对满足TMin&lt;&#x3D;x,y&lt;&#x3D;TMax的x和y，令s&#x3D;x+y，当且仅当x&gt;0,y&gt;0,但s&lt;&#x3D;0时，计算s发生了正溢出。当且仅当x&lt;0,y&lt;0,但s&gt;&#x3D;0时，计算s发生了负溢出。</p><h3 id="2-3-3补码的非"><a href="#2-3-3补码的非" class="headerlink" title="2.3.3补码的非"></a>2.3.3补码的非</h3><p>对w位的补码加法来说，TMin是自己的加法的逆。而对其他任何数值x都有-x作为其加法的逆。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>美赛绘图介绍</title>
      <link href="/2023/02/05/mei-sai-hui-tu-jie-shao/"/>
      <url>/2023/02/05/mei-sai-hui-tu-jie-shao/</url>
      
        <content type="html"><![CDATA[<h1 id="美赛绘图介绍"><a href="#美赛绘图介绍" class="headerlink" title="美赛绘图介绍"></a>美赛绘图介绍</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h3><p><a href="https://mycolor.space/">colorspace</a></p><h3 id="图片素材"><a href="#图片素材" class="headerlink" title="图片素材"></a>图片素材</h3><p><a href="https://www.freepik.com/">freepic</a></p><h3 id="python画图"><a href="#python画图" class="headerlink" title="python画图"></a>python画图</h3><p><a href="https://zhuanlan.zhihu.com/p/81553421?utm_source=wechat_session">seaborn库</a></p><h3 id="绘图网站"><a href="#绘图网站" class="headerlink" title="绘图网站"></a>绘图网站</h3><p><a href="https://www.bioladder.cn/web/#/pro/index">bioladder</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/02/03/hello-world/"/>
      <url>/2023/02/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
