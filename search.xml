<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/02/11/suan-fa-shua-ti-ji-lu-lian-biao/"/>
      <url>/2023/02/11/suan-fa-shua-ti-ji-lu-lian-biao/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-算法刷题记录—链表"><a href="#title-算法刷题记录—链表" class="headerlink" title="title:算法刷题记录—链表"></a>title:算法刷题记录—链表</h2><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">力扣题目链接</a></p><ul><li><p><strong>直接使用原来的链表进行删除操作</strong></p></li><li><p><strong>设置一个虚拟头节点在进行操作</strong></p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        ListNode* dummyHead &#x3D; new ListNode(0); &#x2F;&#x2F; 设置一个虚拟头结点        dummyHead-&gt;next &#x3D; head; &#x2F;&#x2F; 将虚拟头结点指向head，这样方面后面做删除操作        ListNode* cur &#x3D; dummyHead;        while (cur-&gt;next !&#x3D; NULL) &#123;            if(cur-&gt;next-&gt;val &#x3D;&#x3D; val) &#123;                ListNode* tmp &#x3D; cur-&gt;next;                cur-&gt;next &#x3D; cur-&gt;next-&gt;next;                delete tmp;            &#125; else &#123;                cur &#x3D; cur-&gt;next;            &#125;        &#125;        head &#x3D; dummyHead-&gt;next;        delete dummyHead;        return head;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><p><a href="https://leetcode.cn/problems/design-linked-list/">力扣题目链接</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;定义链表结构体struct LinkedNode&#123;    int val;    LinkedNode* next;    LinkedNode(int val):val(val),next(nullptr)&#123;&#125;    &#125;;MyLinkedList()&#123;    _dummyhead &#x3D; new LinkedNode(0);    _size&#x3D;0;&#125;int get(int index)&#123;    if(index &gt; (_size - 1)||index&lt;0)&#123;        return -1;    &#125;    LinkedNode* cur &#x3D; _dummyhead-&gt;next;    while(index--)&#123;        cur &#x3D; cur-&gt;next;    &#125;    return cur-&gt;val;&#125;void addAtHead(int val)&#123;    LinkedNode* newnode &#x3D; new LinkedNode(val);    newnode-&gt;next&#x3D;_dummyhead-&gt;next;    _dummyhead-&gt;next&#x3D;newnode;    _size++;&#125;void addAtTail(int val)&#123;    LinkedNode* newnode &#x3D; new LinkedNode(val);    LinkedNode* cur &#x3D; _dummyhead;    whlie(cur-&gt;next !&#x3D; nullptr)&#123;        cur &#x3D; cur-&gt;next;    &#125;    cur-&gt;next &#x3D; newnode;   _size++; &#125;void addAtIndex(int index, int val)&#123;    if(index &gt; _size) return;    if(index &lt; 0) index&#x3D;0;    LinkedNode* newnode &#x3D; new LinkedNode(val);    LinkedNode* cur &#x3D; _dummyhead;    whlie(index--)&#123;        cur&#x3D;cur-&gt;next;    &#125;    newnode-&gt;next &#x3D; cur-&gt;next;    cur-&gt;next &#x3D; newnode;    _size++;    &#125;void deleteAtIndex(int index)&#123;    if(index &gt;&#x3D; _size || index &lt; 0)&#123;        return;    &#125;    LinkedNode* cur &#x3D; _dunnyhead;    while(index--)&#123;        cur&#x3D;cur-&gt;next;    &#125;    LinkedNode* tmp &#x3D; cur-&gt;next;    cur-&gt;next &#x3D; cur-&gt;next-&gt;next;    delete tmp;    _size--;&#125;private: int _size; LinkedNode* _dummyhead;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/">力扣题目链接</a></p><p><strong>双指针法</strong></p><p><strong>递归法</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题基础—数组</title>
      <link href="/2023/02/10/suan-fa-shua-ti-ji-lu-shu-zu/"/>
      <url>/2023/02/10/suan-fa-shua-ti-ji-lu-shu-zu/</url>
      
        <content type="html"><![CDATA[<h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h3><p><a href="https://leetcode.cn/problems/binary-search/">力扣题目链接</a></p><p>二分法的两种写法：</p><ul><li><p>定义target在左闭右闭的区间里</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int low &#x3D; 0;        int high &#x3D; nums.size() - 1;         while (low &lt;&#x3D; high)         &#123;             int middle &#x3D; low + ((high - low) &#x2F; 2);&#x2F;&#x2F; 防止溢出             if (nums[middle] &gt; target) &#123;                high &#x3D; middle - 1;            &#125; else if (nums[middle] &lt; target) &#123;                left &#x3D; middle + 1;             &#125; else            &#123;                return middle;             &#125;        &#125;                return -1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>定义target在一个左闭右开的区间里</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int low &#x3D; 0;        int high &#x3D; nums.size();         while (low &lt; high) &#123;             int middle &#x3D; low + ((high - low) &gt;&gt; 1);            if (nums[middle] &gt; target) &#123;                high &#x3D; middle;             &#125; else if (nums[middle] &lt; target) &#123;                low &#x3D; middle + 1;             &#125; else &#123;                 return middle;             &#125;        &#125;              return -1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="74-移除元素"><a href="#74-移除元素" class="headerlink" title="74.移除元素"></a>74.移除元素</h3><p><a href="https://leetcode.cn/problems/remove-element/">力扣题目链接</a></p><ul><li><p>暴力求解</p></li><li><p>双指针法：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作</p><p>快指针：寻找新数组的元素，新数组就是不含有目标元素的数组。</p><p>慢指针：指向更新新数组下标的位置。</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><p><strong>双指针法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int slowIndex &#x3D; 0;        for (int fastIndex &#x3D; 0; fastIndex &lt; nums.size(); fastIndex++) &#123;            if (val !&#x3D; nums[fastIndex]) &#123;                nums[slowIndex++] &#x3D; nums[fastIndex];            &#125;        &#125;        return slowIndex;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>相向双指针法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int leftIndex &#x3D; 0;        int rightIndex &#x3D; nums.size() - 1;        while (leftIndex &lt;&#x3D; rightIndex) &#123;            &#x2F;&#x2F; 找左边等于val的元素            while (leftIndex &lt;&#x3D; rightIndex &amp;&amp; nums[leftIndex] !&#x3D; val)&#123;                ++leftIndex;            &#125;            &#x2F;&#x2F; 找右边不等于val的元素            while (leftIndex &lt;&#x3D; rightIndex &amp;&amp; nums[rightIndex] &#x3D;&#x3D; val) &#123;                -- rightIndex;            &#125;            &#x2F;&#x2F; 将右边不等于val的元素覆盖左边等于val的元素            if (leftIndex &lt; rightIndex) &#123;                nums[leftIndex++] &#x3D; nums[rightIndex--];            &#125;        &#125;        return leftIndex;   &#x2F;&#x2F; leftIndex一定指向了最终数组末尾的下一个元素    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">力扣题目链接</a></p><p><strong>双指针法</strong></p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p><p>2</p><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">力扣题目链接</a></p><p><strong>滑动窗口</strong></p><p>不断的调节子序列的起始位置和终止位置，从而得出结果。</p><h3 id="59-螺旋矩阵"><a href="#59-螺旋矩阵" class="headerlink" title="59.螺旋矩阵"></a>59.螺旋矩阵</h3><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">力扣题目链接</a></p><p><strong>四条边要坚持左闭右开或者左开右闭的原则</strong></p><p>完整代码如下</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;        vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0)); &#x2F;&#x2F; 使用vector定义一个二维数组        int startx &#x3D; 0, starty &#x3D; 0; &#x2F;&#x2F; 定义每循环一个圈的起始位置        int loop &#x3D; n &#x2F; 2; &#x2F;&#x2F; 每个圈循环几次，例如n为奇数3，那么loop &#x3D; 1 只是循环一圈，矩阵中间的值需要单独处理        int mid &#x3D; n &#x2F; 2; &#x2F;&#x2F; 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)        int count &#x3D; 1; &#x2F;&#x2F; 用来给矩阵中每一个空格赋值        int offset &#x3D; 1; &#x2F;&#x2F; 需要控制每一条边遍历的长度，每次循环右边界收缩一位        int i,j;        while (loop --) &#123;            i &#x3D; startx;            j &#x3D; starty;            &#x2F;&#x2F; 下面开始的四个for就是模拟转了一圈            &#x2F;&#x2F; 模拟填充上行从左到右(左闭右开)            for (j &#x3D; starty; j &lt; n - offset; j++) &#123;                res[startx][j] &#x3D; count++;            &#125;            &#x2F;&#x2F; 模拟填充右列从上到下(左闭右开)            for (i &#x3D; startx; i &lt; n - offset; i++) &#123;                res[i][j] &#x3D; count++;            &#125;            &#x2F;&#x2F; 模拟填充下行从右到左(左闭右开)            for (; j &gt; starty; j--) &#123;                res[i][j] &#x3D; count++;            &#125;            &#x2F;&#x2F; 模拟填充左列从下到上(左闭右开)            for (; i &gt; startx; i--) &#123;                res[i][j] &#x3D; count++;            &#125;            &#x2F;&#x2F; 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)            startx++;            starty++;            &#x2F;&#x2F; offset 控制每一圈里每一条边遍历的长度            offset +&#x3D; 1;        &#125;        &#x2F;&#x2F; 如果n为奇数的话，需要单独给矩阵最中间的位置赋值        if (n % 2) &#123;            res[mid][mid] &#x3D; count;        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP学习记录(1)</title>
      <link href="/2023/02/05/csapp-xue-xi-ji-lu/"/>
      <url>/2023/02/05/csapp-xue-xi-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="CSAPP——第二章"><a href="#CSAPP——第二章" class="headerlink" title="CSAPP——第二章"></a>CSAPP——第二章</h1><h2 id="2-2整数表示"><a href="#2-2整数表示" class="headerlink" title="2.2整数表示"></a>2.2整数表示</h2><h3 id="2-2-2无符号数的编码"><a href="#2-2-2无符号数的编码" class="headerlink" title="2.2.2无符号数的编码"></a>2.2.2无符号数的编码</h3><p>无符号数编码的定义</p><p>对向量$ \vec{x} $:<br>$$<br>B2U_{w}(\vec{x})&#x3D;\sum_{i&#x3D;0}^{w-1} x_{i}2^{i} \text(Binary to Unsigned)<br>$$<br>函数$ B2U_w $将一个长度为w的0、1串映射到非负整数。</p><p>函数$  B2U_w $是一个双射。</p><h3 id="2-2-3补码编码"><a href="#2-2-3补码编码" class="headerlink" title="2.2.3补码编码"></a>2.2.3补码编码</h3><p>最常见的有符号数的计算机表示方式就是__补码__。在这个定义中，将字的最高有效为解释为负权。用函数$ B2T_w $表示。</p><p>补码编码的定义</p><p>对向量$ \vec{x} $:<br>$$<br>B2T_w(\vec{x})&#x3D;-x_{w-1}+\sum_{i&#x3D;0}^{w-2} x_i2^i \text(BinarytoTwo’s-complement)<br>$$<br>最高有效位成为符号位，权重为$ -2_{w-1} $。</p><p>符号位被设置为1，表示值为负；设置为0，值为正。</p><p>最小整数值是<br>$$<br>TMin_w&#x3D;-2^{w-1}<br>$$<br>最大整数值是<br>$$<br>TMax_w&#x3D;2^{w-1}-1<br>$$<br>补码的范围是不对称的<br>$$<br>|TMin|&#x3D;|TMax|+1<br>$$<br>也就是说，TMin没有与之对应的正数。</p><p>最大的无符号数值刚好比补码的最大值的两倍大一点<br>$$<br>UMax_w&#x3D;2TMax_w+1<br>$$<br>-1是一个全1的串，0是一个全0的串。</p><p>C库中的文件&lt;limit.h&gt;定义了常量INT_MAX,INT_MIN,UINT_MAX。对于一个补码的机器，这些常量就对应TMax,TMin,UMax的值。</p><blockquote><p>有符号数的其他表示方法</p><p>反码<br>$$<br>B2O_w(\vec{x})&#x3D;-x_{w-1}(2_{w-1}-1)+\sum_{i&#x3D;0}^{w-2}x_{i}2^i<br>$$<br>原码<br>$$<br>B2S_w(\vec{x})&#x3D;(-1)^{x_{w-1}}*(\sum_{i&#x3D;0}^{w-2}x_i2^i)<br>$$</p></blockquote><h3 id="2-2-4有符号数与无符号数的转换"><a href="#2-2-4有符号数与无符号数的转换" class="headerlink" title="2.2.4有符号数与无符号数的转换"></a>2.2.4有符号数与无符号数的转换</h3><p>强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。</p><p>对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。</p><p>补码转换为无符号数</p><p>对满足TMin&lt;&#x3D;x&lt;&#x3D;TMax的x有<br>$$<br>T2U_w(x)&#x3D;x+2^w,x&lt;0<br>$$</p><p>$$<br>T2U_w(x)&#x3D;x,x&gt;&#x3D;0<br>$$</p><p>当一个有符号数映射为它相应的无符号数时，负数就被转换成了大的正数，而非负数会保持不变。</p><p>无符号数转换为补码</p><p>对满足0&lt;&#x3D;u&lt;&#x3D;UMax的u有<br>$$<br>U2T_w(u)&#x3D;u,u&lt;&#x3D;TMax_w<br>$$</p><p>$$<br>U2T_w(u)&#x3D;u-2^w,u&gt;TMax_w<br>$$</p><p>对于小的数(&lt;&#x3D;TMax),从无符号数到有符号数的转换将保留数字的原值。</p><p>对于大的数( &gt;TMax),数字将被转换为一个负数值。</p><p><strong>考虑无符号与补码表示之间相互转换的结果</strong></p><p>对于在范围0&lt;&#x3D;x&lt;&#x3D;TMax之内的值x而言，我们得到T2U(x)&#x3D;x和U2T(x)&#x3D;x。也就是说，在这个范围内的数字有相同的无符号和补码表示。</p><p>对于这个范围以外的数字，转换需要加上或者减去$ 2_w $</p><h3 id="2-2-5C语言中的有符号数与无符号数"><a href="#2-2-5C语言中的有符号数与无符号数" class="headerlink" title="2.2.5C语言中的有符号数与无符号数"></a>2.2.5C语言中的有符号数与无符号数</h3><p>当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。</p><p>这种方法对于标准的算数运算来说并无多大差异，但是对于&lt;&gt;这样的关系运算符来说，它会导致非直观的结果。</p><h3 id="2-2-6扩展一个数字的位表示"><a href="#2-2-6扩展一个数字的位表示" class="headerlink" title="2.2.6扩展一个数字的位表示"></a>2.2.6扩展一个数字的位表示</h3><p>要将一个无符号数转换为一个更大的数据类型，只要简单的在表示的开头添加0，这种运算被称为零扩展。</p><p>要将补码数字转换为一个更大的数据类型，可以执行一个符号扩展（将符号位填补前面空余位）。</p><p>数据类型转换时，要先转换大小，再完成符号的转换。</p><h3 id="2-2-7截断数字"><a href="#2-2-7截断数字" class="headerlink" title="2.2.7截断数字"></a>2.2.7截断数字</h3><p>截断无符号数<br>$$<br>x^<code>=xmod2^k $$ 截断补码数值 $$ x^</code>&#x3D;U2T_k(xmod2^k)<br>$$</p><h3 id="2-2-8关于有符号数与无符号数的建议"><a href="#2-2-8关于有符号数与无符号数的建议" class="headerlink" title="2.2.8关于有符号数与无符号数的建议"></a>2.2.8关于有符号数与无符号数的建议</h3><h2 id="2-3整数运算"><a href="#2-3整数运算" class="headerlink" title="2.3整数运算"></a>2.3整数运算</h2><h3 id="2-3-1无符号加法"><a href="#2-3-1无符号加法" class="headerlink" title="2.3.1无符号加法"></a>2.3.1无符号加法</h3><p><strong>无符号加法</strong></p><p>对满足$ 0&lt;&#x3D;x,y&lt;2_w $的x和y有：<br>$$<br>x+y&#x3D;x+y,  x+y&lt;2^w<br>$$</p><p>$$<br>x+y&#x3D;x+y-2^w,2^w&lt;&#x3D;x+y&lt;&#x3D;2^{w+1}<br>$$</p><p><strong>检测无符号数加法中的溢出</strong></p><p>对在范围0&lt;&#x3D;x,y&lt;&#x3D;UMax,中的x和y，令s&#x3D;x+y。当且仅当s&lt;x(或者等价的s&lt;y)时发生了溢出。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>美赛绘图介绍</title>
      <link href="/2023/02/05/mei-sai-hui-tu-jie-shao/"/>
      <url>/2023/02/05/mei-sai-hui-tu-jie-shao/</url>
      
        <content type="html"><![CDATA[<h1 id="美赛绘图介绍"><a href="#美赛绘图介绍" class="headerlink" title="美赛绘图介绍"></a>美赛绘图介绍</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h3><p><a href="https://mycolor.space/">colorspace</a></p><h3 id="图片素材"><a href="#图片素材" class="headerlink" title="图片素材"></a>图片素材</h3><p><a href="https://www.freepik.com/">freepic</a></p><h3 id="python画图"><a href="#python画图" class="headerlink" title="python画图"></a>python画图</h3><p><a href="https://zhuanlan.zhihu.com/p/81553421?utm_source=wechat_session">seaborn库</a></p><h3 id="绘图网站"><a href="#绘图网站" class="headerlink" title="绘图网站"></a>绘图网站</h3><p><a href="https://www.bioladder.cn/web/#/pro/index">bioladder</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/02/03/hello-world/"/>
      <url>/2023/02/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
