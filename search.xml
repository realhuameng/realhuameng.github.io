<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试准备</title>
      <link href="/2024/02/28/mian-shi-zhun-bei/"/>
      <url>/2024/02/28/mian-shi-zhun-bei/</url>
      
        <content type="html"><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>面试官您好，我叫XX，目前大三，就读于哈尔滨工程大学计算机科学与技术专业。在校期间，我自学了Java开发的相关技能和一些常用框架，比如Spring、SpringBoot以及MySQL数据库、Redis等，并且独立开发了Java后端项目，比如Saas短链接系统。另外，在大二大三时，我也参加了许多比赛，计算机方面的例如蓝桥杯，数学建模方面我参加了美国大学生数学建模比赛和全国大学生数学建模比赛。在日常的学习生活中，我是一个乐于钻研技术，敢于迎接挑战的人，平时喜欢通过博客来整理自己所学习的知识，希望在此次面试中能够得到您的认可，以上就是我的个人情况。</p><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>引入：</p><p>短链接经常出现在咱们日常生活中，大家总是能在某些活动节日里收到各种营销短信，里边就会出现短链接。</p><p>简单介绍：</p><p>我在校开发的短链接项目主要功能是将用户提交的长URL通过特定的算法来转换成一个唯一的短标识符，将这个短标识符和用户发送的长URL关联起来保存到数据库中，当用户访问这个短链接时，短链接服务收到请求后会根据唯一标识符查找长URL，在将用户重定向到这个长URL。这样的短链接不仅更容易记忆和分享，还节省了字符空间，特别是一些限制字符数的场合。</p><p>模块介绍：</p><p>项目主要分为后管系统模块和主要的短链功能模块，后管系统包括对用户注册信息、登录的管理、中台联调，功能模块包括长短链接的转换、链接的存储。</p><p>技术选型：</p><p>采用最新的JDK17进行开发，技术架构包括SpringBoot、Redis、MySQL、ShardingSphere，使用ApiFox进行接口测试</p><p>开发难点：</p><p>海量存储的场景</p><p>ShardingSphere分库分表</p><p>海量并发</p><p>布隆过滤器搭配双重锁机制查询数据库，有效的避免了缓存击穿和缓存穿透。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>手搓Spring-11基于JDK、Cglib实现AOP切面</title>
      <link href="/2024/02/15/shou-cuo-spring-11-ji-yu-jdk-cglib-shi-xian-aop-qie-mian/"/>
      <url>/2024/02/15/shou-cuo-spring-11-ji-yu-jdk-cglib-shi-xian-aop-qie-mian/</url>
      
        <content type="html"><![CDATA[<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>需要解决的问题：</p><ul><li>如何给符合规则的方法做代理</li><li>做完代理的方法的案例后，把类的职责拆分出来</li></ul><p>先实现一个可以代理方法的Proxy，主要使用到方法拦截器类处理方法的调用MethodInterceptor#invoke，而不是直接使用invoke方法中的入参Method method进行method.invoke(targetObj, args)</p><p>除了以上，还需要使用到org.aspectj.weaver.tools.PointcutParser处理拦截表达式com.xxx.springframework.test.bean.IUserService.*(..))”</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="代理方法案例"><a href="#代理方法案例" class="headerlink" title="代理方法案例"></a>代理方法案例</h3><p>给一个UserService当成目标对象，对类中的所有方法进行拦截添加监控信息打印处理</p><p>代理的实现：Proxy.newProxyInstance</p><p>方法匹配：MethodMatcher</p><p>反射的调用：invoke(Object proxy, Method method, Object[] args)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test_proxy_method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 目标对象(可以替换成任何的目标对象)</span>    <span class="token class-name">Object</span> targetObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// AOP 代理</span>    <span class="token class-name">IUserService</span> proxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">IUserService</span><span class="token punctuation">)</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> targetObj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 方法匹配器</span>        <span class="token class-name">MethodMatcher</span> methodMatcher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AspectJExpressionPointcut</span><span class="token punctuation">(</span><span class="token string">"execution(* cn.bugstack.springframework.test.bean.IUserService.*(..))"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>methodMatcher<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> targetObj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 方法拦截器</span>                <span class="token class-name">MethodInterceptor</span> methodInterceptor <span class="token operator">=</span> invocation <span class="token operator">-></span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                        <span class="token keyword">return</span> invocation<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"监控 - Begin By AOP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"方法名称："</span> <span class="token operator">+</span> invocation<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"方法耗时："</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"监控 - End\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                <span class="token comment">// 反射调用</span>                <span class="token keyword">return</span> methodInterceptor<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ReflectiveMethodInvocation</span><span class="token punctuation">(</span>targetObj<span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>targetObj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> result <span class="token operator">=</span> proxy<span class="token punctuation">.</span><span class="token function">queryUserInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"测试结果："</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a>切点表达式</h3><p>切入点接口定义用于获取 ClassFilter、MethodMatcher 的两个类，这两个接口获取都是切点表达式提供的内容。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Pointcut</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * Return the ClassFilter for this pointcut.     * @return the ClassFilter (never &lt;code>null&lt;/code>)     */</span>    <span class="token class-name">ClassFilter</span> <span class="token function">getClassFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * Return the MethodMatcher for this pointcut.     * @return the MethodMatcher (never &lt;code>null&lt;/code>)     */</span>    <span class="token class-name">MethodMatcher</span> <span class="token function">getMethodMatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ClassFilter</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * Should the pointcut apply to the given interface or target class?     * @param clazz the candidate target class     * @return whether the advice should apply to the given target class     */</span>    <span class="token keyword">boolean</span> <span class="token function">matches</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> clazz<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MethodMatcher</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * Perform static checking whether the given method matches. If this     * @return whether or not this method matches statically     */</span>    <span class="token keyword">boolean</span> <span class="token function">matches</span><span class="token punctuation">(</span><span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> targetClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切点表达式实现了 Pointcut、ClassFilter、MethodMatcher，三个接口定义方法，同时这个类主要是对 aspectj 包提供的表达式校验方法使用。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AspectJExpressionPointcut</span> <span class="token keyword">implements</span> <span class="token class-name">Pointcut</span><span class="token punctuation">,</span> <span class="token class-name">ClassFilter</span><span class="token punctuation">,</span> <span class="token class-name">MethodMatcher</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PointcutPrimitive</span><span class="token punctuation">></span></span> <span class="token constant">SUPPORTED_PRIMITIVES</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PointcutPrimitive</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>        <span class="token constant">SUPPORTED_PRIMITIVES</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">PointcutPrimitive</span><span class="token punctuation">.</span><span class="token constant">EXECUTION</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">PointcutExpression</span> pointcutExpression<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">AspectJExpressionPointcut</span><span class="token punctuation">(</span><span class="token class-name">String</span> expression<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">PointcutParser</span> pointcutParser <span class="token operator">=</span> <span class="token class-name">PointcutParser</span><span class="token punctuation">.</span><span class="token function">getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution</span><span class="token punctuation">(</span><span class="token constant">SUPPORTED_PRIMITIVES</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pointcutExpression <span class="token operator">=</span> pointcutParser<span class="token punctuation">.</span><span class="token function">parsePointcutExpression</span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">matches</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> clazz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> pointcutExpression<span class="token punctuation">.</span><span class="token function">couldMatchJoinPointsInType</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">matches</span><span class="token punctuation">(</span><span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> targetClass<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> pointcutExpression<span class="token punctuation">.</span><span class="token function">matchesMethodExecution</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">alwaysMatches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">ClassFilter</span> <span class="token function">getClassFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">MethodMatcher</span> <span class="token function">getMethodMatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="包装切面通知信息"><a href="#包装切面通知信息" class="headerlink" title="包装切面通知信息"></a>包装切面通知信息</h3><ul><li>AdvisedSupport，主要是用于把代理、拦截、匹配的各项属性包装到一个类中，方便在 Proxy 实现类进行使用。</li><li>TargetSource，是一个目标对象，在目标对象类中提供 Object 入参属性，以及获取目标类 TargetClass 信息。</li><li>MethodInterceptor，是一个具体拦截方法实现类，由用户自己实现 MethodInterceptor#invoke 方法，做具体的处理。</li><li>MethodMatcher，是一个匹配方法的操作，这个对象由 AspectJExpressionPointcut 提供服务。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdvisedSupport</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 被代理的目标对象</span>    <span class="token keyword">private</span> <span class="token class-name">TargetSource</span> targetSource<span class="token punctuation">;</span>    <span class="token comment">// 方法拦截器</span>    <span class="token keyword">private</span> <span class="token class-name">MethodInterceptor</span> methodInterceptor<span class="token punctuation">;</span>    <span class="token comment">// 方法匹配器(检查目标方法是否符合通知条件)</span>    <span class="token keyword">private</span> <span class="token class-name">MethodMatcher</span> methodMatcher<span class="token punctuation">;</span>        <span class="token comment">// ...get/set</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代理抽象实现（JDK-amp-Cglib）"><a href="#代理抽象实现（JDK-amp-Cglib）" class="headerlink" title="代理抽象实现（JDK&amp;Cglib）"></a>代理抽象实现（JDK&amp;Cglib）</h3><p>定义一个标准接口，用于获取代理类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AopProxy</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Object</span> <span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JdkDynamicAopProxy</span> <span class="token keyword">implements</span> <span class="token class-name">AopProxy</span><span class="token punctuation">,</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AdvisedSupport</span> advised<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">JdkDynamicAopProxy</span><span class="token punctuation">(</span><span class="token class-name">AdvisedSupport</span> advised<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>advised <span class="token operator">=</span> advised<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> advised<span class="token punctuation">.</span><span class="token function">getTargetSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>advised<span class="token punctuation">.</span><span class="token function">getMethodMatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> advised<span class="token punctuation">.</span><span class="token function">getTargetSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">MethodInterceptor</span> methodInterceptor <span class="token operator">=</span> advised<span class="token punctuation">.</span><span class="token function">getMethodInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> methodInterceptor<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ReflectiveMethodInvocation</span><span class="token punctuation">(</span>advised<span class="token punctuation">.</span><span class="token function">getTargetSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>advised<span class="token punctuation">.</span><span class="token function">getTargetSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cglib2AopProxy</span> <span class="token keyword">implements</span> <span class="token class-name">AopProxy</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AdvisedSupport</span> advised<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Cglib2AopProxy</span><span class="token punctuation">(</span><span class="token class-name">AdvisedSupport</span> advised<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>advised <span class="token operator">=</span> advised<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Enhancer</span> enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>advised<span class="token punctuation">.</span><span class="token function">getTargetSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        enhancer<span class="token punctuation">.</span><span class="token function">setInterfaces</span><span class="token punctuation">(</span>advised<span class="token punctuation">.</span><span class="token function">getTargetSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DynamicAdvisedInterceptor</span><span class="token punctuation">(</span>advised<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DynamicAdvisedInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> objects<span class="token punctuation">,</span> <span class="token class-name">MethodProxy</span> methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">CglibMethodInvocation</span> methodInvocation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CglibMethodInvocation</span><span class="token punctuation">(</span>advised<span class="token punctuation">.</span><span class="token function">getTargetSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> method<span class="token punctuation">,</span> objects<span class="token punctuation">,</span> methodProxy<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>advised<span class="token punctuation">.</span><span class="token function">getMethodMatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> advised<span class="token punctuation">.</span><span class="token function">getTargetSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> advised<span class="token punctuation">.</span><span class="token function">getMethodInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>methodInvocation<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> methodInvocation<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CglibMethodInvocation</span> <span class="token keyword">extends</span> <span class="token class-name">ReflectiveMethodInvocation</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>methodProxy<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>target<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>手搓spring-11基于JDK和Cglib动态代理，实现AOP核心功能</title>
      <link href="/2024/02/14/shou-cuo-spring-11-ji-yu-jdk-he-cglib-dong-tai-dai-li-shi-xian-aop-he-xin-gong-neng/"/>
      <url>/2024/02/14/shou-cuo-spring-11-ji-yu-jdk-he-cglib-dong-tai-dai-li-shi-xian-aop-he-xin-gong-neng/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>手搓Spring-10容器事件和事件监听器</title>
      <link href="/2024/02/12/shou-cuo-spring-10-rong-qi-shi-jian-he-shi-jian-jian-ting-qi/"/>
      <url>/2024/02/12/shou-cuo-spring-10-rong-qi-shi-jian-he-shi-jian-jian-ting-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>整个功能的实现需要在面向用户的应用上下文AbstractApplicationContext中添加相关事件内容，包括：初始化事件发布者、注册事件监听器、发布容器刷新完成事件</p><p>使用观察者模式定义事件类、监听类、发布类，同时还需要完成一个广播器的功能，接收到事件推送时进行分析处理符合监听事件接受者感兴趣的事件，也就是使用 isAssignableFrom 进行判断</p><p>isAssignableFrom 和 instanceof 相似，不过 isAssignableFrom 是用来判断子类和父类的关系的，或者接口的实现类和接口的关系的，默认所有的类的终极父类都是Object。如果A.isAssignableFrom(B)结果是true，证明B可以转换成为A,也就是A可以由B转换而来</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="定义和实现事件"><a href="#定义和实现事件" class="headerlink" title="定义和实现事件"></a>定义和实现事件</h3><p>以继承 java.util.EventObject 定义出具备事件功能的抽象类 ApplicationEvent，后续所有事件的类都需要继承这个类</p><p>ApplicationEvent 是定义事件的抽象类，所有的事件包括关闭、刷新，以及用户自己实现的事件，都需要继承这个类</p><p>ContextClosedEvent、ContextRefreshedEvent，分别是 Spring 框架自己实现的两个事件类，可以用于监听刷新和关闭动作</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationEvent</span> <span class="token keyword">extends</span> <span class="token class-name">EventObject</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 构建一个原型事件     */</span>    <span class="token keyword">public</span> <span class="token class-name">ApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">Object</span> source<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationContextEvent</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationEvent</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 构建一个原型事件     */</span>    <span class="token keyword">public</span> <span class="token class-name">ApplicationContextEvent</span><span class="token punctuation">(</span><span class="token class-name">Object</span> source<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 获取引发事件的ApplicationContext     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">ApplicationContext</span> <span class="token function">getApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">ApplicationContext</span><span class="token punctuation">)</span> <span class="token function">getSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ContextClosedEvent</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationContextEvent</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ContextClosedEvent</span><span class="token punctuation">(</span><span class="token class-name">Object</span> source<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ContextRefreshedEvent</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationContextEvent</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ContextRefreshedEvent</span><span class="token punctuation">(</span><span class="token class-name">Object</span> source<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="事件广播器"><a href="#事件广播器" class="headerlink" title="事件广播器"></a>事件广播器</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ApplicationEventMulticaster</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * Add a listener to be notified of all events.     * @param listener the listener to add     */</span>    <span class="token keyword">void</span> <span class="token function">addApplicationListener</span><span class="token punctuation">(</span><span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * Remove a listener from the notification list.     * @param listener the listener to remove     */</span>    <span class="token keyword">void</span> <span class="token function">removeApplicationListener</span><span class="token punctuation">(</span><span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * Multicast the given application event to appropriate listeners.     * @param event the event to multicast     */</span>    <span class="token keyword">void</span> <span class="token function">multicastEvent</span><span class="token punctuation">(</span><span class="token class-name">ApplicationEvent</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>首先，获取监听器的类信息，存储在 <code>listenerClass</code> 变量中。</li><li>接着，通过 <code>ClassUtils.isCglibProxyClass(listenerClass)</code> 方法判断监听器实例化的类型，如果是 Cglib 代理类，则获取其父类作为目标类，否则目标类就是监听器本身，存储在 <code>targetClass</code> 变量中。</li><li>然后，通过 <code>targetClass.getGenericInterfaces()[0]</code> 获取目标类实现的第一个泛型接口，即监听器所监听的事件类型。</li><li>接下来，通过 <code>((ParameterizedType) genericInterface).getActualTypeArguments()[0]</code> 获取泛型接口的实际类型参数，即监听的事件类型。</li><li>最后，将获取到的事件类型的类名存储在 <code>className</code> 变量中，并通过 <code>Class.forName(className)</code> 获取事件类型的 <code>Class</code> 对象，存储在 <code>eventClassName</code> 变量中。</li></ol><p>这段代码的作用是通过反射获取监听器所监听的事件类型，以便在后续的逻辑中判断监听器是否对特定的事件感兴趣</p><blockquote><p>在 Java 中，有两种常见的动态代理方式：JDK 动态代理和 CGLIB 动态代理。</p><p>JDK 动态代理是基于接口的代理，它要求被代理的类实现一个或多个接口。代理对象是基于接口生成的，因此代理对象的类型是接口的子类。</p><p>CGLIB 动态代理是基于继承的代理，它可以代理没有实现接口的类。代理对象是基于被代理类生成的子类。</p><p>在 Spring 框架中，当我们使用 <code>@EventListener</code> 注解或者实现 <code>ApplicationListener</code> 接口来定义事件监听器时，Spring 会根据代理方式的不同来处理监听器的实例化。</p><p>如果监听器是通过 JDK 动态代理生成的，那么监听器本身就是目标类，因为 JDK 动态代理要求被代理的类实现接口，所以监听器本身就是实现了 <code>ApplicationListener</code> 接口的类。</p><p>而如果监听器是通过 CGLIB 动态代理生成的，那么监听器的父类才是目标类。因为 CGLIB 动态代理是基于继承的代理，它生成的代理对象是目标类的子类，而监听器本身是代理对象的父类。</p><p>因此，在获取监听器所监听的事件类型时，需要根据代理方式的不同来处理，从而得到正确的目标类信息。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractApplicationEventMulticaster</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationEventMulticaster</span><span class="token punctuation">,</span> <span class="token class-name">BeanFactoryAware</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ApplicationListener</span><span class="token punctuation">&lt;</span><span class="token class-name">ApplicationEvent</span><span class="token punctuation">></span><span class="token punctuation">></span></span> applicationListeners <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">BeanFactory</span> beanFactory<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addApplicationListener</span><span class="token punctuation">(</span><span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> listener<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        applicationListeners<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ApplicationEvent</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeApplicationListener</span><span class="token punctuation">(</span><span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> listener<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        applicationListeners<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setBeanFactory</span><span class="token punctuation">(</span><span class="token class-name">BeanFactory</span> beanFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory <span class="token operator">=</span> beanFactory<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">protected</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ApplicationListener</span><span class="token punctuation">></span></span> <span class="token function">getApplicationListeners</span><span class="token punctuation">(</span><span class="token class-name">ApplicationEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ApplicationListener</span><span class="token punctuation">></span></span> allListeners <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ApplicationListener</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ApplicationEvent</span><span class="token punctuation">></span></span> listener <span class="token operator">:</span> applicationListeners<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">supportsEvent</span><span class="token punctuation">(</span>listener<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">)</span> allListeners<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> allListeners<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 监听器是否对该事件感兴趣     */</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">supportsEvent</span><span class="token punctuation">(</span><span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ApplicationEvent</span><span class="token punctuation">></span></span> applicationListener<span class="token punctuation">,</span> <span class="token class-name">ApplicationEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationListener</span><span class="token punctuation">></span></span> listenerClass <span class="token operator">=</span> applicationListener<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 按照 CglibSubclassingInstantiationStrategy、SimpleInstantiationStrategy 不同的实例化类型，需要判断后获取目标 class</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> targetClass <span class="token operator">=</span> <span class="token class-name">ClassUtils</span><span class="token punctuation">.</span><span class="token function">isCglibProxyClass</span><span class="token punctuation">(</span>listenerClass<span class="token punctuation">)</span> <span class="token operator">?</span> listenerClass<span class="token punctuation">.</span><span class="token function">getSuperclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> listenerClass<span class="token punctuation">;</span>        <span class="token class-name">Type</span> genericInterface <span class="token operator">=</span> targetClass<span class="token punctuation">.</span><span class="token function">getGenericInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token class-name">Type</span> actualTypeArgument <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ParameterizedType</span><span class="token punctuation">)</span> genericInterface<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getActualTypeArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> className <span class="token operator">=</span> actualTypeArgument<span class="token punctuation">.</span><span class="token function">getTypeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> eventClassName<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            eventClassName <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeansException</span><span class="token punctuation">(</span><span class="token string">"wrong event class name: "</span> <span class="token operator">+</span> className<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 判定此 eventClassName 对象所表示的类或接口与指定的 event.getClass() 参数所表示的类或接口是否相同，或是否是其超类或超接口。</span>        <span class="token comment">// isAssignableFrom是用来判断子类和父类的关系的，或者接口的实现类和接口的关系的，默认所有的类的终极父类都是Object。如果A.isAssignableFrom(B)结果是true，证明B可以转换成为A,也就是A可以由B转换而来。</span>        <span class="token keyword">return</span> eventClassName<span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="事件发布者的定义和实现"><a href="#事件发布者的定义和实现" class="headerlink" title="事件发布者的定义和实现"></a>事件发布者的定义和实现</h3><p>ApplicationEventPublisher 是整个一个事件的发布接口，所有的事件都需要从这个接口发布出去。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ApplicationEventPublisher</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * Notify all listeners registered with this application of an application     * event. Events may be framework events (such as RequestHandledEvent)     * or application-specific events.     * @param event the event to publish     */</span>    <span class="token keyword">void</span> <span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token class-name">ApplicationEvent</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>手搓Spring-09关于Bean对象作用域以及FactoryBean的实现和使用</title>
      <link href="/2024/02/07/shou-cuo-spring-guan-yu-bean-dui-xiang-zuo-yong-yu-yi-ji-factorybean-de-shi-xian-he-shi-yong/"/>
      <url>/2024/02/07/shou-cuo-spring-guan-yu-bean-dui-xiang-zuo-yong-yu-yi-ji-factorybean-de-shi-xian-he-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>对外提供一个可以二次从FactoryBean的getObject方法中获取对象的功能，这样所有实现此接口的对象类，就可以扩充自己对象的功能了</p><p>实现过程分为两部分：</p><blockquote><p>对单例对象和原型对象进行不同的处理</p><p>对象类型的创建获取方式，主要区分在于<code>AbstractAutowireCapableBeanFactory#createBean</code>创建完成对象后是否放入内存，如果不放入则每次获取都会重新创建</p></blockquote><blockquote><p>处理FactoryBean对象创建过程中关于获取具体调用对象的getObject操作</p></blockquote><p>createBean 执行对象创建、属性填充、依赖加载、前置后置处理、初始化等操作后，就要开始做执行判断整个对象是否是一个 FactoryBean 对象，如果是这样的对象，就需要再继续执行获取 FactoryBean 具体对象中的 getObject 对象了。整个 getBean 过程中都会新增一个单例类型的判断factory.isSingleton()，用于决定是否使用内存存放对象信息。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Bean的作用范围定义和xml解析"><a href="#Bean的作用范围定义和xml解析" class="headerlink" title="Bean的作用范围定义和xml解析"></a>Bean的作用范围定义和xml解析</h3><p>singleton、prototype，是本次在 BeanDefinition 类中新增加的两个属性信息，用于把从 spring.xml 中解析到的 Bean 对象作用范围填充到属性中</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanDefinition</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> <span class="token constant">SCOPE_SINGLETON</span> <span class="token operator">=</span> <span class="token class-name">ConfigurableBeanFactory</span><span class="token punctuation">.</span><span class="token constant">SCOPE_SINGLETON</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> <span class="token constant">SCOPE_PROTOTYPE</span> <span class="token operator">=</span> <span class="token class-name">ConfigurableBeanFactory</span><span class="token punctuation">.</span><span class="token constant">SCOPE_PROTOTYPE</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Class</span> beanClass<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">PropertyValues</span> propertyValues<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> initMethodName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> destroyMethodName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> scope <span class="token operator">=</span> <span class="token constant">SCOPE_SINGLETON</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> singleton <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> prototype <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment">//在xml注册Bean定义时，通过scope字段来判断是单例还是原型</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setScope</span><span class="token punctuation">(</span><span class="token class-name">String</span> scope<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>scope <span class="token operator">=</span> scope<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>singleton <span class="token operator">=</span> <span class="token constant">SCOPE_SINGLETON</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token constant">SCOPE_PROTOTYPE</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>            <span class="token comment">//...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">XmlBeanDefinitionReader</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractBeanDefinitionReader</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doLoadBeanDefinition</span><span class="token punctuation">(</span><span class="token class-name">InputStream</span> inputStream<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Document</span> doc <span class="token operator">=</span> <span class="token class-name">XmlUtil</span><span class="token punctuation">.</span><span class="token function">readXML</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Element</span> root <span class="token operator">=</span> doc<span class="token punctuation">.</span><span class="token function">getDocumentElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">NodeList</span> childNodes <span class="token operator">=</span> root<span class="token punctuation">.</span><span class="token function">getChildNodes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>childNodes<span class="token punctuation">.</span><span class="token function">getLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//判断元素</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>childNodes<span class="token punctuation">.</span><span class="token function">item</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">Element</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment">//判断对象</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token string">"bean"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>childNodes<span class="token punctuation">.</span><span class="token function">item</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getNodeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment">//解析标签</span>            <span class="token class-name">Element</span> bean <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Element</span><span class="token punctuation">)</span>childNodes<span class="token punctuation">.</span><span class="token function">item</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> id <span class="token operator">=</span> bean<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> name <span class="token operator">=</span> bean<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> className <span class="token operator">=</span> bean<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"class"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//增加对新增属性的读取</span>            <span class="token class-name">String</span> initMethod <span class="token operator">=</span> bean<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"init-method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> destroyMethodName <span class="token operator">=</span> bean<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"destroy-method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> beanScope <span class="token operator">=</span> bean<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"scope"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//获取class</span>            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> beanName <span class="token operator">=</span> <span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token operator">?</span> id <span class="token operator">:</span> name<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                beanName <span class="token operator">=</span> <span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">lowerFirst</span><span class="token punctuation">(</span>clazz<span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token class-name">BeanDefinition</span> beanDefinition <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BeanDefinition</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>            beanDefinition<span class="token punctuation">.</span><span class="token function">setInitMethodName</span><span class="token punctuation">(</span>initMethod<span class="token punctuation">)</span><span class="token punctuation">;</span>            beanDefinition<span class="token punctuation">.</span><span class="token function">setDestroyMethodName</span><span class="token punctuation">(</span>destroyMethodName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>beanScope<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                beanDefinition<span class="token punctuation">.</span><span class="token function">setScope</span><span class="token punctuation">(</span>beanScope<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>bean<span class="token punctuation">.</span><span class="token function">getChildNodes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>bean<span class="token punctuation">.</span><span class="token function">getChildNodes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">item</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">Element</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token string">"property"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>bean<span class="token punctuation">.</span><span class="token function">getChildNodes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">item</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getNodeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token class-name">Element</span> property <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Element</span><span class="token punctuation">)</span>bean<span class="token punctuation">.</span><span class="token function">getChildNodes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">item</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">String</span> attrName <span class="token operator">=</span> property<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">String</span> attrValue <span class="token operator">=</span> property<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">String</span> attrRef <span class="token operator">=</span> property<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"ref"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">Object</span> value <span class="token operator">=</span> <span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>attrRef<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">BeanReference</span><span class="token punctuation">(</span>attrRef<span class="token punctuation">)</span> <span class="token operator">:</span> attrValue<span class="token punctuation">;</span>                <span class="token class-name">PropertyValue</span> propertyValue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PropertyValue</span><span class="token punctuation">(</span>attrName<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>                beanDefinition<span class="token punctuation">.</span><span class="token function">getPropertyValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addPropertyValue</span><span class="token punctuation">(</span>propertyValue<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">getRegistry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">containBeanDefinition</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeansException</span><span class="token punctuation">(</span><span class="token string">"Duplicate beanName["</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"] is not allowed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">getRegistry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建和修改对象时判断单例和原型模式"><a href="#创建和修改对象时判断单例和原型模式" class="headerlink" title="创建和修改对象时判断单例和原型模式"></a>创建和修改对象时判断单例和原型模式</h3><p>单例模式和原型模式的区别就在于是否存放到内存中，如果是原型模式那么就不会存放到内存中，每次获取都重新创建对象，非Singleton类型的Bean不需要执行销毁方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractAutowireCapableBeanFactory</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractBeanFactory</span> <span class="token keyword">implements</span> <span class="token class-name">AutowireCapableBeanFactory</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">InstantiationStrategy</span> instantiationStrategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CglibSubclassingInstantiationStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">createBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token class-name">BeanDefinition</span> beanDefinition<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Object</span> bean <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>            bean <span class="token operator">=</span> <span class="token function">createBeanInstance</span><span class="token punctuation">(</span>beanDefinition<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//填充属性</span>            <span class="token function">applyPropertyValues</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> bean<span class="token punctuation">,</span> beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//执行Bean的初始化方法和BeanPostProcessor的前置和后置处理方法</span>            bean <span class="token operator">=</span> <span class="token function">initializeBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> bean<span class="token punctuation">,</span> beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeansException</span><span class="token punctuation">(</span><span class="token string">"Instantiation of bean failed"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//注册实现了B、DispasableBean接口的Bean对象</span>        <span class="token function">registerDisposableBeanIfNeccessary</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> bean<span class="token punctuation">,</span> beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>beanDefinition<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">addSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">registerDisposableBeanIfNeccessary</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">BeanDefinition</span> beanDefinition<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>beanDefinition<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">DisposableBean</span> <span class="token operator">||</span> <span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>beanDefinition<span class="token punctuation">.</span><span class="token function">getDestroyMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">registerDisposableBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DisposableBeanAdapter</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> beanDefinition<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="定义FactoryBean接口"><a href="#定义FactoryBean接口" class="headerlink" title="定义FactoryBean接口"></a>定义FactoryBean接口</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">FactoryBean</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 获取对象     * @return     * @throws Exception     */</span>    <span class="token class-name">T</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 获取对象类型     * @return     */</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">getObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 判断是否为单例对象     * @return     */</span>    <span class="token keyword">boolean</span> <span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实现一个FactoryBean注册服务"><a href="#实现一个FactoryBean注册服务" class="headerlink" title="实现一个FactoryBean注册服务"></a>实现一个FactoryBean注册服务</h3><p>定义一个缓存操作factoryBeanObjectCache，用于存放单例对象，避免重复创建</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">FactoryBeanRegistrySupport</span> <span class="token keyword">extends</span> <span class="token class-name">DefaultSingletonBeanRegistry</span><span class="token punctuation">&#123;</span>    <span class="token comment">/**     * FactoryBeans创建的单例对象缓存：FactoryBean name --> object     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> factoryBeanObjectCache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">getCachedObjectForFactoryBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Object</span> object <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>factoryBeanObjectCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>object <span class="token operator">!=</span> <span class="token constant">NULL_OBJECT</span> <span class="token operator">?</span> object <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">getObjectFromFactoryBean</span><span class="token punctuation">(</span><span class="token class-name">FactoryBean</span> factory<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>factory<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Object</span> object <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>factoryBeanObjectCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>object <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                object <span class="token operator">=</span> <span class="token function">doGetObjectFromFactoryBean</span><span class="token punctuation">(</span>factory<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>factoryBeanObjectCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span>object <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> object <span class="token operator">:</span> <span class="token constant">NULL_OBJECT</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>object <span class="token operator">!=</span> <span class="token constant">NULL_OBJECT</span> <span class="token operator">?</span> object <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">doGetObjectFromFactoryBean</span><span class="token punctuation">(</span>factory<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> <span class="token function">doGetObjectFromFactoryBean</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">FactoryBean</span> factory<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> factory<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeansException</span><span class="token punctuation">(</span><span class="token string">"FactoryBean threw exception on object["</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"] creation"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="扩展AbstractBeanFactory创建对象逻辑"><a href="#扩展AbstractBeanFactory创建对象逻辑" class="headerlink" title="扩展AbstractBeanFactory创建对象逻辑"></a>扩展AbstractBeanFactory创建对象逻辑</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractBeanFactory</span> <span class="token keyword">extends</span> <span class="token class-name">FactoryBeanRegistrySupport</span> <span class="token keyword">implements</span> <span class="token class-name">ConfigurableBeanFactory</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">doGetBean</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Object</span> sharedInstance <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sharedInstance <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 如果是 FactoryBean，则需要调用 FactoryBean#getObject</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token function">getObjectForBeanInstance</span><span class="token punctuation">(</span>sharedInstance<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">private</span> <span class="token class-name">Object</span> <span class="token function">getObjectForBeanInstance</span><span class="token punctuation">(</span><span class="token class-name">Object</span> beanInstance<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>beanInstance <span class="token keyword">instanceof</span> <span class="token class-name">FactoryBean</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> beanInstance<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Object</span> object <span class="token operator">=</span> <span class="token function">getCachedObjectForFactoryBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>object <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">FactoryBean</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> factoryBean <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">FactoryBean</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> beanInstance<span class="token punctuation">;</span>            object <span class="token operator">=</span> <span class="token function">getObjectFromFactoryBean</span><span class="token punctuation">(</span>factoryBean<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> object<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>手搓Spring-08定义标记类型Aware接口，实现感知容器对象</title>
      <link href="/2024/02/03/shou-cuo-spring-08-ding-yi-biao-ji-lei-xing-aware-jie-kou-shi-xian-gan-zhi-rong-qi-dui-xiang/"/>
      <url>/2024/02/03/shou-cuo-spring-08-ding-yi-biao-ji-lei-xing-aware-jie-kou-shi-xian-gan-zhi-rong-qi-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>如果需要拿到Spring框架中一些提供的资源，首先应该考虑以什么方式去获取，定义获取方式，还要考虑在Spring框架中该怎么去承接</p><p>为了实现这两项内容，可以定义一个标记性的接口，这个接口只起到标记作用，而具体的功能由继承此接口的其他功能性接口定义具体方法，最终这个接口就可以通过instanceof进行判断和调用</p><ul><li>定义接口Aware，在Spring框架种它是一种感知标记性接口，具体的子类定义和实现能感知容器中的相关对象</li><li>继承Aware的接口包括：BeanFactoryAware、BeanClassLoaderAware、BeanNameAware、ApplicationContextAware</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Aware有四个继承的接口，其他这些接口的继承都是为了继承一个标记，有了标记的存在更方便类的操作和具体判断实现</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-02-04%20125000.png"></p><h3 id="定义标记接口"><a href="#定义标记接口" class="headerlink" title="定义标记接口"></a>定义标记接口</h3><p>此类接口可以方便统一摘取出属于此类接口的实现类，通常与instanceof一起判断使用</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-02-04%20130655.png"></p><h3 id="容器感知类"><a href="#容器感知类" class="headerlink" title="容器感知类"></a>容器感知类</h3><p>BeanFactoryAware</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-02-04%20130829.png"></p><p>BeanClassLoaderAware</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-02-04%20130907.png"></p><p>BeanNameAware</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-02-04%20130944.png"></p><p>ApplicationContextAware</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-02-04%20131054.png"></p><h2 id="包装处理器"><a href="#包装处理器" class="headerlink" title="包装处理器"></a>包装处理器</h2><p>由于ApplicationContext的获取并不能直接在创建Bean时候就可以拿到，所以需要在refresh操作时，把ApplicationContext写入到一个包装的BeanPostProcessor中去，再由AbstractAutowireCapableBeanFactory.applyBeanPostProcessorBeforeInitialization方法调用</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-02-04%20132505.png"></p><h3 id="注册BeanPostProcessor"><a href="#注册BeanPostProcessor" class="headerlink" title="注册BeanPostProcessor"></a>注册BeanPostProcessor</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-02-04%20132826.png"></p><h3 id="感知调用操作"><a href="#感知调用操作" class="headerlink" title="感知调用操作"></a>感知调用操作</h3><p> 在initializeBean中，通过判断bean instanceof Aware，调用了三个接口方法，<code>BeanFactoryAware.setBeanFactory(this)</code>、<code>BeanClassLoaderAware.setBeanClassLoader(getBeanClassLoader())</code>、<code>BeanNameAware.setBeanName(beanName)</code>，这样就能通知到已经实现了此接口的类。</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-02-06%20183155.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SaaS短链接项目开发日志</title>
      <link href="/2024/02/02/saas-duan-lian-jie/"/>
      <url>/2024/02/02/saas-duan-lian-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>短链接是指将一个原始的长URL通过特定的算法或服务转化未一个更短、易于记忆的URL</p><blockquote><p>短链接的原理：</p></blockquote><ol><li>生成唯一标识符：当用户提交一个长URL时，短链接服务会生成一个唯一的标识符或者短码</li><li>将标识符与长URL关联将唯一的标识符与用户提供的长URL关联起来，并将其保存在数据库或者其他持久化存储中</li><li>创建短链接：将生成的唯一标识符加上短链接服务的域名作为前缀，构成短链接</li><li>重定向：当用户访问短链接时，短链接服务会根据唯一标识符查找关联的长URL，将用户重定向到这个URL</li><li>跟踪统计</li></ol><h2 id="用户模块"><a href="#用户模块" class="headerlink" title="用户模块"></a>用户模块</h2><h3 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h3><ul><li>检查用户名是否存在</li><li>注册用户</li><li>修改用户</li><li>根据用户名查询用户</li><li>用户登录</li><li>检查用户是否登录</li><li>用户退出登录</li><li>注销用户</li></ul><h2 id="短链接管理模块"><a href="#短链接管理模块" class="headerlink" title="短链接管理模块"></a>短链接管理模块</h2><h3 id="功能分析-1"><a href="#功能分析-1" class="headerlink" title="功能分析"></a>功能分析</h3><ul><li>短链接跳转原理</li><li>创建短链接表</li><li>新增短链接</li><li>Host添加域名映射</li><li>分页查询短链接集合</li><li>编辑短链接</li><li>将短链接删除（回收站）</li></ul><h2 id="回收站管理"><a href="#回收站管理" class="headerlink" title="回收站管理"></a>回收站管理</h2><h3 id="功能分析-2"><a href="#功能分析-2" class="headerlink" title="功能分析"></a>功能分析</h3><ul><li>将短链接移致回收站</li><li>回收站分页列表查询</li><li>短链接从回收站恢复</li><li>短链接从回收站删除</li></ul><h2 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h2><h3 id="1-使用布隆过滤器判断短链是否存在"><a href="#1-使用布隆过滤器判断短链是否存在" class="headerlink" title="1.使用布隆过滤器判断短链是否存在"></a>1.使用布隆过滤器判断短链是否存在</h3><p>定义一个布隆过滤器 <code>RBloomFilterConfiguration</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 布隆过滤器配置 */</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RBloomFilterConfiguration</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 防止短链接创建查询数据库的布隆过滤器     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">RBloomFilter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">shortUriCreateCachePenetrationBloomFilter</span><span class="token punctuation">(</span><span class="token class-name">RedissonClient</span> redissonClient<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">RBloomFilter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> cachePenetrationBloomFilter <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getBloomFilter</span><span class="token punctuation">(</span><span class="token string">"userRegisterCachePenetrationBloomFilter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cachePenetrationBloomFilter<span class="token punctuation">.</span><span class="token function">tryInit</span><span class="token punctuation">(</span><span class="token number">100000000L</span><span class="token punctuation">,</span> <span class="token number">0.001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> cachePenetrationBloomFilter<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">ShortLinkCreateRespDto</span> <span class="token function">createShortLink</span><span class="token punctuation">(</span><span class="token class-name">ShortLinkCreateReqDto</span> requestParam<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> shortLinkSuffix <span class="token operator">=</span> <span class="token function">generateSuffix</span><span class="token punctuation">(</span>requestParam<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> fullShortUrl <span class="token operator">=</span> requestParam<span class="token punctuation">.</span><span class="token function">getDomain</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> shortLinkSuffix<span class="token punctuation">;</span>        <span class="token class-name">ShortLinkDO</span> shortLinkDO <span class="token operator">=</span> <span class="token class-name">BeanUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>requestParam<span class="token punctuation">,</span> <span class="token class-name">ShortLinkDO</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        shortLinkDO<span class="token punctuation">.</span><span class="token function">setShortUri</span><span class="token punctuation">(</span>shortLinkSuffix<span class="token punctuation">)</span><span class="token punctuation">;</span>        shortLinkDO<span class="token punctuation">.</span><span class="token function">setFullShortUrl</span><span class="token punctuation">(</span>fullShortUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>            baseMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>shortLinkDO<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">DuplicateKeyException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">LambdaQueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ShortLinkDO</span><span class="token punctuation">></span></span> queryWrapper <span class="token operator">=</span> <span class="token class-name">Wrappers</span><span class="token punctuation">.</span><span class="token function">lambdaQuery</span><span class="token punctuation">(</span><span class="token class-name">ShortLinkDO</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>                    <span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token class-name">ShortLinkDO</span><span class="token operator">::</span><span class="token function">getFullShortUrl</span><span class="token punctuation">,</span> fullShortUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">ShortLinkDO</span> shortLinkDO1 <span class="token operator">=</span> baseMapper<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span>queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>shortLinkDO1 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"短链接：重复入库"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ServiceException</span><span class="token punctuation">(</span><span class="token string">"短链接生成重复"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>        shortUriCreateCachePenetrationBloomFilter<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>shortLinkSuffix<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">ShortLinkCreateRespDto</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">fullShortUrl</span><span class="token punctuation">(</span>shortLinkDO<span class="token punctuation">.</span><span class="token function">getFullShortUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">gid</span><span class="token punctuation">(</span>requestParam<span class="token punctuation">.</span><span class="token function">getGid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">originUrl</span><span class="token punctuation">(</span>requestParam<span class="token punctuation">.</span><span class="token function">getOriginUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">generateSuffix</span><span class="token punctuation">(</span><span class="token class-name">ShortLinkCreateReqDto</span> requestParam<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> customGenerateCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> shortUri<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//while循环10次，直到不冲突为止，如果超过10次就抛异常</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>customGenerateCount <span class="token operator">></span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ServiceException</span><span class="token punctuation">(</span><span class="token string">"短链接频繁生成，请稍后再试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token class-name">String</span> originUrl <span class="token operator">=</span> requestParam<span class="token punctuation">.</span><span class="token function">getOriginUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            originUrl <span class="token operator">+=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            shortUri <span class="token operator">=</span> <span class="token class-name">HashUtil</span><span class="token punctuation">.</span><span class="token function">hashToBase62</span><span class="token punctuation">(</span>originUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>shortUriCreateCachePenetrationBloomFilter<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>originUrl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            customGenerateCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> shortUri<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-添加路由表完成跳转功能"><a href="#2-添加路由表完成跳转功能" class="headerlink" title="2.添加路由表完成跳转功能"></a>2.添加路由表完成跳转功能</h3><p>跳转功能：用户传来一个短链接，通过302重定向，跳转到原始链接对应的网址</p><p>由于短链接分组是以gid作为分组标识进行分组的，而用户仅仅传来一个短链接，如何从数据库中获取到对应的记录呢？可以通过添加一个路由表来实现此功能</p><blockquote><p>如何实现？</p></blockquote><p>创建一个新表：t_link_goto，存储gid和shortUri，通过短链接找到gid，再通过gid找到原始网址</p><h3 id="3-分布式锁避免缓存击穿问题"><a href="#3-分布式锁避免缓存击穿问题" class="headerlink" title="3.分布式锁避免缓存击穿问题"></a>3.分布式锁避免缓存击穿问题</h3><p>加redis的分布式锁并进行双重判定</p><ol><li>首先，通过<code>stringRedisTemplate.opsForValue().get(...)</code>方法从Redis中获取原始链接（<code>originLink</code>）。</li><li>如果<code>originLink</code>为空（即Redis中没有对应的原始链接），则进入双重判定逻辑。</li><li>在双重判定逻辑中，首先获取分布式锁（<code>RLock lock = redissonClient.getLock(...)</code>），确保只有一个线程可以执行后续操作。</li><li>在获取锁之后，再次判定<code>originLink</code>是否为空。由于在获取锁之前可能有其他线程已经设置了原始链接，因此需要再次检查以避免重复操作。</li><li>如果再次判定后发现<code>originLink</code>不为空，说明在获取锁之前已经有其他线程设置了原始链接，此时直接重定向到原始链接并返回。</li><li>如果再次判定后<code>originLink</code>仍为空，则继续执行后续逻辑，包括从数据库查询相关信息、设置原始链接到Redis缓存中，并最终重定向到原始链接。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">RLock</span> lock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token constant">LOCK_GOTO_SHORT_LINK_KEY</span><span class="token punctuation">,</span> fullShortUrl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-布隆过滤器搭配锁机制避免缓存穿透"><a href="#4-布隆过滤器搭配锁机制避免缓存穿透" class="headerlink" title="4.布隆过滤器搭配锁机制避免缓存穿透"></a>4.布隆过滤器搭配锁机制避免缓存穿透</h3><p>当大量请求访问缓存时，先判断请求key是否存在于布隆过滤器中，存在则查询数据库，不存在则返回空，由于布隆过滤器存在误判，再对请求的key进行判断，判断其是否为空值，为空则请求数据库；接着通过分布式锁仅让一个请求访问数据库，如果数据存在，则加载数据，新增进缓存，如果不存在则缓存空值。</p><h3 id="5-通过缓存预热避免缓存雪崩、缓存穿透问题"><a href="#5-通过缓存预热避免缓存雪崩、缓存穿透问题" class="headerlink" title="5.通过缓存预热避免缓存雪崩、缓存穿透问题"></a>5.通过缓存预热避免缓存雪崩、缓存穿透问题</h3><p>创建短链接后</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>                        fullShortUrl<span class="token punctuation">,</span>                         requestParam<span class="token punctuation">.</span><span class="token function">getOriginUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        <span class="token class-name">LinkUtil</span><span class="token punctuation">.</span><span class="token function">getLinkCacheValidDate</span><span class="token punctuation">(</span>requestParam<span class="token punctuation">.</span><span class="token function">getValidDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span>                <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><h3 id="1-问题：开发用户登录功能时，需要查询用户记录，查询的UserDO总为NULL"><a href="#1-问题：开发用户登录功能时，需要查询用户记录，查询的UserDO总为NULL" class="headerlink" title="1.问题：开发用户登录功能时，需要查询用户记录，查询的UserDO总为NULL"></a>1.问题：开发用户登录功能时，需要查询用户记录，查询的UserDO总为NULL</h3><p>解决方法：由于使用了ShardingSphere进行分表，手动向数据库添加的用户记录是无法查询到的，只有通过接口测试向数据库中添加的用户记录，也就是通过用户注册功能添加的用户，才能被查询到。</p><h3 id="2-问题：在开发用户中台调用功能时，接口测试提示连接失败"><a href="#2-问题：在开发用户中台调用功能时，接口测试提示连接失败" class="headerlink" title="2.问题：在开发用户中台调用功能时，接口测试提示连接失败"></a>2.问题：在开发用户中台调用功能时，接口测试提示连接失败</h3><p>解决方法：idea中要将project和admin同时启动，因为admin中调用的时project中的方法，两个要全部启动</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>手搓Spring-07向虚拟机注册钩子，实现Bean对象的初始化和销毁方法</title>
      <link href="/2024/01/29/shou-cuo-spring-07-xiang-xu-ni-ji-zhu-ce-gou-zi-shi-xian-bean-dui-xiang-de-chu-shi-hua-he-xiao-hui-fang-fa/"/>
      <url>/2024/01/29/shou-cuo-spring-07-xiang-xu-ni-ji-zhu-ce-gou-zi-shi-xian-bean-dui-xiang-de-chu-shi-hua-he-xiao-hui-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="初始化和销毁方法"><a href="#初始化和销毁方法" class="headerlink" title="初始化和销毁方法"></a>初始化和销毁方法</h2><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>此部分我们希望可以在Bean初始化过程执行一些操作，比如做一些数据的加载执行，链接注册中心暴露RPC接口以及在Web程序关闭时执行链接断开，内存销毁等操作</p><p>需要满足用户可以在XML中配置初始化和销毁的方法，也可以通过实现类的方式处理，还可以通过注解的方式处理初始化操作</p><p>在spring.xml配置中添加init-method、destory-method两个注解，在配置文件加载的过程中，把注解配置一并定义到BeanDefinition的属性当中。在initializeBean初始化操作的工程中，就可以通过反射的方式来调用配置在Bean定义属性当中的方法信息了</p><p>如果是接口实现的方式，那么直接可以通过Bean对象调用对应接口定义的方法即可</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>个类图结构描述出来的就是本次新增 Bean 实例化过程中的初始化方法和销毁方法。</p><p>共实现了两种方式的初始化和销毁方法，xml配置和定义接口，所以这里既有 InitializingBean、DisposableBean 也有需要 XmlBeanDefinitionReader 加载 spring.xml 配置信息到 BeanDefinition 中。</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-02-02%20182118.png"></p><h3 id="定义初始化和销毁方法的接口"><a href="#定义初始化和销毁方法的接口" class="headerlink" title="定义初始化和销毁方法的接口"></a>定义初始化和销毁方法的接口</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-02-02%20183255.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-02-02%20183335.png"></p><h3 id="Bean属性定义新增初始化和销毁"><a href="#Bean属性定义新增初始化和销毁" class="headerlink" title="Bean属性定义新增初始化和销毁"></a>Bean属性定义新增初始化和销毁</h3><p>BeanDefinition中新增的两个属性：initMethodName、destroyMethodName</p><p>这两个属性是为了在spring.xml配置的Bean对象中，可以配置<code>init-method=&quot;initDataMethod&quot; destroy-method=&quot;destroyDataMethod&quot;</code>操作，最终实现的接口效果是一样的，一个是接口方法的直接调用，一个是在配置文件中读取到方法反射调用</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-02-02%20183831.png"></p><p>在XmlBeanDefinitionReader类中增加对新增属性的读取，并添加到BeanDeifnition中</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-02-02%20184830.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-02-02%20184906.png"></p><h3 id="执行Bean对象的初始化方法"><a href="#执行Bean对象的初始化方法" class="headerlink" title="执行Bean对象的初始化方法"></a>执行Bean对象的初始化方法</h3><p>在方法 invokeInitMethods 中，主要分为两块来执行实现了 InitializingBean 接口的操作，处理 afterPropertiesSet 方法。另外一个是判断配置信息 init-method 是否存在，执行反射调用 initMethod.invoke(bean)。这两种方式都可以在 Bean 对象初始化过程中进行处理加载 Bean 对象中的初始化操作，让使用者可以额外新增加自己想要的动作。</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-02-02%20190537.png"></p><h3 id="定义销毁方法适配器（接口和配置）"><a href="#定义销毁方法适配器（接口和配置）" class="headerlink" title="定义销毁方法适配器（接口和配置）"></a>定义销毁方法适配器（接口和配置）</h3><p>这两种销毁方式都是由AbstractApplicationContext在注册虚拟机钩子后，由虚拟机关闭前执行的操作动作</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-02-02%20191905.png"></p><h3 id="创建Bean时销毁方法对象"><a href="#创建Bean时销毁方法对象" class="headerlink" title="创建Bean时销毁方法对象"></a>创建Bean时销毁方法对象</h3><p>在创建 Bean 对象的实例的时候，需要把销毁方法保存起来，方便后续执行销毁动作进行调用。 那么这个销毁方法的具体方法信息，会被注册到 DefaultSingletonBeanRegistry 中新增加的 Map&lt;String, DisposableBean&gt; disposableBeans 属性中去，因为这个接口的方法最终可以被类 AbstractApplicationContext 的 close 方法通过 getBeanFactory().destroySingletons() 调用。</p><p>在注册销毁方法的时候，会根据是接口类型和配置类型统一交给 DisposableBeanAdapter 销毁适配器类来做统一处理。实现了某个接口的类可以被 instanceof 判断或者强转后调用接口方法</p><p><img src="C:\Users\huameng\AppData\Roaming\Typora\typora-user-images\image-20240202193107834.png" alt="image-20240202193107834"></p><p><img src="C:\Users\huameng\AppData\Roaming\Typora\typora-user-images\image-20240202193141973.png" alt="image-20240202193141973"></p><h3 id="虚拟机关闭钩子注册调用销毁方法"><a href="#虚拟机关闭钩子注册调用销毁方法" class="headerlink" title="虚拟机关闭钩子注册调用销毁方法"></a>虚拟机关闭钩子注册调用销毁方法</h3><p>首先在ConfigurableApplicationContext接口中定义注册虚拟机钩子的方法registerShutDownHook和手动执行关闭的方法close</p><p><img src="C:\Users\huameng\AppData\Roaming\Typora\typora-user-images\image-20240202193831929.png" alt="image-20240202193831929"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>手搓Spring-06实现应用上下文、自动识别、资源加载、扩展机制</title>
      <link href="/2024/01/28/shou-cuo-spring-06-shi-xian-ying-yong-shang-xia-wen-zi-dong-shi-bie-zi-yuan-jia-zai-kuo-zhan-ji-zhi/"/>
      <url>/2024/01/28/shou-cuo-spring-06-shi-xian-ying-yong-shang-xia-wen-zi-dong-shi-bie-zi-yuan-jia-zai-kuo-zhan-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="实现应用上下文"><a href="#实现应用上下文" class="headerlink" title="实现应用上下文"></a>实现应用上下文</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>DefaultListableBeanFactory、XmlBeanDefinitionReader，是我们在目前 Spring 框架中对于服务功能测试的使用方式，它能很好的体现出 Spring 是如何对 xml 加载以及注册Bean对象的操作过程，但这种方式是面向 Spring 本身的，还不具备一定的扩展性。 </p><p>这部分我们要把 Bean 对象扩展机制功能和对 Spring 框架上下文的包装融合起来，对外提供完整的服务。</p><h2 id="功能设计"><a href="#功能设计" class="headerlink" title="功能设计"></a>功能设计</h2><p>为了满足于在Bean对象从注册到实例化的过程中执行用户的自定义操作，需要在Bean的定义和初始化过程中插入接口类，这个接口再有外部去实现自己需要的服务</p><p>满足对Bean对象扩展的两个接口，也是Spring框架中比较重要的两个接口：BeanFactoryPostProcessor、BeanPostProcessor</p><p>BeanFactoryPostProcessor是Spring框架提供的容器扩展机制，允许Bean对象注册后但未实例化之前，对BeanDefinition执行修改操作</p><p>BeanPostProcessor是在Bean对象实例化之后修改Bean对象，也可以替换Bean对象</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Spring应用上下文和Bean对象扩展机制的类关系</p><p>以继承了 ListableBeanFactory 接口的 ApplicationContext 接口开始，扩展出一系列应用上下文的抽象实现类，并最终完成 ClassPathXmlApplicationContext 类的实现。而这个类就是最后交给用户使用的类。 </p><p>同时在实现应用上下文的过程中，通过定义接口：BeanFactoryPostProcessor、BeanPostProcessor 两个接口，把关于对 Bean 的扩展机制串联进去了。</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-28%20135349.png"></p><h3 id="定义BeanFactoryPostProcessor"><a href="#定义BeanFactoryPostProcessor" class="headerlink" title="定义BeanFactoryPostProcessor"></a>定义BeanFactoryPostProcessor</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-28%20170523.png"></p><h3 id="定义BeanPostProcessor"><a href="#定义BeanPostProcessor" class="headerlink" title="定义BeanPostProcessor"></a>定义BeanPostProcessor</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-28%20170916.png"></p><h3 id="定义上下文接口"><a href="#定义上下文接口" class="headerlink" title="定义上下文接口"></a>定义上下文接口</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-28%20171550.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-28%20171811.png"></p><h3 id="应用上下文抽象类实现"><a href="#应用上下文抽象类实现" class="headerlink" title="应用上下文抽象类实现"></a>应用上下文抽象类实现</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-28%20181913.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-28%20181932.png"></p><h3 id="获取Bean工厂和加载资源"><a href="#获取Bean工厂和加载资源" class="headerlink" title="获取Bean工厂和加载资源"></a>获取Bean工厂和加载资源</h3><p>在 refreshBeanFactory() 中主要是获取了 <code>DefaultListableBeanFactory</code> 的实例化以及对资源配置的加载操作 <code>loadBeanDefinitions(beanFactory)</code>，在加载完成后即可完成对 spring.xml 配置文件中 Bean 对象的定义和注册，同时也包括实现了接口 BeanFactoryPostProcessor、BeanPostProcessor 的配置 Bean 信息。</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-28%20201833.png"></p><h3 id="上下文中对配置信息的加载"><a href="#上下文中对配置信息的加载" class="headerlink" title="上下文中对配置信息的加载"></a>上下文中对配置信息的加载</h3><p>在AbstractXmlApplicationContext抽象类的loadBeanDefinitions方法实现中，使用XmlBeanDefinitionReader类，处理了关于XML文件配置信息的操作</p><p>getConfigLocations()方法是为了从入口上下文类拿到配置信息的地址描述</p><p><img src="C:\Users\huameng\AppData\Roaming\Typora\typora-user-images\image-20240128202715385.png" alt="image-20240128202715385"></p><h3 id="应用上下文实现类-ClassPathXmlApplicationContext"><a href="#应用上下文实现类-ClassPathXmlApplicationContext" class="headerlink" title="应用上下文实现类(ClassPathXmlApplicationContext)"></a>应用上下文实现类(ClassPathXmlApplicationContext)</h3><p>ClassPathXmlApplicationContext是具体对外给用户提供的应用上下文的方法</p><p><img src="C:\Users\huameng\AppData\Roaming\Typora\typora-user-images\image-20240128203324997.png" alt="image-20240128203324997"></p><h3 id="在Bean创建时完成前置和后置处理"><a href="#在Bean创建时完成前置和后置处理" class="headerlink" title="在Bean创建时完成前置和后置处理"></a>在Bean创建时完成前置和后置处理</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-29%20154215.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-29%20154316.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-29%20154334.png"></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><img src="C:\Users\huameng\AppData\Roaming\Typora\typora-user-images\image-20240128171409276.png" alt="image-20240128171409276"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-28%20172855.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-28%20173223.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-28%20173332.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-28%20173408.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>手搓Spring-05资源加载器解析文件注册对象</title>
      <link href="/2024/01/27/shou-cuo-spring-05-zi-yuan-jia-zai-qi-jie-xi-wen-jian-zhu-ce-dui-xiang/"/>
      <url>/2024/01/27/shou-cuo-spring-05-zi-yuan-jia-zai-qi-jie-xi-wen-jian-zhu-ce-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="设计与实现资源加载器，从Spring-xml解析和注册Bean对象"><a href="#设计与实现资源加载器，从Spring-xml解析和注册Bean对象" class="headerlink" title="设计与实现资源加载器，从Spring.xml解析和注册Bean对象"></a>设计与实现资源加载器，从Spring.xml解析和注册Bean对象</h1><p>目前实现的spring框架可以通过单元测试手动操作Bean对象的定义、注册和属性填充</p><p>可以将创建过程写入配置文件中来简化操作，通过spring配置文件的方式将Bean对象实例化</p><h2 id="功能设计"><a href="#功能设计" class="headerlink" title="功能设计"></a>功能设计</h2><p>根据需求背景，我们需要在现有的Spring框架雏形中添加一个资源解析器，也就是能读取classpath、本地文件和云文件的配置内容。</p><p>在读取配置文件信息后，接下来就是对配置文件中的Bean描述信息解析后进行注册操作，把Bean对象注册到Spring容器中</p><p>资源加载器属于相对独立的部分，它位于Spring框架核心包下的IO实现内容，主要用于处理Class、本地和云环境中的文件信息</p><p>当资源可以加载后，接下来就是解析和注册Bean到Spring中的操作，这部分功能需要和DefaultListableBeanFactory核心类结合起来</p><p>另外还要定义出Bean定义的读取接口BeanDefinitionReader以及做好对应的实现类，在实现类中完成对Bean对象的解析和注册</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h3><p>Spring Bean容器资源加载和使用类关系</p><p>为了能把Bean的定义、注册和初始化交给Spring.xml配置化处理，需要实现两大块内容：资源加载器和xml资源处理类，实现过程主要以对接口Resource、ResourceLoader的实现为主</p><p>BeanDefinitionReader接口是对资源的具体使用，将配置信息注册到Spring容器中去</p><p>在Resource资源加载器中包括ClassPath、系统文件、云配置文件，这三部分与Spring源码中的设计与实现保持一致，最终在DefaultResourceLoader中做具体的调用</p><p>接口BeanDefinition、抽象类AbstractBeanDefinitionReader、实现类XmlBeanDefinitionReader</p><p>主要功能是处理资源读取后的注册Bean容器的操作</p><p>接口负责定义，抽象类处理非接口功能外的注册Bean组件填充，最终类只关心具体的业务实现</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-27%20130304.png"></p><p>此外，本部分根据Spring源码，完善了相应接口的集成和实现的关系</p><p>HierarchicalBeanFactory，在Spring源码中它提供了可以获取父类BeanFactory的方法，属于一种扩展工程的层次子接口</p><p>AutowireCapableBeanFactory，是一个自动化处理Bean工厂配置的接口</p><p>ConfigurableBeanFactory，可获取 BeanPostProcessor、BeanClassLoader等的一个配置化接口</p><p>ConfigurableListableBeanFactory，提供分析和修改Bean以及预先实例化的操作接口</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-27%20132058.png"></p><h3 id="定义工具类"><a href="#定义工具类" class="headerlink" title="定义工具类"></a>定义工具类</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-27%20133605.png"></p><h3 id="资源加载接口定义和实现"><a href="#资源加载接口定义和实现" class="headerlink" title="资源加载接口定义和实现"></a>资源加载接口定义和实现</h3><p>在Spring框架下创建core.io核心包，主要用于处理资源加载流</p><p>定义Resource接口，提供获取流的方法，再分别实现三种不同的流文件操作</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-27%20132548.png"></p><p>ClassPath：</p><p>通过ClassLoader读取ClassPath下的文件信息</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-27%20133802.png"></p><p>FileSystem：</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-27%20134138.png"></p><p>Url：</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-27%20134452.png"></p><h3 id="包装资源加载器"><a href="#包装资源加载器" class="headerlink" title="包装资源加载器"></a>包装资源加载器</h3><p>定义接口：</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-27%20135700.png"></p><p>实现接口：</p><p>将三种类型的资源进行包装，判断是否为ClassPath、URL以及文件</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-27%20140140.png"></p><h3 id="Bean定义读取接口"><a href="#Bean定义读取接口" class="headerlink" title="Bean定义读取接口"></a>Bean定义读取接口</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-27%20140535.png"></p><h3 id="Bean定义抽象类实现"><a href="#Bean定义抽象类实现" class="headerlink" title="Bean定义抽象类实现"></a>Bean定义抽象类实现</h3><p>实现BeanDefinitionReader接口的前两个方法，并提供构造函数，让外部的调用使用方把Bean定义注入类</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-27%20141247.png"></p><h3 id="解析XML处理Bean注册"><a href="#解析XML处理Bean注册" class="headerlink" title="解析XML处理Bean注册"></a>解析XML处理Bean注册</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">XmlBeanDefinitionReader</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractBeanDefinitionReader</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">public</span> <span class="token class-name">XmlBeanDefinitionReader</span><span class="token punctuation">(</span><span class="token class-name">BeanDefinitionRegistry</span> registry<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token keyword">super</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>      <span class="token keyword">public</span> <span class="token class-name">XmlBeanDefinitionReader</span><span class="token punctuation">(</span><span class="token class-name">BeanDefinitionRegistry</span> registry<span class="token punctuation">,</span> <span class="token class-name">ResourceLoader</span> resourceLoader<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token keyword">super</span><span class="token punctuation">(</span>registry<span class="token punctuation">,</span> resourceLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>      <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">loadBeanDefinitions</span><span class="token punctuation">(</span><span class="token class-name">Resource</span> resource<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>             <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">InputStream</span> inputStream <span class="token operator">=</span> resource<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                 <span class="token function">doLoadBeanDefinition</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">&#125;</span>         <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">IOException</span> <span class="token operator">|</span> <span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeansException</span><span class="token punctuation">(</span><span class="token string">"IOException parsing XML document from"</span> <span class="token operator">+</span> resource<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>      <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">loadBeanDefinitions</span><span class="token punctuation">(</span><span class="token class-name">Resource</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> resources<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Resource</span> resource <span class="token operator">:</span> resources<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>             <span class="token function">loadBeanDefinitions</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>      <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">loadBeanDefinitions</span><span class="token punctuation">(</span><span class="token class-name">String</span> location<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">&#123;</span>         <span class="token class-name">ResourceLoader</span> resourceLoader <span class="token operator">=</span> <span class="token function">getResourceLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">Resource</span> resource <span class="token operator">=</span> resourceLoader<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">loadBeanDefinitions</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>      <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doLoadBeanDefinition</span><span class="token punctuation">(</span><span class="token class-name">InputStream</span> inputStream<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">&#123;</span>         <span class="token class-name">Document</span> doc <span class="token operator">=</span> <span class="token class-name">XmlUtil</span><span class="token punctuation">.</span><span class="token function">readXML</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">Element</span> root <span class="token operator">=</span> doc<span class="token punctuation">.</span><span class="token function">getDocumentElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">NodeList</span> childNodes <span class="token operator">=</span> root<span class="token punctuation">.</span><span class="token function">getChildNodes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>childNodes<span class="token punctuation">.</span><span class="token function">getLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>             <span class="token comment">//判断元素             if(!(childNodes.item(i) instanceof Element)) continue;             //判断对象             if(!"bean".equals(childNodes.item(i).getNodeName())) continue;              //解析标签             Element bean = (Element)childNodes.item(i);             String id = bean.getAttribute("id");             String name = bean.getAttribute("name");             String className = bean.getAttribute("class");              //获取class             Class&lt;?> clazz = Class.forName(className);             String beanName = StrUtil.isNotEmpty(id) ? id : name;             if(StrUtil.isEmpty(beanName))&#123;                 beanName = StrUtil.lowerFirst(clazz.getSimpleName());             &#125;              BeanDefinition beanDefinition = new BeanDefinition(clazz);              for(int j=0;j&lt;bean.getChildNodes().getLength();j++)&#123;                 if(!(bean.getChildNodes().item(j) instanceof Element)) continue;                 if(!"property".equals(bean.getChildNodes().item(j).getNodeName())) continue;                  Element property = (Element)bean.getChildNodes().item(j);                 String attrName = property.getAttribute("name");                 String attrValue = property.getAttribute("value");                 String attrRef = property.getAttribute("ref");                  Object value = StrUtil.isNotEmpty(attrRef) ? new BeanReference(attrRef) : attrValue;                  PropertyValue propertyValue = new PropertyValue(attrName, value);                 beanDefinition.getPropertyValues().addPropertyValue(propertyValue);              &#125;              if(getRegistry().containBeanDefinition(beanName))&#123;                 throw new BeansException("Duplicate beanName[" + beanName + "] is not allowed");             &#125;              getRegistry().registerBeanDefinition(beanName, beanDefinition);           &#125;      &#125; &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>手搓Spring-04为Bean对象注入属性和依赖Bean的功能实现</title>
      <link href="/2024/01/26/shou-cuo-spring-04-wei-bean-dui-xiang-zhu-ru-shu-xing-he-yi-lai-bean-de-gong-neng-shi-xian/"/>
      <url>/2024/01/26/shou-cuo-spring-04-wei-bean-dui-xiang-zhu-ru-shu-xing-he-yi-lai-bean-de-gong-neng-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="注入属性和依赖对象"><a href="#注入属性和依赖对象" class="headerlink" title="注入属性和依赖对象"></a>注入属性和依赖对象</h1><h2 id="功能设计"><a href="#功能设计" class="headerlink" title="功能设计"></a>功能设计</h2><p>完整的对象在实例化时是需要属性信息的，并且要在Bean创建时进行填充，此部分实现的就是这一功能</p><p>由于Bean使用newInstance或Cglib创建后，开始进行属性填充，那么可以在createBean方法中补全属性方法，添加applyPropertyValues操作</p><p>在bean定义BeanDefinition中添加PropertyValues信息</p><p>属性填充部分还要定义一个BeanReference，里面是一个简单的Bean名称，在实例化时进行递归创建和填充。在spring源码中，BeanReference是一个接口</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-26%20174258.png"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-26%20175105.png"></p><p><img src="C:\Users\huameng\AppData\Roaming\Typora\typora-user-images\image-20240126175556424.png" alt="image-20240126175556424"></p><h3 id="Bean定义补全"><a href="#Bean定义补全" class="headerlink" title="Bean定义补全"></a>Bean定义补全</h3><p>填充PropertyValues属性，对构造函数进行优化</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-26%20175908.png"></p><h3 id="BeanReference"><a href="#BeanReference" class="headerlink" title="BeanReference"></a>BeanReference</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-26%20190025.png"></p><h3 id="Bean属性填充"><a href="#Bean属性填充" class="headerlink" title="Bean属性填充"></a>Bean属性填充</h3><p>此处比较关键的地方在applyPropertyValues中，通过beanDefinition.getPropertyValues()进行循环属性填充操作</p><p>（此处并未处理循环依赖的问题）</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-26%20190647.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-26%20190857.png"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-27%20103324.png"></p><p>先把UserDao注入到Bean容器中</p><p>填充两种属性：普通属性和对象属性</p><p>然后正常获取userService对象</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-27%20104420.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>手搓Spring-03基于Cglib实现含构造函数的类实例化</title>
      <link href="/2024/01/21/shou-cuo-spring-03-ji-yu-cglib-shi-xian-han-gou-zao-han-shu-de-lei-shi-li-hua/"/>
      <url>/2024/01/21/shou-cuo-spring-03-ji-yu-cglib-shi-xian-han-gou-zao-han-shu-de-lei-shi-li-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="实现含有构造函数的类的实例化"><a href="#实现含有构造函数的类的实例化" class="headerlink" title="实现含有构造函数的类的实例化"></a>实现含有构造函数的类的实例化</h1><h2 id="功能设计"><a href="#功能设计" class="headerlink" title="功能设计"></a>功能设计</h2><p>由于<code>beanDefinition.getBeanClass().newInstance()</code>并未考虑实例化bean对象时的入参，所以需要实现有带参构造函数的bean的实例化</p><p>实现该部分功能主要考虑两部分：</p><blockquote><p>从哪把构造函数的入参信息传递到实例化操作中</p></blockquote><p>在BeanFactory中添加Object getBean(String name, Object…args)</p><blockquote><p>实例化含有构造函数的对象</p></blockquote><p>基于Java本身自带的方法DeclaredConstructor</p><p>使用Cglib动态创建Bean对象</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-24%20114033.png"></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>在现有工程中添加InstantiationStrategy接口，补充响应的getBean入参信息</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-22%20190131.png"></p><h3 id="新增getBean接口"><a href="#新增getBean接口" class="headerlink" title="新增getBean接口"></a>新增getBean接口</h3><p>重载一个含有入参信息的getBean方法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-22%20190355.png"></p><h3 id="定义实例化策略接口"><a href="#定义实例化策略接口" class="headerlink" title="定义实例化策略接口"></a>定义实例化策略接口</h3><p>添加必要的入参信息</p><p>ctor参数的目的就是为了拿到符合入参信息相对应的构造函数</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-22%20190850.png"></p><h3 id="JDK实例化"><a href="#JDK实例化" class="headerlink" title="JDK实例化"></a>JDK实例化</h3><p>使用beanDefinition获取class信息</p><p>ctor为空时是无构造函数实例化，不为空时是有构造函数的实例化</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-22%20193111.png"></p><h3 id="Cglib实例化"><a href="#Cglib实例化" class="headerlink" title="Cglib实例化"></a>Cglib实例化</h3><blockquote><p>CGLIB是一个强大的，高性能的代码生成库，它扩展了Java语言，为Java类提供了动态代理的功能。CGLIB可以在运行时动态生成字节码，用于创建目标类的子类，并覆盖其中的方法。这种技术通常被称为字节码增强。  </p><p>CGLIB主要用途是为那些无法使用标准Java动态代理的类创建代理。例如，对于没有实现接口的类，或者需要对类的final方法进行代理的情况，CGLIB是一个很好的选择。  </p><p>CGLIB的特点包括： - 高性能：相比Java标准动态代理，CGLIB通常更快。 - 支持对类的代理：CGLIB可以代理那些没有实现接口的类。 - 支持对final方法的代理：CGLIB可以代理那些类中的final方法。 </p><p> CGLIB的使用对于某些特定的应用场景非常有用，例如AOP（面向切面编程）框架，它可以通过CGLIB来创建代理类来实现横切关注点的功能。在Spring框架中，CGLIB也被广泛应用于创建代理对象。  </p><p>总的来说，CGLIB是一个强大的动态代码生成库，它为Java程序提供了一种灵活的方式来创建代理类，扩展类的功能，并实现一些高级的编程技术。</p></blockquote><p>maven中记得要导入cglib依赖</p><p>使用enhancer.create的方法来创建一个类的新实例。它接受构造函数的参数类型和要传递给构造函数的参数，并返回一个新的类实例。这种方式通常用于动态创建对象实例，尤其是在使用反射或代理技术时</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-22%20194327.png"></p><h3 id="创建策略调用"><a href="#创建策略调用" class="headerlink" title="创建策略调用"></a>创建策略调用</h3><p>首先定义一个创建对象的实例化策略属性类</p><p>抽取createBeanInstance方法，其中，Construtor代表了构造函数的个数</p><p>通过beanClass.getDeclaredConstructors()方法获取所有的构造函数</p><p>循环比对构造函数集合与入参信息的匹配情况</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-22%20200630.png"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-23%20184732.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-23%20184920.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>单例设计模式</title>
      <link href="/2024/01/20/dan-li-she-ji-mo-shi/"/>
      <url>/2024/01/20/dan-li-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式涉及到一个单一的类，确保只有单个对象被创建</p><p>这个类提供了一种访问其唯一的对象的方式，可以直接访问，&#x3D;&#x3D;不需要实例化该类的对象&#x3D;&#x3D;</p><p>单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供了一个全局访问点来访问该实例</p><blockquote><p>单例类只有一个实例，这个实例必须为自己创建，并且还要给其他对象提供这一实例</p></blockquote><p>单例类没有接口，不能继承，但能减少内存开销</p><blockquote><p>使用场景</p></blockquote><ul><li>唯一序列号</li><li>web中的计数器</li><li>创建对象消耗的资源过多时</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><blockquote><p>创建一个单例类</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> singleObject<span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">SingleObject</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token class-name">SingleObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SingleObject</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>懒汉式</p></blockquote><p>不支持多线程</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>支持多线程</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>饿汉式</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>双锁</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>手搓Spring-02实现Bean的定义、注册、获取</title>
      <link href="/2024/01/20/shou-cuo-spring-02-shi-xian-bean-de-ding-yi-zhu-ce-huo-qu/"/>
      <url>/2024/01/20/shou-cuo-spring-02-shi-xian-bean-de-ding-yi-zhu-ce-huo-qu/</url>
      
        <content type="html"><![CDATA[<h2 id="实现Bean的定义、注册、获取"><a href="#实现Bean的定义、注册、获取" class="headerlink" title="实现Bean的定义、注册、获取"></a>实现Bean的定义、注册、获取</h2><p>将Spring Bean容器的功能进行完善，实现Bean容器关于Bean对象的注册和获取</p><p>把Bean的创建交给容器，另外考虑单例对象，在对象的二次获取中可以从内存中获取对象</p><p>此外还要完善基础容器框架的结构体</p><blockquote><p>Spring Bean容器的完善</p></blockquote><p>在上一次的代码实现中，bean对象注册时是直接将一个实例化好的bean传入BeanDefintion中，本次代码要实现在Bean注册时只注册一个类信息，而不会把实例化信息注册到Bean容器中</p><p>实现这点需要修改BeanDefinition中的属性Object为Class，因为在注册bean对象时传入的并不是实例化后的对象，所以在获取bean对象时需要对bean进行实例化操作以及判断当前单例对象是否在容器中已经缓存起来了</p><p>单例对象的缓存由hashmap实现（在DefaultSingletonBeanRegistry中）</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-20%20182652.png"></p><blockquote><p>BeanDefinition</p></blockquote><p>将Object bean替换为Class，就可以把Bean的实例化操作放到容器中处理</p><blockquote><p>单例注册接口定义和实现</p></blockquote><p>定义一个获取单例对象的接口</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-20%20184727.png"></p><p>在DefaultSingletonBeanRegistry中主要实现getSingleton方法，同时实现一个受保护的addSingleton方法，可以被继承此类的其他类调用</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-20%20185310.png"></p><blockquote><p>抽象类定义模板方法AbstractBeanFactory</p></blockquote><p>AbstractBeanFactory继承了DefaultSingletonBeanRegistry，具备单例注册类方法</p><p>该方法对getBean的实现过程，主要是对单例Bean对象的获取以及在获取不到时拿到Bean的定义对Bean做实例化操作</p><p>getBean并没有自身去实现这些方法，而是定义了调用过程以及提供了调用方法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-20%20203524.png"></p><blockquote><p>实例化Bean类AbstractAutowireCapableBeanFactory</p></blockquote><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-20%20204123.png"></p><p>处理完实例化后，调用addSingleton方法存放到单例对象的缓存中</p><blockquote><p>核心类实现DefaultListableBeanFactory</p></blockquote><p>DefaultListableBeanFactory继承AbstractAutowireCapableBeanFactory类，那么也就实现了BeanFactory和AbstractBeanFactory等功能</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-21%20125634.png"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-21%20131500.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>手搓Spring-01创建一个Bean容器</title>
      <link href="/2024/01/20/shou-cuo-spring-01-chuang-jian-yi-ge-bean-rong-qi/"/>
      <url>/2024/01/20/shou-cuo-spring-01-chuang-jian-yi-ge-bean-rong-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="容器：IOC"><a href="#容器：IOC" class="headerlink" title="容器：IOC"></a>容器：IOC</h1><h2 id="创建简单的Bean容器"><a href="#创建简单的Bean容器" class="headerlink" title="创建简单的Bean容器"></a>创建简单的Bean容器</h2><blockquote><p>Spring Bean容器是什么？</p></blockquote><p>Spring包含并管理应用对象的配置和生命周期将一个Bean对象交给Spring后，该对象会被拆解后存放在Bean的定义中，存放后再由Spring统一进行装配，包括Bean对象的初始化、属性填充</p><blockquote><p>Bean容器的设计</p></blockquote><p>采用HashMap作为Spring Bean的容器</p><p>一个简单的Bean容器的实现需要Bean的定义、注册、获取三个步骤</p><p>Spring Bean容器的设计基于Spring源码进行了简化</p><ol><li>BeanDefinition：定义Bean实例化信息，以一个Object存放对象</li><li>BeanFactory：Bean对象的工厂</li></ol><blockquote><p>在BeanDefinition中，有一个Object用来存放bean对象，后续会完善相关属性的填充</p><p>BeanFactory中，有一个HashMap来存放bean对象，通过registerBeanDefinition进行bean的注册，即把通过BeanDefinition定义后的bean放入hashmap中</p></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><blockquote><p>Bean定义</p></blockquote><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-20%20143513.png"></p><p>简化的Bean定义中，暂时只用一个Object存放Bean对象</p><blockquote><p>Bean工厂</p></blockquote><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-20%20144018.png"></p><p>简化的Bean工厂中实现了Bean注册、Bean的获取</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><blockquote><p>准备一个测试的对象来对Spring容器进行测试</p></blockquote><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-20%20150639.png"></p><blockquote><p>测试用例</p></blockquote><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-20%20150731.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis-持久化、订阅发布、主从复制、缓存穿透和雪崩</title>
      <link href="/2024/01/15/redis-chi-jiu-hua-ding-yue-fa-bu-zhu-cong-fu-zhi-huan-cun-chuan-tou-he-xue-beng/"/>
      <url>/2024/01/15/redis-chi-jiu-hua-ding-yue-fa-bu-zhu-cong-fu-zhi-huan-cun-chuan-tou-he-xue-beng/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="RDB（Redis-Database）"><a href="#RDB（Redis-Database）" class="headerlink" title="RDB（Redis Database）"></a>RDB（Redis Database）</h2><blockquote><p>RDB是什么</p></blockquote><p>在指定时间间隔内将内存中的数据集快照写入磁盘，恢复时是将快照文件直接读到内存里</p><p>Redis会单独fork一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。</p><p>整个过程中，主进程不进行任何I&#x2F;O操作，确保了极高的性能。</p><p>如果需要大规模的数据的恢复，且对对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加高效</p><p>RDB的缺点是最后一次持久化后的数据可能丢失。</p><p>&#x3D;&#x3D;RDB保存的文件是dump.rdb&#x3D;&#x3D;</p><blockquote><p>如何恢复rdb文件？</p></blockquote><p>将rdb文件放在redis启动目录，redis启动的时候就会自动检查dump.rdb恢复其中的数据</p><blockquote><p>补充说明</p></blockquote><p>rdb适合大规模的数据恢复</p><p>对数据的完整性要求不高</p><p>需要一定的时间间隔进程操作</p><p>fork进程的时候，会占用一定的内容空间</p><h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><p>以日志的形式来记录每个写操作，将redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis重启后会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p><p>&#x3D;&#x3D;AOF保存的是appendonly.aof文件&#x3D;&#x3D;</p><p>AOF默认是不开启的，需要手动配置，重启redis生效</p><blockquote><p>如何对aof文件进行修复？</p></blockquote><p>当aof文件有错误时，redis无法启动，需要进行修复</p><p>使用&#x3D;&#x3D;redis-check-aof&#x3D;&#x3D;进行fix</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">redis-check-aof <span class="token parameter variable">--fix</span> appendonly.aof<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>补充说明</p></blockquote><p>可以设置每一次修改都同步，文件完整性高</p><p>默认设置为每秒同步一次</p><p>相对于数据文件来说，aof远远大于rdb，修复的速度比rdb慢</p><p>由于aof运行效率比rdb慢，redis默认配置是rdb持久化</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li>RDB持久化方式能够在指定时间间隔内对数据进行快照存储</li><li>AOF命令以redis协议追加每次写的操作到文件的末尾，redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大</li><li>只做缓存，如果只希望数据在服务器运行的时候存在，也可以不使用任何持久化</li><li>同时开启两种持久化<ul><li>在这种情况下，redis会优先载入AOF文件来恢复原始的数据，因为通常情况下AOF的数据集要比RDB保存的数据集要完整</li><li>RDB数据不实时，同时使用两者时服务器重启也只会找AOF文件，但AOF可能有潜在的bug</li></ul></li><li>因为RDB只用作后备用途，建议只在slave上持久化RDB文件，只保留<code>save 900 1</code></li></ol><h1 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h1><p>redis发布订阅是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息</p><p>redis客户端可以订阅任意数量的频道</p><p>redis通过PUBLISH、SUBSCRIBE、PSUBSCRIBE等命令实现发布和订阅功能</p><p>通过SUBSCRIBE命令订阅某频道后，redis-server里维护了一个字典，字典的键就是一个个频道，字典里的值是一个链表，链表中保存了所有订阅这个频道的客户端。</p><p>通过PUBLISH命令向订阅者发送消息，redis-server会使用给定的频道作为键，在它所维护的频道字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者</p><h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><p>主从复制，指将一台redis服务器的数据复制到其他的redis服务器，前者称为主节点，后者称为从节点。</p><p>数据的复制是单向的，只能从主节点到从节点。</p><p>默认情况下，每台redis服务器都是主节点，且一个主节点可以有多个从节点，一个从节点只能有一个主节点。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">info replication <span class="token comment"># 查看主从复制的信息</span>SLAVEOF <span class="token function">host</span> <span class="token number">6379</span> <span class="token comment"># 设置主机，使用命令行配置的主从，从机重启后就会变回主机</span>SLAVEOF no one <span class="token comment"># 取消主机设置</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>主从复制的作用</p></blockquote><ol><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式</li><li>故障恢复：主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复</li><li>复杂均衡</li><li>实现高可用</li></ol><p> 复制配置文件，修改对应信息</p><ol><li>端口</li><li>pid</li><li>log文件名</li><li>dump.rdb文件名</li></ol><p> 主机可以写，从机只能读，主机所有的数据都会被从机保存</p><blockquote><p>复制原理</p></blockquote><p>slave启动成功连接到master后会发送一个sync同步命令</p><p>master接收到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕后，master将传送整个数据文件到slave，并完成一次完全同步</p><p>&#x3D;&#x3D;全量复制：&#x3D;&#x3D;slave在接收到数据库文件数据后，将其存盘并加载到内存中</p><p>&#x3D;&#x3D;增量复制：&#x3D;&#x3D;master继续将新的所有收集到的修改命令依次传给slave，完成同步</p><p>只要是重新连接master，一次完全同步将被自动执行</p><h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><p>自动切换主服务器的模式</p><p>Redis2.8开始正式提供了Sentinel架构来解决这个问题</p><p>哨兵模式能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p><p>哨兵是一个独立的进程，作为进程，它会独立运行</p><p>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例</p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态</li><li>当哨兵检测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的服务器，修改配置文件，让他们切换主机</li><li>可以使用多个哨兵进行监控，各个哨兵之间还可以互相监控，形成多哨兵模式</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> sentinel.conf <span class="token comment"># 配置哨兵配置文件</span>sentinel monitor myredis <span class="token number">127.0</span>.0.1 <span class="token number">6379</span> <span class="token number">1</span> <span class="token comment"># sentinel monitor 被监控的名称 host port 1</span>redis-sentinel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>主机宕机后，哨兵通过投票算法选择从机中票数最高的从机作为主机</p><p>主机重连后，会被归并到其他的主机下</p><h1 id="Redis缓存穿透和雪崩"><a href="#Redis缓存穿透和雪崩" class="headerlink" title="Redis缓存穿透和雪崩"></a>Redis缓存穿透和雪崩</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>布隆过滤器：对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃</p><p>缓存空对象：当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>设置热点数据永不过期</p><p>加互斥锁</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>某个时间段，缓存集中过期失效</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【MIT6.S081】-Lab4</title>
      <link href="/2023/11/28/mit6.s081-lab4/"/>
      <url>/2023/11/28/mit6.s081-lab4/</url>
      
        <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li>阅读<a href="https://pdos.csail.mit.edu/6.828/2020/readings/riscv-calling.pdf">calling convention</a></li><li>阅读xv6 book的chapter4</li><li>阅读源码kernel&#x2F;memlayout.h，kernel&#x2F;vm.c，kernel&#x2F;kalloc.c，kernel&#x2F;risv.h，kernel&#x2F;exec.c</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>外卖管理系统开发日志</title>
      <link href="/2023/11/11/wai-mai-xiang-mu-kai-fa-ri-zhi/"/>
      <url>/2023/11/11/wai-mai-xiang-mu-kai-fa-ri-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="本项目分为系统管理后台和移动端应用两部分"><a href="#本项目分为系统管理后台和移动端应用两部分" class="headerlink" title="本项目分为系统管理后台和移动端应用两部分"></a>本项目分为系统管理后台和移动端应用两部分</h1><h1 id="移动端前台："><a href="#移动端前台：" class="headerlink" title="移动端前台："></a>移动端前台：</h1><p>手机号登录</p><p>微信登录</p><p>地址管理</p><p>历史订单</p><p>菜品规格</p><p>购物车</p><p>下单</p><p>菜品浏览</p><h1 id="系统管理后台"><a href="#系统管理后台" class="headerlink" title="系统管理后台"></a>系统管理后台</h1><p>分类管理</p><p>菜品管理</p><p>套餐管理</p><p>菜品口味管理</p><p>员工登录</p><p>员工退出</p><p>员工管理</p><p>订单管理</p><h1 id="数据库环境搭建"><a href="#数据库环境搭建" class="headerlink" title="数据库环境搭建"></a>数据库环境搭建</h1><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-11%20114631.png"></p><h1 id="Maven项目搭建"><a href="#Maven项目搭建" class="headerlink" title="Maven项目搭建"></a>Maven项目搭建</h1><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">?</span>xml version<span class="token operator">=</span><span class="token string">"1.0"</span> encoding<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">?</span><span class="token operator">></span><span class="token operator">&lt;</span>project xmlns<span class="token operator">=</span><span class="token string">"http://maven.apache.org/POM/4.0.0"</span>         xmlns<span class="token operator">:</span>xsi<span class="token operator">=</span><span class="token string">"http://www.w3.org/2001/XMLSchema-instance"</span>         xsi<span class="token operator">:</span>schemaLocation<span class="token operator">=</span><span class="token string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span><span class="token operator">></span>    <span class="token generics"><span class="token punctuation">&lt;</span>modelVersion<span class="token punctuation">></span></span><span class="token number">4.0</span><span class="token number">.0</span><span class="token operator">&lt;</span><span class="token operator">/</span>modelVersion<span class="token operator">></span>    <span class="token generics"><span class="token punctuation">&lt;</span>parent<span class="token punctuation">></span></span>        <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>        <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>parent<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>        <span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">></span></span><span class="token number">2.4</span><span class="token number">.5</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span>relativePath<span class="token operator">/</span><span class="token operator">></span> <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> lookup parent from repository <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>parent<span class="token operator">></span>    <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>com<span class="token punctuation">.</span>huameng<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>    <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>quickbite<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>    <span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">></span></span><span class="token number">1.0</span><span class="token operator">-</span><span class="token constant">SNAPSHOT</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>    <span class="token generics"><span class="token punctuation">&lt;</span>properties<span class="token punctuation">></span></span>        <span class="token generics"><span class="token punctuation">&lt;</span>java<span class="token punctuation">.</span>version<span class="token punctuation">></span></span><span class="token number">1.8</span><span class="token operator">&lt;</span><span class="token operator">/</span>java<span class="token punctuation">.</span>version<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>properties<span class="token operator">></span>    <span class="token generics"><span class="token punctuation">&lt;</span>dependencies<span class="token punctuation">></span></span>        <span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">></span></span>            <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>        <span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">></span></span>            <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>test<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>scope<span class="token punctuation">></span></span>test<span class="token operator">&lt;</span><span class="token operator">/</span>scope<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>        <span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">></span></span>        <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>web<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>scope<span class="token punctuation">></span></span>compile<span class="token operator">&lt;</span><span class="token operator">/</span>scope<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>        <span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">></span></span>            <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>com<span class="token punctuation">.</span>baomidou<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>mybatis<span class="token operator">-</span>plus<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">></span></span><span class="token number">3.4</span><span class="token number">.2</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>        <span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">></span></span>            <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>org<span class="token punctuation">.</span>projectlombok<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>lombok<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">></span></span><span class="token number">1.18</span><span class="token number">.20</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>        <span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">></span></span>            <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>com<span class="token punctuation">.</span>alibaba<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>fastjson<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">></span></span><span class="token number">1.2</span><span class="token number">.76</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>        <span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">></span></span>            <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>commons<span class="token operator">-</span>lang<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>commons<span class="token operator">-</span>lang<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">></span></span><span class="token number">2.6</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>        <span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">></span></span>            <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>mysql<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>mysql<span class="token operator">-</span>connector<span class="token operator">-</span>java<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>scope<span class="token punctuation">></span></span>runtime<span class="token operator">&lt;</span><span class="token operator">/</span>scope<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>        <span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">></span></span>            <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>com<span class="token punctuation">.</span>alibaba<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>druid<span class="token operator">-</span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">></span></span><span class="token number">1.1</span><span class="token number">.23</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>dependencies<span class="token operator">></span>    <span class="token generics"><span class="token punctuation">&lt;</span>build<span class="token punctuation">></span></span>        <span class="token generics"><span class="token punctuation">&lt;</span>plugins<span class="token punctuation">></span></span>            <span class="token generics"><span class="token punctuation">&lt;</span>plugin<span class="token punctuation">></span></span>                <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>                <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>maven<span class="token operator">-</span>plugin<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>                <span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">></span></span><span class="token number">2.4</span><span class="token number">.5</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">/</span>plugin<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>plugins<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>build<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>project<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">server<span class="token operator">:</span>  port<span class="token operator">:</span> <span class="token number">8080</span>spring<span class="token operator">:</span>  application<span class="token operator">:</span>    name<span class="token operator">:</span> <span class="token class-name">Quickbite</span>  datasource<span class="token operator">:</span>    druid<span class="token operator">:</span>      driver<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">-</span>name<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>cj<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span></span>Driver</span>      url<span class="token operator">:</span> jdbc<span class="token operator">:</span>mysql<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">:</span><span class="token number">3306</span><span class="token operator">/</span>quickbite<span class="token operator">?</span>serverTimezone<span class="token operator">=</span><span class="token class-name">Asia</span><span class="token operator">/</span><span class="token class-name">Shanghai</span><span class="token operator">&amp;</span>useUnicode<span class="token operator">=</span><span class="token boolean">true</span><span class="token operator">&amp;</span>characterEncoding<span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span><span class="token operator">&amp;</span>zeroDateTimeBehavior<span class="token operator">=</span>convertToNull<span class="token operator">&amp;</span>useSSL<span class="token operator">=</span><span class="token boolean">false</span><span class="token operator">&amp;</span>allowPublicKeyRetrieval<span class="token operator">=</span><span class="token boolean">true</span>      username<span class="token operator">:</span> root      password<span class="token operator">:</span> rootmybatis<span class="token operator">-</span>plus<span class="token operator">:</span>  configuration<span class="token operator">:</span>    #在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射    map<span class="token operator">-</span>underscore<span class="token operator">-</span><span class="token keyword">to</span><span class="token operator">-</span>camel<span class="token operator">-</span><span class="token keyword">case</span><span class="token operator">:</span> <span class="token boolean">true</span>    log<span class="token operator">-</span>impl<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>logging<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span></span>StdOutImpl</span>  global<span class="token operator">-</span>config<span class="token operator">:</span>    db<span class="token operator">-</span>config<span class="token operator">:</span>      id<span class="token operator">-</span>type<span class="token operator">:</span> <span class="token constant">ASSIGN_ID</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="编写启动类"><a href="#编写启动类" class="headerlink" title="编写启动类"></a>编写启动类</h2><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-17%20125159.png"></p><p>出现的问题：</p><p><code>log.info</code>处报错</p><p>解决：</p><p>在setting-&gt;plugins中添加lombook插件</p><h2 id="导入前端页面"><a href="#导入前端页面" class="headerlink" title="导入前端页面"></a>导入前端页面</h2><h3 id="设置MVC静态资源映射"><a href="#设置MVC静态资源映射" class="headerlink" title="设置MVC静态资源映射"></a>设置MVC静态资源映射</h3><p>创建package</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-17%20125818.png"></p><p>在该package中创建WebMvcConfig类</p><p>添加注解</p><p>重写add方法，进行静态资源映射</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-17%20131027.png"></p><h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-18%20165123.png"></p><h2 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h2><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-18%20165745.png"></p><p>启动项目访问 <a href="http://127.0.0.1:8080/swagger-ui.html">http://127.0.0.1:8080/swagger-ui.html</a> 打开可视化测试页面</p><h2 id="两个必须解决的重要问题！"><a href="#两个必须解决的重要问题！" class="headerlink" title="两个必须解决的重要问题！"></a>两个必须解决的重要问题！</h2><p>在WebMvcConfig中加入</p><p>解决静态资源映射冲突问题</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-18%20180526.png"></p><p>在LoginCheckFilter将swagger的URI放行</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-18%20180929.png"></p><p>成功加载</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-18%20181029.png"></p><h1 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h1><h2 id="创建与employee表映射的实体类Employee"><a href="#创建与employee表映射的实体类Employee" class="headerlink" title="创建与employee表映射的实体类Employee"></a>创建与employee表映射的实体类Employee</h2><p>创建entity实体包用于存放实体类</p><p>Employee中的变量定义要与表中对应</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-17%20133627.png"></p><h2 id="实现controller、service、mapper"><a href="#实现controller、service、mapper" class="headerlink" title="实现controller、service、mapper"></a>实现controller、service、mapper</h2><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-17%20134056.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-17%20134613.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-17%20134925.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-17%20135204.png"></p><h2 id="导入返回结果类R"><a href="#导入返回结果类R" class="headerlink" title="导入返回结果类R"></a>导入返回结果类R</h2><p>设置泛型类增强通用性</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-17%20140242.png"></p><h2 id="在controller中创建登录方法"><a href="#在controller中创建登录方法" class="headerlink" title="在controller中创建登录方法"></a>在controller中创建登录方法</h2><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-17%20143506.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-17%20144730.png"></p><h2 id="未登录的跳转功能"><a href="#未登录的跳转功能" class="headerlink" title="未登录的跳转功能"></a>未登录的跳转功能</h2><p>限制未登录的员工的访问，当未登录员工要访问其他页面时跳转到登录页面</p><p>使用过滤器或者拦截器来实现功能</p><p>跳转功能由前端实现，后端只需相应数据由前端进行判断</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-17%20154829.png"></p><p>在启动类中添加注解</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-17%20154905.png"></p><h1 id="退出功能"><a href="#退出功能" class="headerlink" title="退出功能"></a>退出功能</h1><p>用户界面点击退出按钮，发送请求，请求地址为&#x2F;employee&#x2F;logout，请求方式为POST</p><p>处理逻辑</p><p>清理session中用户的id</p><p>返回结果</p><p>在employeecontroller中添加方法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-17%20153612.png"></p><p>创建logincheckfilter类</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-17%20160935.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-17%20161001.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-17%20161023.png"></p><h1 id="员工管理功能"><a href="#员工管理功能" class="headerlink" title="员工管理功能"></a>员工管理功能</h1><h2 id="新增员工"><a href="#新增员工" class="headerlink" title="新增员工"></a>新增员工</h2><p>页面发送ajax请求，将新增员工页面中的数据以json的形式提交到服务端</p><p>服务端controller接收数据并调用service对数据进行保存</p><p>service调用mapper操作数据库，保存数据</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-17%20164438.png"></p><h2 id="处理重复添加员工出现的异常"><a href="#处理重复添加员工出现的异常" class="headerlink" title="处理重复添加员工出现的异常"></a>处理重复添加员工出现的异常</h2><p>定义一个全局处理异常类</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-17%20191142.png"></p><h2 id="员工信息分页查询"><a href="#员工信息分页查询" class="headerlink" title="员工信息分页查询"></a>员工信息分页查询</h2><p>页面发送sjax请求，将分页查询参数（page、pageSize、name）提交到服务端</p><p>服务端Controller接收页面提交的数据并调用service查询数据</p><p>Controller将查询到的分页数据并通过elementUI的table组件展示到页面上</p><p>使用mybatis分页插件</p><p><img src="C:\Users\huameng\AppData\Roaming\Typora\typora-user-images\image-20231118091918431.png" alt="image-20231118091918431"></p><p><img src="C:\Users\huameng\AppData\Roaming\Typora\typora-user-images\image-20231118091909507.png"></p><h2 id="启用-x2F-禁用员工账号"><a href="#启用-x2F-禁用员工账号" class="headerlink" title="启用&#x2F;禁用员工账号"></a>启用&#x2F;禁用员工账号</h2><p>在controller中创建update方法进行员工信息的通用修改</p><blockquote><p>在服务端给页面响应json数据时进行处理，将long型数据统一转为String</p><ol><li>提供对象转换器JacksonObjectMapper，基于Jackson进行java对象到Json数据的转换</li><li>在WebMvcConfig配置类中扩展Spring mvc的消息转换器，在此消息转换器中使用提供的对象转换器进行java对象到Json数据的转换</li></ol></blockquote><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-18%20100742.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-18%20101402.png"></p><h2 id="编辑员工信息"><a href="#编辑员工信息" class="headerlink" title="编辑员工信息"></a>编辑员工信息</h2><p>点击编辑按钮，跳转到add.html，在url中携带员工id</p><p>在add.html页面中获取url的参数</p><p>发送ajax请求，请求服务端，同时提交员工id参数</p><p>服务端接收请求，根据员工id查询员工信息，将员工信息以json形式响应给页面</p><p>页面接收json数据，通过VUE的数据绑定进行员工信息回显</p><p>点击保存按钮，发送ajax请求，将页面中的员工信息以json方式提交给服务端</p><p>服务端接收员工信息并处理，完成后交给页面响应</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-18%20112708.png"></p><h1 id="分类管理功能"><a href="#分类管理功能" class="headerlink" title="分类管理功能"></a>分类管理功能</h1><h2 id="公共字段填充"><a href="#公共字段填充" class="headerlink" title="公共字段填充"></a>公共字段填充</h2><p>在实体类上加入<code>@TableField</code>注解，指定自动填充的策略</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-18%20152745.png"></p><p>编写元数据对象处理器，实现<code>MetaObjectHandler</code>接口</p><p>由于<code>MyMetaObjectHandler</code>中不能获取<code>session</code>，所以使用<code>ThreadLocal</code>来动态获取用户的id</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-18%20154554.png"></p><p>客户端发送的每次http请求，对应在服务端都会分配一个新的线程来处理</p><p>处理过程中涉及的类中的方法都属于同一个进程</p><p>在<code>LoginCheckFilter</code>的<code>doFilter</code>、<code>EmployeeController</code>的<code>update</code>、<code>MyMetaObjectHandler</code>的<code>updateFill</code>方法中添加获取进程id的代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> id <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"线程id：&#123;&#125;"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>&#x3D;&#x3D;什么是ThreadLocal？&#x3D;&#x3D;</p><p>TL是Thread的局部变量，为每个使用变量的线程提供一个独立的变量副本。</p><p>TL为每个线程提供单独一份存储空间，具有线程隔离的效果</p><p>常用方法：</p><p><code>public void set(T value)</code>设置当前线程的线程局部变量的值</p><p><code>public T get()</code>返回当前线程所对应的线程局部变量的值</p></blockquote><p>在<code>LoginCheckFilter</code>的<code>doFilter</code>方法中获取当前登录用户id，调用set方法设置线程局部变量的值（id），在<code>MyMetaObjectHandler</code>的<code>updateFill</code>调用get方法获取变量的值</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-18%20161649.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-18%20161717.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-18%20161740.png"></p><h2 id="新增分类"><a href="#新增分类" class="headerlink" title="新增分类"></a>新增分类</h2><p>分类分为两种：菜品分类和套餐分类</p><p>实体类：<code>category</code></p><p>mapper接口<code>categorymapper</code></p><p>业务层接口<code>categoryserviceimpl</code></p><p>控制层<code>categorycontroller</code></p><h3 id="添加实体类Category"><a href="#添加实体类Category" class="headerlink" title="添加实体类Category"></a>添加实体类Category</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-20%20091018.png"></p><h3 id="添加CategoryMapper"><a href="#添加CategoryMapper" class="headerlink" title="添加CategoryMapper"></a>添加CategoryMapper</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-20%20091117.png"></p><h3 id="添加CategoryService"><a href="#添加CategoryService" class="headerlink" title="添加CategoryService"></a>添加CategoryService</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-20%20091225.png"></p><h3 id="添加Service实现类"><a href="#添加Service实现类" class="headerlink" title="添加Service实现类"></a>添加Service实现类</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-20%20091319.png"></p><h3 id="代码开发"><a href="#代码开发" class="headerlink" title="代码开发"></a>代码开发</h3><p>backend&#x2F;page&#x2F;category&#x2F;list.html发送ajax请求</p><p>新增套餐分类和新增菜品分类请求的服务端地址和提交的JSON数据结构相同，所以用一个方法处理</p><p>CategoryController</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-20%20150636.png"></p><h2 id="分类信息分页查询"><a href="#分类信息分页查询" class="headerlink" title="分类信息分页查询"></a>分类信息分页查询</h2><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-20%20155652.png"></p><h2 id="删除分类"><a href="#删除分类" class="headerlink" title="删除分类"></a>删除分类</h2><p>当分类关联了菜品或套餐时，此分类不允许删除</p><p>页面发送ajax请求，将参数id提交到服务端</p><p>服务端controller接受页面提交的数据调用service删除数据</p><p>service调用mapper操作数据库</p><h3 id="实体类Dish和Setmeal"><a href="#实体类Dish和Setmeal" class="headerlink" title="实体类Dish和Setmeal"></a>实体类Dish和Setmeal</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-20%20170605.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-20%20170634.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-20%20171612.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-20%20171644.png"></p><h3 id="Mapper接口"><a href="#Mapper接口" class="headerlink" title="Mapper接口"></a>Mapper接口</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-20%20171926.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-20%20172000.png"></p><h3 id="Service接口"><a href="#Service接口" class="headerlink" title="Service接口"></a>Service接口</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-20%20172212.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-20%20172238.png"></p><h3 id="Service实现类"><a href="#Service实现类" class="headerlink" title="Service实现类"></a>Service实现类</h3><p><img src="C:\Users\huameng\AppData\Roaming\Typora\typora-user-images\image-20231121090334714.png" alt="image-20231121090334714"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-21%20090316.png"></p><h3 id="在Service实现类中重写remove方法"><a href="#在Service实现类中重写remove方法" class="headerlink" title="在Service实现类中重写remove方法"></a>在Service实现类中重写remove方法</h3><p>在categoryservice中添加声明</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-21%20092052.png"></p><p>在实现类中重写remove方法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-21%20092141.png"></p><h3 id="添加异常类CustomException"><a href="#添加异常类CustomException" class="headerlink" title="添加异常类CustomException"></a>添加异常类CustomException</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-21%20092432.png"></p><h3 id="添加全局异常"><a href="#添加全局异常" class="headerlink" title="添加全局异常"></a>添加全局异常</h3><p>在GlobalException中添加代码</p><p>目的是在前端反馈错误提示页面</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-21%20092830.png"></p><p>接下来在remove方法中需要抛出异常的位置添加代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CustomExceptiom</span><span class="token punctuation">(</span><span class="token string">"当前分类已关联菜品，不能删除"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CustomExceptiom</span><span class="token punctuation">(</span><span class="token string">"当前分类已关联套餐，不能删除"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在controller中调用remove方法即可</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@DeletedMapping</span><span class="token keyword">public</span> <span class="token class-name">R</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">deleteCategory</span><span class="token punctuation">(</span><span class="token class-name">Long</span> ids<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    categorySerice<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>ids<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">R</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token string">"..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修改分类"><a href="#修改分类" class="headerlink" title="修改分类"></a>修改分类</h2><p>在categorycontroller中添加update方法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-21%20101854.png"></p><h1 id="菜品管理功能"><a href="#菜品管理功能" class="headerlink" title="菜品管理功能"></a>菜品管理功能</h1><h2 id="文件上传下载"><a href="#文件上传下载" class="headerlink" title="文件上传下载"></a>文件上传下载</h2><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>文件上传对form表单的要求</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">method <span class="token operator">=</span> <span class="token string">"post"</span> <span class="token comment">//采用post方式提交数据</span>enctype <span class="token operator">=</span> <span class="token string">"multipart/form-data"</span> <span class="token comment">//采用multipart格式上传文件</span>    type <span class="token operator">=</span> <span class="token string">"file"</span> <span class="token comment">//使用input的file控件上传</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>服务端接收机客户端页面上传的文件，通常会使用Apache的两个组件：<code>commons-fileupload</code>、<code>commons-io</code></p><p>Spring框架在spring-web包中对文件上传进行了封装，只需在controller的方法中声明一个<code>MultipartFile</code>类型的参数即可接收上传的文件</p><p>在该项目中，页面端使用ElementUI提供的上传组件</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>el-upload</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>avatar-uploader<span class="token punctuation">"</span></span>           <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/commom/upload<span class="token punctuation">"</span></span>           <span class="token attr-name">:show-file-list</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span>           <span class="token attr-name">:on-success</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>handleAvatarSuccess<span class="token punctuation">"</span></span>           <span class="token attr-name">:before-upload</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>beforeUpload<span class="token punctuation">"</span></span>           <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>upload<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>imageUrl<span class="token punctuation">"</span></span> <span class="token attr-name">:src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>imageUrl<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>avatar<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>img</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">v-else</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>el-icon-plus avatar-uploader-icon<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>el-upload</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将upload.html放在resource下  并在head中加入 </p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>shortcut icon<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>../../favicon.ico<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>添加CommonController类，用于文件的上传和下载</p><p>添加upload方法用于文件的上传</p><p>注意：upload接受的参数必须为MultipartFile类型，且参数名需要和前端传来的name的值保持一致</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-21%20114045.png"></p><h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><p>通过浏览器进行文件下载一般有两种形式：附件形式下载、直接在浏览器中打开</p><p>通过浏览器进行文件下载，本质上是将服务端的文件以流的形式写回浏览器的过程</p><p>页面端使用<img>标签展示下载的图片</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>imageUrl<span class="token punctuation">"</span></span> <span class="token attr-name">:src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>imageUrl<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>avatar<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>img</span><span class="token punctuation">></span></span>handleAvatarSuccess(response, file, fileList) &#123;this.imageUrl = '/common/download?name=$&#123;response.data&#125;'&#125;,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-21%20123817.png"></p><h2 id="新增菜品"><a href="#新增菜品" class="headerlink" title="新增菜品"></a>新增菜品</h2><h3 id="准备类和接口"><a href="#准备类和接口" class="headerlink" title="准备类和接口"></a>准备类和接口</h3><p>实体类<code>DishFlavor</code></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-21%20133038.png"></p><p>Mapper接口<code>DishFlavorMapper</code></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-21%20133114.png"></p><p>业务层接口<code>DishFlavorService</code></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-21%20133135.png">实现类<code>DishFLavorServiceImpl</code></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-21%20133153.png"></p><p>控制层<code>DishController</code></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-21%20133221.png"></p><h3 id="交互过程"><a href="#交互过程" class="headerlink" title="交互过程"></a>交互过程</h3><p>页面发送ajax请求，请求服务端获取菜品分类数据并展示到下拉框中</p><p>页面发送请求进行图片上传，请求服务端将图片保存到服务器</p><p>页面发送请求进行图片下载，将上传的图片进行回显</p><p>点击保存，发送ajax请求，将菜品相关数据以json形式提交到服务端</p><h3 id="菜品分类查询"><a href="#菜品分类查询" class="headerlink" title="菜品分类查询"></a>菜品分类查询</h3><p>在新增菜品时对现有的菜品分类进行查询</p><p>在categorycontroller中添加</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-21%20141236.png"></p><h3 id="接收页面提交的数据"><a href="#接收页面提交的数据" class="headerlink" title="接收页面提交的数据"></a>接收页面提交的数据</h3><p>导入DishDto类，用于封装页面提交的数据</p><p>DTO，Data Transfer Object，即数据传输对象，一般用于展示层与服务层之间的数据传输</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-22%20101314.png"></p><p>由于此次要操作两张表</p><p>所以需要重写save方法</p><p>先在DishService中添加声明</p><p>在Service实现类中实现方法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-22%20103506.png"></p><p>启动类中开启Transactional</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-22%20103548.png"></p><p>DishController中实现新增菜品方法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-22%20103656.png"></p><h2 id="菜品信息分页查询"><a href="#菜品信息分页查询" class="headerlink" title="菜品信息分页查询"></a>菜品信息分页查询</h2><h3 id="交互过程-1"><a href="#交互过程-1" class="headerlink" title="交互过程"></a>交互过程</h3><p>页面发送ajax请求，将分页查询参数提交到服务端，获取分页数据</p><p>页面发送请求，请求服务端进行图片下载，用于页面展示</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-22%20115644.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-22%20115714.png"></p><h2 id="修改菜品"><a href="#修改菜品" class="headerlink" title="修改菜品"></a>修改菜品</h2><h3 id="交互过程-2"><a href="#交互过程-2" class="headerlink" title="交互过程"></a>交互过程</h3><p>页面发送ajax请求，请求服务端获取分类数据，用于菜品分类下拉框中数据显示（在新增菜品中已经实现）</p><p>页面发送ajax请求，请求服务端，根据id查询当前菜品信息，用于菜品信息回显</p><p>页面发送请求，页面发送ajax请求，将修改后的菜品相关数据以json形式提交到服务端</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>实现getByIdWithFlavor</p><p>在DishService中声明</p><p>在实现类中实现方法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-22%20121321.png"></p><p>在controller中调用方法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-22%20121516.png"></p><p>实现updatewithflavor</p><p>在dishservice中添加声明</p><p>在实现类中实现</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-22%20124004.png"></p><p>在controller中调用方法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-22%20124041.png"></p><h2 id="停售-x2F-起售菜品"><a href="#停售-x2F-起售菜品" class="headerlink" title="停售&#x2F;起售菜品"></a>停售&#x2F;起售菜品</h2><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-01%20224940.png"></p><h2 id="删除菜品"><a href="#删除菜品" class="headerlink" title="删除菜品"></a>删除菜品</h2><h1 id="套餐管理功能"><a href="#套餐管理功能" class="headerlink" title="套餐管理功能"></a>套餐管理功能</h1><h2 id="新增套餐"><a href="#新增套餐" class="headerlink" title="新增套餐"></a>新增套餐</h2><h3 id="准备需要的类和接口"><a href="#准备需要的类和接口" class="headerlink" title="准备需要的类和接口"></a>准备需要的类和接口</h3><p>实体类SetmealDish</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-23%20195030.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-23%20195104.png"></p><p>DTO SetmaelDto</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-23%20195134.png"></p><p>SetmealDishMapper</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-23%20195208.png"></p><p>SetmealDishService</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-23%20195226.png"></p><p>SetmealDishServiceImpl</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-23%20195257.png"></p><h3 id="交互过程-3"><a href="#交互过程-3" class="headerlink" title="交互过程"></a>交互过程</h3><ol><li>页面发送ajax请求，请求服务端获取套餐分类数据并显示到下拉框中</li><li>页面发送ajax请求，请求服务端获取菜品分类数据并展示到添加菜品窗口中</li><li>页面发送ajax请求，请求服务端，根据菜品分类查询对应的菜品数据并展示到添加菜品窗口中</li><li>页面发送请求进行图片上传，请求服务端将图片保存到服务器</li><li>页面发送请求进行图片下载，将上传的图片进行回显</li><li>点击保存按钮，发送ajax请求，将套餐相关数据以JSON形式提交到服务端</li></ol><p>其中，1、2的功能在前面已经实现，对应的是CategoryController中的list方法，type&#x3D;1时查询的是菜品分类，type&#x3D;2时查询的是套餐分类</p><h3 id="根据分类查询菜品"><a href="#根据分类查询菜品" class="headerlink" title="根据分类查询菜品"></a>根据分类查询菜品</h3><p>在DishController中添加list方法，根据条件来查询菜品数据</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-23%20201235.png"></p><p>可以在添加一个查询条件，只查询状态字段为1的菜品，即不查询停售状态的菜品</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">queryWrapper<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token class-name">Dish</span><span class="token operator">::</span><span class="token function">getStatus</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="服务端接收页面提交的数据"><a href="#服务端接收页面提交的数据" class="headerlink" title="服务端接收页面提交的数据"></a>服务端接收页面提交的数据</h3><p>SetmealService中添加声明，实现一个save方法，同时操作两张表</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-27%20152609.png"></p><p>在实现类中实现该方法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-27%20153843.png"></p><p>在setmealcontroller中调用该方法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-27%20153955.png"></p><h2 id="套餐信息分类查询"><a href="#套餐信息分类查询" class="headerlink" title="套餐信息分类查询"></a>套餐信息分类查询</h2><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-27%20160609.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-27%20160634.png"></p><h2 id="删除套餐"><a href="#删除套餐" class="headerlink" title="删除套餐"></a>删除套餐</h2><p>在套餐管理列表中点击删除按钮，删除对应的套餐信息</p><p>也可以通过多个复选框选择多个套餐批量删除</p><p>并且只能删除停售状态的套餐</p><p>两种删除方式的请求地址和请求方式都是相同的，仅仅是传递的id个数不同</p><p>在SetmealService中声明removeWithDish方法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-27%20162311.png"></p><p>在实现类中实现该方法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-27%20163149.png"></p><p>在controller中调用该方法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-27%20163556.png"></p><h1 id="手机验证码登录"><a href="#手机验证码登录" class="headerlink" title="手机验证码登录"></a>手机验证码登录</h1><h2 id="短信发送"><a href="#短信发送" class="headerlink" title="短信发送"></a>短信发送</h2><p>使用阿里云短信服务</p><p>添加依赖</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-29%20163131.png"></p><p>导入工具类</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-29%20163746.png"></p><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>准备好类和接口：</p><p>User</p><p>UserMapper</p><p>UserService</p><p>UserServiceImpl</p><p>UserController</p><p>SMSUtils、ValidateCodeUtils</p><p>修改LoginCheckFilter，用于检查用户的登录状态</p><p>在进行手机验证码登陆时。发送的请求直接放行</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-29%20170137.png"></p><p>加入登录状态的判断</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-29%20171723.png"></p><p>此处验证码为随机生成的四位数字</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-01%20174746.png"></p><p>当手机号为未登录过的用户时，自动注册账号</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-01%20174821.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-01%20174843.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot+VUE全栈开发</title>
      <link href="/2023/11/05/springboot-vue-quan-zhan-kai-fa/"/>
      <url>/2023/11/05/springboot-vue-quan-zhan-kai-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="maven配置"><a href="#maven配置" class="headerlink" title="maven配置"></a>maven配置</h1><h2 id="官网下载IDEA2020支持的maven版本"><a href="#官网下载IDEA2020支持的maven版本" class="headerlink" title="官网下载IDEA2020支持的maven版本"></a>官网下载IDEA2020支持的maven版本</h2><p>此处下载的为maven3.6.3</p><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>解压下载的zip文件</p><p>找到conf文件夹下的setting.xml</p><p>修改资源文件保存地址</p><p>默认在C盘用户文件夹</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-05%20135707.png"></p><p>修改镜像</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-05%20135917.png"></p><h2 id="与IDEA集成使用"><a href="#与IDEA集成使用" class="headerlink" title="与IDEA集成使用"></a>与IDEA集成使用</h2><p>修改配置路径</p><p>file-&gt;setting-&gt;build,execution,deployment-&gt;build tools-&gt;maven-&gt;maven home directory</p><p>修改配置文件</p><p>file-&gt;setting-&gt;build,execution,deployment-&gt;build tools-&gt;maven-&gt;user setting files(勾选override)</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-05%20140539.png"></p><h1 id="开发环境热部署"><a href="#开发环境热部署" class="headerlink" title="开发环境热部署"></a>开发环境热部署</h1><p>实际的项目开发调试过程中会频繁地修改后台类文件，导致需要重新编译、重新启动。</p><p>Spring Boot提供了spring-boot-devtools组件，无需重启Spring Boot应用即可重新编译、启动项目</p><p>devtools会监听classpath下的文件变动，出发restart类加载器重新加载该类</p><p>并不是所有的更改都需要重启应用</p><p>在pom.xml配置文件中添加dev-tools依赖</p><p>使用option &#x3D; true表示依赖不会传递</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-05%20153038.png"></p><p>在application.properties中添加</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-05%20153304.png"></p><p>如果使用IDEA开发，要在setting中勾选build project automatically，调出maintenance页面，registry，勾选complier.automake.allow.when.app.running</p><h1 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h1><p>Sprint Boot提供@Controller和@Restcontroller两种注解来标识此类负责接收和处理http请求</p><p>请求页面和数据@Controller</p><p>仅请求数据@RestController</p><h2 id="Restcontroller"><a href="#Restcontroller" class="headerlink" title="@Restcontroller"></a>@Restcontroller</h2><p>将返回的对象数据转换为JSON格式</p><h1 id="路由映射"><a href="#路由映射" class="headerlink" title="路由映射"></a>路由映射</h1><p>@Requestmapping注解负责URL的路由映射，可以添加到类或方法上</p><p>常用属性参数：</p><ul><li>value：请求URL的路径，支持URL模板、正则表达式</li><li>method：HTTP请求方法</li><li>consumes：请求的媒体类型</li><li>produces：响应的媒体类型</li><li>params，headers：请求的参数及请求头的值</li></ul><h1 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h1><p>默认静态资源目录：</p><p>classpath:&#x2F;static&#x2F;目录</p><p>自定义过滤规则和静态资源位置：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">spring<span class="token punctuation">.</span>mvc<span class="token punctuation">.</span><span class="token keyword">static</span><span class="token operator">-</span>path<span class="token operator">-</span>pattern <span class="token operator">=</span><span class="token operator">/</span>dirname<span class="token comment">/**</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">spring<span class="token punctuation">.</span>web<span class="token punctuation">.</span>resources<span class="token punctuation">.</span><span class="token keyword">static</span><span class="token operator">-</span>locations<span class="token operator">=</span>classpath<span class="token operator">:</span><span class="token operator">/</span>dirname<span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="文件上传原理"><a href="#文件上传原理" class="headerlink" title="文件上传原理"></a>文件上传原理</h1><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-05%20162921.png"></p><p>Spring Boot的tomcat限制了请求文件的大小，每个文件配置最大为1Mb。单次请求的文件总数不能大于10Mb</p><p>在application.properties中更改默认值</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-05%20163432.png"></p><h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><p>功能：</p><p>权限检查</p><p>性能监控</p><p>通用行为</p><p>Spring Boot定义了HandlerInterceptor接口来自定义拦截器的功能</p><p>HandlerInterceptor接口定义了preHandle、postHandle、afterCompletion三种方法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-05%20165309.png"></p><h1 id="拦截器注册"><a href="#拦截器注册" class="headerlink" title="拦截器注册"></a>拦截器注册</h1><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-18%20162015.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-18%20162044.png"></p><h1 id="构建RESTful服务"><a href="#构建RESTful服务" class="headerlink" title="构建RESTful服务"></a>构建RESTful服务</h1><p>每个URI代表一种资源</p><p>客户端使用GET获取 POST新建 PUT更新 DELETE删除四种方式表示操作方式对服务端资源进行操作</p><p>资源的表现形式是JSON或HTML</p><h2 id="SpringBoot实现RESTful-API"><a href="#SpringBoot实现RESTful-API" class="headerlink" title="SpringBoot实现RESTful API"></a>SpringBoot实现RESTful API</h2><p>spring-boot-starter-web组件提供了与REST操作方式对应的注解</p><p><code>@GetMapping</code></p><p><code>@PostMapping</code></p><p><code>@PutMapping</code></p><p><code>@DeleteMapping</code></p><p><code>@PatchMapping</code></p><p>RESTful架构中，每个网址代表一种资源，所以URI中建议不要包含动词</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-18%20163550.png"></p><h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><p>用于生成、描述、调用和可视化RESTful风格的web服务</p><p>swagger能够自动生成完善的RESTful API 文档，并可以根据后台代码的修改同步更新，同时生成完整的测试页面来调试API</p><h2 id="配置swagger"><a href="#配置swagger" class="headerlink" title="配置swagger"></a>配置swagger</h2><h3 id="添加依赖："><a href="#添加依赖：" class="headerlink" title="添加依赖："></a>添加依赖：</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-18%20164053.png"></p><h3 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-18%20164147.png"></p><h3 id="启动项目访问-http-127-0-0-1-8080-swagger-ui-html-打开可视化测试页面"><a href="#启动项目访问-http-127-0-0-1-8080-swagger-ui-html-打开可视化测试页面" class="headerlink" title="启动项目访问 http://127.0.0.1:8080/swagger-ui.html 打开可视化测试页面"></a>启动项目访问 <a href="http://127.0.0.1:8080/swagger-ui.html">http://127.0.0.1:8080/swagger-ui.html</a> 打开可视化测试页面</h3><h2 id="swagger提供的注解"><a href="#swagger提供的注解" class="headerlink" title="swagger提供的注解"></a>swagger提供的注解</h2><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-18%20164543.png"></p><h1 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h1><h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>对象关系映射</p><p>使用描述对象和数据库之间的映射的元数据将程序中的对象自动持久化到关系数据库中</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-19%20093527.png"></p><h2 id="配置数据库的相关信息"><a href="#配置数据库的相关信息" class="headerlink" title="配置数据库的相关信息"></a>配置数据库的相关信息</h2><p><img src="C:\Users\huameng\AppData\Roaming\Typora\typora-user-images\image-20231119093648258.png" alt="image-20231119093648258"></p><h2 id="添加-MapperScan注解"><a href="#添加-MapperScan注解" class="headerlink" title="添加@MapperScan注解"></a>添加@MapperScan注解</h2><p>添加mapper package后</p><p>在启动类中添加</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@MapperScan</span><span class="token punctuation">(</span><span class="token string">"com.xx.mapper"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MybatisplusDemoApp</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span> <span class="token class-name">MybatisplusDemoApp</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Mybatis-CRUD注解"><a href="#Mybatis-CRUD注解" class="headerlink" title="Mybatis CRUD注解"></a>Mybatis CRUD注解</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Insert</span> <span class="token annotation punctuation">@Update</span><span class="token annotation punctuation">@Delete</span><span class="token annotation punctuation">@Select</span> <span class="token comment">//查询</span><span class="token annotation punctuation">@Result</span> <span class="token comment">//结果集封装</span><span class="token annotation punctuation">@Results</span> <span class="token annotation punctuation">@One</span> <span class="token comment">//一对一结果集封装</span><span class="token annotation punctuation">@Many</span> <span class="token comment">//一对多结果集封装</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>mybatis</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//usermapper.java</span><span class="token annotation punctuation">@Mapper</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">"select* from user"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//usercontroller.java</span><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">UserMapper</span> userMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">List</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//自动转为JSON</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在mybatisplus中，可以直接继承<code>BaseMappper&lt;T&gt;</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Mapper</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token keyword">extends</span> <span class="token class-name">BaseMapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="MybatisPlus多表查询及分页查询"><a href="#MybatisPlus多表查询及分页查询" class="headerlink" title="MybatisPlus多表查询及分页查询"></a>MybatisPlus多表查询及分页查询</h1><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Results</span> <span class="token comment">//代替&lt;resultmap>标签，可以加入单个或多个@Result注解</span><span class="token annotation punctuation">@Result</span> <span class="token comment">//代替&lt;id>&lt;result>标签，可以使用以下属性</span>      <span class="token comment">//-column、-property、-one、-many</span><span class="token annotation punctuation">@One</span> <span class="token comment">//代替&lt;assocation> 使用格式：@Result(column="",property="",one=@One(select=""))</span><span class="token annotation punctuation">@Many</span> <span class="token comment">//代替&lt;collection> 使用格式：@Result(column="",property="",many=@many(select=""))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//UserMapper</span><span class="token comment">//查询用户及其所有的订单</span><span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span>select <span class="token operator">*</span> from t_user<span class="token punctuation">)</span><span class="token annotation punctuation">@Result</span><span class="token punctuation">(</span>    <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Result</span><span class="token punctuation">(</span>column <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">,</span> property <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token annotation punctuation">@Result</span><span class="token punctuation">(</span>column <span class="token operator">=</span> <span class="token string">"username"</span><span class="token punctuation">,</span> property <span class="token operator">=</span> <span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token annotation punctuation">@Result</span><span class="token punctuation">(</span>column <span class="token operator">=</span> <span class="token string">"password"</span><span class="token punctuation">,</span> property <span class="token operator">=</span> <span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token annotation punctuation">@Result</span><span class="token punctuation">(</span>column <span class="token operator">=</span> <span class="token string">"birthday"</span><span class="token punctuation">,</span> property <span class="token operator">=</span> <span class="token string">"birthday"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token annotation punctuation">@Result</span><span class="token punctuation">(</span>column <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">,</span> property <span class="token operator">=</span> <span class="token string">"order"</span><span class="token punctuation">,</span> javaType <span class="token operator">=</span> <span class="token class-name">Lis</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>               many <span class="token operator">=</span> <span class="token annotation punctuation">@Many</span><span class="token punctuation">(</span>select <span class="token operator">=</span> <span class="token string">"com.xxx.mapper.OrderMapper.selectByUid"</span><span class="token punctuation">)</span>               <span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//OrderMapper</span><span class="token annotation punctuation">@Mapper</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">OrderMapper</span> <span class="token keyword">extends</span> <span class="token class-name">BaseMapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Order</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">"select * from t_order where uid = #&#123;uid&#125;"</span><span class="token punctuation">)</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Order</span><span class="token punctuation">></span></span> <span class="token function">selectByUid</span><span class="token punctuation">(</span><span class="token keyword">int</span> uid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p>使用querywrapper</p><p>queryWrapper提供不同的方法来进行条件查询</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//条件查询</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/user/find"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> <span class="token function">findByCond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> queryWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queryWrapper<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">,</span> <span class="token string">"zhangsan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> userMapper<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span>queryMapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><h3 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBatisPlusConfig</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">MyBatisPlusInterceptor</span> <span class="token function">paginationInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">MyBatisPlusInterceptor</span> interceptor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyBatisPlusInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">PaginationInnerInterceptor</span> paginationINterceptor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PaginationInnerInterceptor</span><span class="token punctuation">(</span><span class="token class-name">DbType</span><span class="token punctuation">.</span><span class="token constant">MYSQL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        interceptor<span class="token punctuation">.</span><span class="token function">addInnerInterceptor</span><span class="token punctuation">(</span>paginationINterceptor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> interceptor<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"findAll"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">IPage</span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> page <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> userMapper<span class="token punctuation">.</span><span class="token function">selectPage</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE学习</title>
      <link href="/2023/10/11/javase-xue-xi/"/>
      <url>/2023/10/11/javase-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>此篇笔记只记录部分细节和重要内容</p><h1 id="Java文档注释"><a href="#Java文档注释" class="headerlink" title="Java文档注释"></a>Java文档注释</h1><p>注释内容可以被JDK提供的工具javadoc所解析</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">javadoc <span class="token parameter variable">-d</span> 文件夹名 <span class="token parameter variable">-xx</span> <span class="token parameter variable">-yy</span> Demo.java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>一些可使用的javadoc标签：</p><p>@author：标识一个类的作者</p><p>@deprecated：指明一个过期的类成员</p><p>@docRoot：指明当前文档根目录的路径</p><p>@exception：标志一个类抛出的异常</p><p>@inheritDoc：从父类继承的注释</p><p>@link：插入到另一个主题的链接</p><p>@param：说明一个方法的参数</p><p>……</p></blockquote><h1 id="Java代码规范"><a href="#Java代码规范" class="headerlink" title="Java代码规范"></a>Java代码规范</h1><ul><li>对于类、方法的注释，用javadoc来写</li><li>&#x3D;&#x3D;shift+tab：整体右移&#x3D;&#x3D;</li></ul><p>……</p><h1 id="Java可变参数"><a href="#Java可变参数" class="headerlink" title="Java可变参数"></a>Java可变参数</h1><p>Java允许将同一个类中的多个同名同功能的但是参数个数不同的方法，封装成一个方法</p><p>访问修饰符 返回类型 方法名（数据类型… 形参名）{</p><p>}</p><blockquote><p>可变参数的实参可以为0个或任意多个</p><p>可变参数的实参可以为数组</p><p>可变参数的本质就是数组</p><p>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后</p><p>一个形参列表中只能出现一个可变参数</p></blockquote><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>主要作用：完成新对象的初始化</p><p>[修饰符] 方法名(形参列表)</p><p>​方法体；</p><p><em>构造方法没有返回值</em></p><p><em>方法名必须与类名相同</em></p><p><em>可以重载</em></p><p><em>默认构造器被覆盖后不能继续使用</em></p><p><strong>对象的初始化顺序</strong></p><p>1.默认初始化</p><p>2.显式初始化</p><p>3.构造方法初始化</p><h1 id="Javap"><a href="#Javap" class="headerlink" title="Javap"></a>Javap</h1><p>对指定的class文件进行反编译</p><p><strong>使用格式</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">javap <span class="token operator">&lt;</span>options<span class="token operator">></span> <span class="token operator">&lt;</span>classes<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>常用命令</p><p>-c：对代码进行反汇编</p><p>-v -verbose：输出附加信息</p><p>-p -private：显示所有类和成员</p></blockquote><h1 id="类的五大成员"><a href="#类的五大成员" class="headerlink" title="类的五大成员"></a>类的五大成员</h1><p>属性、方法、构造器、代码块、内部类</p><h1 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h1><p>this关键字可以用来访问本类的属性、方法、构造器</p><p>this用于区分当前类的属性和局部变量</p><p>语法：this(参数列表)，只在构造器中使用（<strong>必须放在第一条语句</strong>）</p><p>只能在类定义的方法中使用</p><h1 id="常用包"><a href="#常用包" class="headerlink" title="常用包"></a>常用包</h1><p>java.lang：默认引入</p><p>java.util：工具包</p><p>java.net：网络包</p><p>java.awt：界面开发GUI</p><h1 id="面向对象编程—封装"><a href="#面向对象编程—封装" class="headerlink" title="面向对象编程—封装"></a>面向对象编程—封装</h1><p>（1）将属性进行私有化</p><p>（2）提供一个公共的set方法，用于对属性判断并赋值</p><p>（3）提供一个公共的get方法用于获取属性的值</p><p><em>可以将构造器与setXxx结合来实现对属性的控制</em></p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>&#x3D;&#x3D;ctrl+H快速查看继承关系&#x3D;&#x3D;</p><p>&#x3D;&#x3D;ctrl+B快速定位&#x3D;&#x3D;</p><blockquote><p>1.子类必须调用父类的构造器，完成父类的初始化</p><p>2.创建子类对象时，不管使用子类的哪个构造器，默认调用父类的午餐&#x3D;&#x3D;无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作</p><p>3.super在使用时必须放下在构造器的第一行且只能在构造器中使用</p><p>4.super和this都只能放在构造器中的第一行</p><p>5.java所有类都是Object类的子类</p><p>6.父类构造器的调用不限于直接父类</p><p>7.Java中是单继承机制</p></blockquote><h1 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h1><p>super代表父类的引用，用于访问父类属性的方法、属性、构造器</p><blockquote><p>super.属性名</p><p>访问父类的属性，但不能访问私有属性</p><p>super.方法名</p><p>访问父类的方法，但不能访问私有方法</p><p>super(参数列表)</p><p>访问父类的构造器，只能放在第一句，只能出现一句</p><p>super的访问不限于父类，遵循就近原则</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ol><li><p>方法的重写和重载</p></li><li><p>一个对象的编译类型和运行类型可以不一致</p><p>父类引用指向子类对象</p></li><li><p>编译类型是确定的，运行类型可以改变</p></li><li><p>编译类型看&#x3D;左边，运行类型看&#x3D;右边</p></li><li><p>向上转型</p></li><li><p>向下转型</p><p>子类类型 引用名&#x3D;（子类类型）父类引用</p><p>只能强转父类引用</p><p>要求父类引用必须指向的是当前目标类型的对象</p><p>可以调用子类类型中的所有成员</p></li><li><p>属性不能重写，直接看编译类型</p></li><li><p>instanceOf比较操作符，用于判断对象的类型是否是某类型或为某类型的子类型</p></li></ol><h1 id="Java的动态绑定机制"><a href="#Java的动态绑定机制" class="headerlink" title="Java的动态绑定机制"></a>Java的动态绑定机制</h1><ol><li>当&#x3D;&#x3D;调用对象方法&#x3D;&#x3D;的时候，该方法会和该对象的内存地址&#x2F;运行类型绑定</li><li>当&#x3D;&#x3D;调用对象属性&#x3D;&#x3D;时，&#x3D;&#x3D;没有动态绑定机制&#x3D;&#x3D;，哪里声明，哪里使用</li></ol><h1 id="Instanceof"><a href="#Instanceof" class="headerlink" title="Instanceof"></a>Instanceof</h1><p>判断运行类型</p><p>子类 instanceof 父类类型</p><h1 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a>多态数组</h1><p>数组的定义类型为父类类型，数组内保存的元素实际为子类类型</p><p>当需要调用子类的特有方法时，要先将父类类型向下转型为子类类型后再进行调用</p><h1 id="多态参数"><a href="#多态参数" class="headerlink" title="多态参数"></a>多态参数</h1><p>方法定义的形参类型为父类类型，实参类型允许为子类类型</p><h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><h2 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h2><p>默认判断的是地址是否相等，子类中往往重写该方法，用于判断&#x3D;&#x3D;内容&#x3D;&#x3D;是否相等</p><blockquote><p>&#x3D;&#x3D;与equals的对比：</p><p>&#x3D;&#x3D;既可以判断基本类型也可以判断引用类型</p><p>equals是object的方法，只能判断引用类型</p></blockquote><p>由于person并没有重写equals方法，所以最后一条语句返回False</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-25%20140624.png"></p><h2 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h2><ul><li>提高哈希结构容器的效率</li><li>两个指向同一对象的引用，哈希值相同</li><li>集合中也可以重写hashcode方法</li></ul><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><p>返回对象的字符串表示</p><p>默认返回：全类名( getclass()+getname() 包名+类名 )+@+哈希值的十六进制( Integer.toHexString(hashCode()) )</p><p>子类往往重写toString方法，用于返回对象的信息</p><p><strong>使用快捷键alt+insert-&gt;toString</strong></p><p>直接输出一个对象时，会默认调用toString方法</p><h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h2><p>当垃圾回收器不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法</p><p>子类可以重写该方法来做一些释放资源的操作</p><p>垃圾回收机制的调用是由系统来决定，也可以通过System.gc()主动触发垃圾回收机制</p><p>finalize方法也可快捷键直接生成</p><h1 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h1><p>类变量是随着类的加载而创建，所以即使没有创建对象叶也可以访问</p><h2 id="static变量：对象共享"><a href="#static变量：对象共享" class="headerlink" title="static变量：对象共享"></a>static变量：对象共享</h2><p>jdk7前静态类变量放在方法区中，此后的版本放在堆中class实例的尾部</p><h1 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h1><p>访问修饰符 static 数据返回类型 方法名(){}</p><p>static 访问修饰符 数据返回类型 方法名(){}</p><p>静态方法只能访问静态变量或静态方法</p><p>&#x3D;&#x3D;当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率&#x3D;&#x3D;</p><p>类方法中不允许使用和对象有关的关键字，比如this、super</p><h1 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h1><p>&#x3D;&#x3D;public static void main(String[] args)&#x3D;&#x3D;</p><p>Java虚拟机调用类的main方法</p><p>该方法接收String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数</p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>没有方法名，没有返回，没有参数，只有方法体，不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用</p><p>先调用代码块，再调用构造器</p><blockquote><p>static代码块也叫静态代码块，随着类的加载执行且只执行一次，只能调用静态成员</p><p>普通代码块每创建一个对象就执行，可以调用任意成员</p><p>只使用类的静态成员时，普通代码块不会被执行</p></blockquote><p>静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用，普通代码块也是如此</p><blockquote><p>为什么代码的执行顺序为静态代码块、普通代码块、构造器？</p><p>每个类的构造方法前隐含super()和普通代码块的调用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">//(1)super()</span>        <span class="token comment">//(2)调用普通代码块</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用构造器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>静态相关的代码块，属性初始化，在类加载时就已经执行完毕，所以优先于构造器和普通代码块</p></blockquote><p>调用一个子类对象时的调用顺序：</p><ol><li>父类的静态代码块和静态属性&#x3D;&#x3D;（先进行类的加载）&#x3D;&#x3D;（加载父类）</li><li>子类的静态代码块和静态属性（加载子类）</li><li>父类的普通代码块和普通属性初始化</li><li>父类的构造方法</li><li>子类的普通代码块和普通属性初始化</li><li>子类的构造方法</li></ol><h2 id="类什么时候被加载"><a href="#类什么时候被加载" class="headerlink" title="类什么时候被加载"></a>类什么时候被加载</h2><ol><li>创建对象实例</li><li>创建子类对象实例，父类也会被加载</li><li>使用类的静态成员时</li></ol><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><blockquote><p>采取一定的方法保证在整个软件系统中，对某一类只存在一个对象实例，并且该类只提供一个取得其对象实例的方法</p></blockquote><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><ol><li>构造器私有化</li><li>类的内部创建对象（该对象是static）</li><li>提供一个公共的static方法，返回该对象</li></ol><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>可能存在线程安全问题</p><ol><li>构造器私有化</li><li>定义一个静态属性对象</li><li>提供一个public的static方法，当对象还未被创建时，返回一个对象</li><li>当用户使用getInstance时，才返回对象；后面再次调用时，再返回同一个对象</li></ol><h2 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h2><h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><p>访问修饰符 final 返回类型 方法名</p><p>使用final的情况：</p><ol><li>不希望类被继承时</li><li>不希望父类的某个方法被子类重写&#x2F;覆盖时</li><li>不希望某个属性的值被修改</li><li>不希望某个局部变量被修改</li></ol><blockquote><ol><li>final修饰的属性又叫常量，一般用XX_XX命名</li><li>final修饰的属性在定义时，&#x3D;&#x3D;必须赋初值&#x3D;&#x3D;，并且以后不能再修改，可以在如下位置赋值：定义时、构造器中、代码块中</li><li>如果final修饰的属性是静态的，初始化的位置只能是：定义时、在静态代码块中，不能在构造器中复制</li><li>final类不能继承，但是可以实例化对象</li><li>如果类不是final类，但是含有final方法，该方法虽然不能重写，但是可以继承</li><li>一般来说，当一个类已经是final类，就没有必要将方法修饰为final方法</li><li>final不能修饰构造方法</li><li>final往往和static一起使用，因为不会导致类加载，底层编译器进行了优化处理</li><li>final类：包装类（Integer、Double、Float），String</li></ol></blockquote><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>解决父类方法不确定的问题</p><blockquote><ol><li>当一个类中存在抽象方法时，需要将该类声明为abstract类</li><li>抽象类不能被实例化且抽象类可以没有abstract方法</li><li>abstract只修饰类和方法</li><li>抽象类可以有任意成员</li><li>抽象方法不能有主体</li><li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为抽象类</li><li>抽象方法不能使用private、final、static来修饰</li></ol></blockquote><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再实现这些方法</p><h2 id="接口使用细节"><a href="#接口使用细节" class="headerlink" title="接口使用细节"></a>接口使用细节</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">interface</span> interfacename<span class="token punctuation">&#123;</span>    属性；    方法；<span class="token comment">//抽象方法，默认实现方法，静态方法</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> classname <span class="token keyword">implements</span> 接口<span class="token punctuation">&#123;</span>    属性；    方法；    必须实现接口的抽象方法，可以省略abtract关键字        <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JDK7.0前，接口里的所有方法都没有方法体，都是抽象方法</p><p>JDK8.0后接口可以有静态static方法，即可以有方法的具体实现；也可以有默认实现方法，使用default关键字修饰</p><blockquote><ol><li>接口不能实例化</li><li>接口中的所有方法是publlic方法</li><li>一个普通类实现接口，必须实现接口的所有方法（快捷键alt+enter）</li><li>抽象类实现接口，可以实现接口的方法</li><li>一个类可以同时实现多个接口</li><li>接口中的属性，只能是final的，而且是public static final修饰符</li><li>接口不能继承，但可以继承多个别的接口</li><li>接口只能是public或default修饰</li><li>接口类型的变量可以指向实现了该接口的对象实例</li></ol></blockquote><h2 id="接口的多态特性"><a href="#接口的多态特性" class="headerlink" title="接口的多态特性"></a>接口的多态特性</h2><ol><li><p>多态参数</p></li><li><p>多态数组</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Usb</span><span class="token punctuation">[</span><span class="token punctuation">]</span> usbs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Usb</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>usbs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">phone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>usbs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">camera</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="接口的多态传递"><a href="#接口的多态传递" class="headerlink" title="接口的多态传递"></a>接口的多态传递</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterfacePolyPass</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">IG</span> ig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//如果IG继承了IH接口，而T实现了IG接口</span>        <span class="token comment">//实际上相当于T也实现了IG接口</span>        <span class="token class-name">IH</span> ih <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">IH</span><span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">hi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">IG</span> <span class="token keyword">extends</span> <span class="token class-name">IH</span><span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token keyword">implements</span> <span class="token class-name">IG</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>一个类的内部完整的嵌套了另一个类的结构，被嵌套的类被称为内部类，嵌套的其他类成为外部类</p><p>内部类可以直接访问私有属性</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Outer</span><span class="token punctuation">&#123;</span> <span class="token comment">//外部类</span>    <span class="token keyword">class</span> <span class="token class-name">Inner</span><span class="token punctuation">&#123;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Other</span><span class="token punctuation">&#123;</span> <span class="token comment">//外部其他类</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h2><p>定义在外部类&#x3D;&#x3D;局部位置&#x3D;&#x3D;</p><ol><li>局部内部类（有类名）</li><li>&#x3D;&#x3D;匿名内部类（没有类名）&#x3D;&#x3D;</li></ol><p>定义在外部类&#x3D;&#x3D;成员位置&#x3D;&#x3D;</p><ol><li>成员内部类（无static修饰）</li><li>静态内部类（使用static修饰）</li></ol><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>本质是一个类</p><p>定义在局部位置有类名</p><blockquote><ol><li><p>可以直接访问外部类成员，包括私有成员</p></li><li><p>不能添加访问修饰符，但可以用final修饰因为它是局部变量</p></li><li><p>作用域：仅在定义它的方法或代码块中</p></li><li><p>外部类访问局部内部类的成员</p><p>访问方式：创建对象再访问&#x3D;&#x3D;在作用域内&#x3D;&#x3D;</p></li><li><p>外部其他类不能访问局部内部类</p></li><li><p>外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，可以使用（外部类名.this.成员）来访问</p><p>外部类名.this本质是外部类的对象</p></li></ol></blockquote><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>定义在外部类的局部位置，没有类名</p><p>如果一个类仅会被使用一次，可以使用匿名内部类简化开发</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">new</span> 类或接口<span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-11%20151013.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-11%20151121.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-11%20151612.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-11%20151635.png"></p><p><strong>使用细节</strong></p><p>1.调用匿名内部类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">cry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">cry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//匿名内部类本身也是返回对象</span><span class="token class-name">A</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">cry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.可以直接访问外部类的所有成员，包括私有</p><p>3.不能添加访问修饰符</p><p>4.作用域：在定义它的方法或代码块中</p><p>5.外部其他类不能访问局部内部类 </p><p>6.外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，可以使用（外部类名.this.成员）来访问     外部类名.this本质是外部类的对象</p><p>7.可以当作实参直接传递</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">IL</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>定义在外部类的成员位置，没有static修饰</p><blockquote><ol><li>可以直接访问外部类的所有成员，包含私有的</li><li>可以添加任意访问修饰符</li><li>作用域：整个类体</li><li>外部类通过&#x3D;&#x3D;创建内部类对象&#x3D;&#x3D;来访问内部类</li><li>外部其他类通过外部类来访问内部类</li></ol></blockquote><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><blockquote><ol><li>可以直接访问外部类的所有静态成员，并有static修饰</li><li>可以直接访问外部类的所有静态成员，包含私有的</li><li>可以添加任意访问修饰符</li><li>作用域：整个类体</li><li>可以通过类名直接访问</li></ol></blockquote><h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><h2 id="枚举的实现方式"><a href="#枚举的实现方式" class="headerlink" title="枚举的实现方式"></a>枚举的实现方式</h2><h3 id="自定义类实现枚举"><a href="#自定义类实现枚举" class="headerlink" title="自定义类实现枚举"></a>自定义类实现枚举</h3><blockquote><ol><li>不需要提供set方法</li><li>构造器私有化</li><li>本类内部创建对象</li><li>使用final + static共同修饰，实现底层优化</li><li>对象名通常全部大写</li></ol></blockquote><h3 id="enum实现枚举类"><a href="#enum实现枚举类" class="headerlink" title="enum实现枚举类"></a>enum实现枚举类</h3><blockquote><ol><li>使用enum代替class</li><li>常量名(实参列表)</li><li>多个常量使用逗号间隔</li><li>调用无参构造器可以省略括号</li><li>枚举对象必须放在枚举类的行首</li></ol></blockquote><h4 id="enum常用方法"><a href="#enum常用方法" class="headerlink" title="enum常用方法"></a>enum常用方法</h4><p>toString：返回当前对象名，子类可以重写</p><p>name：返回当前对象名（常量名）</p><p>ordinal：返回位置号，默认从0开始</p><p>values：返回当前枚举类中的所有常量</p><p>valueOf：将字符串转换为枚举对象，要求字符串必须为已有的常量名</p><p>compareTo：比较两个枚举常量，返回位置号的差</p><h4 id="enum使用细节"><a href="#enum使用细节" class="headerlink" title="enum使用细节"></a>enum使用细节</h4><p>enum不能继承其他类</p><p>可以实现接口</p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>注释不影响程序逻辑，但可以被编译或运行</p><h2 id="基本的注解"><a href="#基本的注解" class="headerlink" title="基本的注解"></a>基本的注解</h2><h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><p>限定某个方法，表示重写</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">METHOD</span><span class="token punctuation">)</span> <span class="token comment">//@Target是注解的注解，叫做元注解，此处代码说明只能修饰方法</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">SOURCE</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Override</span><span class="token punctuation">&#123;</span>    <span class="token comment">//@interface为注解类，而不是接口</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><p>用于表示某个程序元素已过时，不推荐使用</p><p>可以修饰方法、类、字段、包、参数等</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Documented</span> <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span> <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token constant">CONSTRUCTOR</span><span class="token punctuation">,</span> <span class="token constant">FIELD</span><span class="token punctuation">,</span> <span class="token constant">LOCAL_VARIABLE</span><span class="token punctuation">,</span> <span class="token constant">METHOD</span><span class="token punctuation">,</span> <span class="token constant">PACKAGE</span><span class="token punctuation">,</span> <span class="token constant">PARAMETER</span><span class="token punctuation">,</span> <span class="token constant">TYPE</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Deprecated</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h3><p>抑制编译器警告</p><p>作用范围与放置位置有关</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token constant">TYPE</span><span class="token punctuation">,</span> <span class="token constant">FIELD</span><span class="token punctuation">,</span> <span class="token constant">METHOD</span><span class="token punctuation">,</span> <span class="token constant">PARAMETER</span><span class="token punctuation">,</span> <span class="token constant">CONSTRUCTOR</span><span class="token punctuation">,</span> <span class="token constant">LOCAL_VARIABLE</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">SOURCE</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">SuppressWarnings</span> <span class="token punctuation">&#123;</span>               <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><h2 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h2><p>指定注解能够保留多久</p><p>包含RetentionPolicy类型的变量</p><p>三种值：SOURCE CLASS(默认值) RUNTIME</p><h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h2><p>指定注解修饰的程序元素</p><h2 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h2><p>被注解修饰的类将被javadoc工具提取成文档</p><p>Retention必须为RUNTIME</p><h2 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h2><p>被其修饰的注解具有继承性</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>快捷键 ctrl+alt+t</p><p>执行中出现的异常可以分为Error和Exception（编译异常、运行异常）</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-13%20113326.png"></p><h2 id="常见运行时异常"><a href="#常见运行时异常" class="headerlink" title="常见运行时异常"></a>常见运行时异常</h2><p>NullPointerException空指针异常</p><p>ArithmeticException数学运算异常</p><p>ArrayIndexOutOfBoundException数组下标越界异常</p><p>ClassCastException类型转换异常</p><p>NumberFormatException数字格式不正确异常</p><h2 id="try-catch-finally处理机制"><a href="#try-catch-finally处理机制" class="headerlink" title="try-catch-finally处理机制"></a>try-catch-finally处理机制</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">&#123;</span>    <span class="token comment">//可能有异常的代码</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//捕获到异常</span>    <span class="token comment">//处理异常</span><span class="token punctuation">&#125;</span> <span class="token keyword">finally</span><span class="token punctuation">&#123;</span>    <span class="token comment">//不管try代码块是否有异常，始终使用finally</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以有多个catch语句，捕获不同的异常，子类异常在父类异常后</p><h2 id="throws异常处理"><a href="#throws异常处理" class="headerlink" title="throws异常处理"></a>throws异常处理</h2><ol><li>编译异常必须显式处理，运行异常可以不显式处理（有默认处理机制）</li><li>没有处理的异常默认throws方式处理</li><li>子类重写父类时对异常的规定：子类抛出的异常要么与父类的一致，要么是父类异常的子类型</li></ol><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>编译异常：继承Exception</p><p>运行异常：继承RuntimeException</p><h2 id="throw和throws"><a href="#throw和throws" class="headerlink" title="throw和throws"></a>throw和throws</h2><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-13%20123615.png"></p><h1 id="包装类Wrapper"><a href="#包装类Wrapper" class="headerlink" title="包装类Wrapper"></a>包装类Wrapper</h1><p>针对八种基本数据类型相应的引用类型叫做包装类</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-19%20184010.png"></p><h2 id="包装类和基本数据类型的转换"><a href="#包装类和基本数据类型的转换" class="headerlink" title="包装类和基本数据类型的转换"></a>包装类和基本数据类型的转换</h2><p>JDK5前手动装箱拆箱，装箱：基本数据类型-&gt;包装类，反之则为拆箱</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//手动装箱</span><span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> integer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> integer1 <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//手动拆箱</span><span class="token keyword">int</span> i <span class="token operator">=</span> integer<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JDK5后可以自动装箱拆箱</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//自动装箱</span><span class="token class-name">Integer</span> integer2 <span class="token operator">=</span> n1<span class="token punctuation">;</span> <span class="token comment">//底层使用valueOf方法</span><span class="token comment">//自动拆箱</span><span class="token keyword">int</span> n3 <span class="token operator">=</span> integer2<span class="token punctuation">;</span> <span class="token comment">//底层使用intValue方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="包装类和String的转换"><a href="#包装类和String的转换" class="headerlink" title="包装类和String的转换"></a>包装类和String的转换</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">//1</span><span class="token class-name">String</span> str1 <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token comment">//2</span><span class="token class-name">String</span> str2 <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//3</span><span class="token class-name">String</span> str3 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> str4 <span class="token operator">=</span> <span class="token string">"12345"</span><span class="token punctuation">;</span><span class="token comment">//1</span><span class="token class-name">Integer</span> i2 <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"12345"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2</span><span class="token class-name">Integer</span> i3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>str4<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><p>String类实现了serializable、comparable接口</p><p>字符串使用unicode字符编码，一个字符占两个字节</p><p>String是final类，不能被继承</p><p>String有属性private final char value[]，用于存放字符串内容</p><h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><p>直接赋值：从常量池查看是否有“xx”数据空间，如果有，直接指向，没有则重新创建，最终指向的是常量池的空间地址</p><p>调用构造器：先在堆中创建空间，维护value的属性，指向常量池空间</p><h2 id="intern方法"><a href="#intern方法" class="headerlink" title="intern方法"></a>intern方法</h2><p>当调用intern方法时，如果池已经包含一个等于此String对象的字符串（用equal确定），则返回池中的字符串。否则将此String对象添加到池中，并返回此对象的引用</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>String是一个final类</p><p>一个字符串对象一旦被分配就不可改变</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span><span class="token comment">/* 先创建一个StringBuilder     执行append    再执行toString    c指向堆中的对象(String) value[]->池中 "helloabc "*/</span><span class="token class-name">String</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//format方法</span><span class="token class-name">String</span> formatStr <span class="token operator">=</span> <span class="token string">"我的姓名是%s"</span><span class="token punctuation">;</span><span class="token class-name">String</span> info <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>formatStr<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="StringBuffer和StringBuilder类"><a href="#StringBuffer和StringBuilder类" class="headerlink" title="StringBuffer和StringBuilder类"></a>StringBuffer和StringBuilder类</h1><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p>StringBuffer是可变长度的，是final类，StringBuffer是一个容器</p><p>实现了Serializable接口</p><p>父类AbstractStringBuilder中，属性char[] value存放字符串内容，不是final，因此，存放在堆中</p><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//构造初始容量为16个字符的字符串缓冲区</span><span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token class-name">CharSequence</span> seq<span class="token punctuation">)</span> <span class="token comment">//构造一个包含与CharSequence相同字符的字符串缓冲区</span><span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token comment">//指定容量</span><span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token comment">//初始化为指定字符串的内容</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><p>此类提供与StringBuffer兼容的API，但不保证同步（不是线程安全）</p><p>用在字符串缓冲区被单个线程使用的时候</p><h1 id="Math类常用方法"><a href="#Math类常用方法" class="headerlink" title="Math类常用方法"></a>Math类常用方法</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//求绝对值</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span><span class="token number">3.01</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token number">3.99</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5.001</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//四舍五入</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//开方</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">ranndon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>b <span class="token operator">-</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回0 &lt;= 数 &lt;= b - a</span><span class="token comment">//获取a b间随机数</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>b<span class="token operator">-</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Arrays类常用方法"><a href="#Arrays类常用方法" class="headerlink" title="Arrays类常用方法"></a>Arrays类常用方法</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//返回数组的字符串形式</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//自然排序</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//定制排序：传入接口Comparator，要求实现compare方法</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o1<span class="token punctuation">,</span> <span class="token class-name">Object</span> o2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//数组元素的复制</span><span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newArr <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//数组元素的填充</span><span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将一组值转换为list</span><span class="token comment">//返回asList的编译类型 List(接口)</span><span class="token comment">//asList运行类型 java.utils.Arrays$ArrayList</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> asList <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="System类常用方法"><a href="#System类常用方法" class="headerlink" title="System类常用方法"></a>System类常用方法</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//退出程序</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回当前时间距离1970.01.01的毫秒数</span><span class="token class-name">System</span><span class="token punctuation">.</span>currentTimeMillis<span class="token punctuation">;</span><span class="token comment">//垃圾回收机制</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="BigInteger和BigDecimal"><a href="#BigInteger和BigDecimal" class="headerlink" title="BigInteger和BigDecimal"></a>BigInteger和BigDecimal</h1><p>BigInteger适合保存比较大的整型</p><p>BigDecimal适合保存精度更高的浮点型</p><h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><ul><li>add</li><li>substract</li><li>multiply</li><li>divide</li></ul><h1 id="Lamda表达式"><a href="#Lamda表达式" class="headerlink" title="Lamda表达式"></a>Lamda表达式</h1><p>简化函数式接口匿名内部类的写法</p><p>必须是接口，且接口中有且仅有一个方法</p><p>大部分函数式接口有@FunctionalInterface的注解</p><p>（被重写的方法的形参列表）-&gt;{</p><p>​被重写方法的方法体</p><p>}</p><p>省略写法：</p><ol><li>参数类型可以省略</li><li>只有一个参数，（）也可以省略</li><li>方法体中只有一行代码，可以省略大括号，同时省略分号，如果是return语句，return也可以省略</li></ol><h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>静态方法的引用：某个lamda表达式只调用一个静态方法并且前后参数形式一致，就可以使用静态方法引用</p><p>类名::静态方法</p><p>实例方法的引用：某个lamda表达式只调用一个实例方法并且前后参数形式一致，就可以使用实例方法引用</p><p>对象名::实例方法</p><p>特定类型方法的引用：Lamda表达式调用的实例方法，第一个参数是主调，后面所有参数作为入参</p><p>类型::方法</p><p>构造器引用</p><p>类名::new</p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>校验数据格式</p><p>查找满足要求的内容</p><p>String匹配正则表达式的方法</p><p>public boolean matches(String regex)</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-06%20145433.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-06%20145455.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-06%20145511.png"></p><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="体系"><a href="#体系" class="headerlink" title="体系"></a>体系</h2><p>集合主要有单列集合和双列集合</p><p>Collection接口有两个重要的子接口， List和Set，他们的实现子类都是单列集合</p><p>Map接口的实现子类是双列集合，存放KEY—VALUE</p><h2 id="Collection接口和常用方法"><a href="#Collection接口和常用方法" class="headerlink" title="Collection接口和常用方法"></a>Collection接口和常用方法</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token class-name">Collections</span><span class="token punctuation">.</span>addAll <span class="token comment">//为集合批量添加数据</span><span class="token class-name">Collections</span><span class="token punctuation">.</span>shuffle <span class="token comment">//打乱list集合中的元素顺序</span><span class="token class-name">Collections</span><span class="token punctuation">.</span>sort <span class="token comment">//升序排序</span>        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Collection实现子类可以存放多个元素，每个元素可以是Object</p><p>Collection接口没有直接实现的子类，是通过它的子接口Set、List来实现的</p><h2 id="iterator接口"><a href="#iterator接口" class="headerlink" title="iterator接口"></a>iterator接口</h2><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>hasNext()</p><p>next()</p><p>remove()</p><p>调用it.next()方法之前必须调用it.hasNext()进行检测，否则如果下一条记录无效则会抛出异常NoSuchElementException</p><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><p>List中元素是有序的，添加顺序与取出顺序一致</p><p>常用的实现类：ArrayList LinkedList Vector</p><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>void add.index(int index, Object ele)</p><p>boolean addAll.(int index, Collection ele)</p><p>get(int index)</p><p>int indexOf(Object obj) 返回元素首次出现的位置</p><p>int lastIndexOf(Object obj)</p><p>Object set(int index, Object ele) 替换</p><p>List subList(int fromIndex, int toIndex) 返回子集合</p><h2 id="ArrayList底层结构"><a href="#ArrayList底层结构" class="headerlink" title="ArrayList底层结构"></a>ArrayList底层结构</h2><p>List<String> list &#x3D; new ArrayList&lt;&gt;();</p><p>可以加入空值null</p><p>底层由&#x3D;&#x3D;数组&#x3D;&#x3D;实现</p><p>基本等同于Vector，但线程不安全</p><p>ArraryList维护了一个Object的数组elementData中</p><p>ArrayList&#x3D;&#x3D;无参构造器初始化&#x3D;&#x3D;elementData为&#x3D;&#x3D;0&#x3D;&#x3D;</p><p>第一次添加扩容elementData为10，接下来每次扩容都扩容1.5倍</p><p>指定大小的构造器初始elementData为指定大小，扩容则直接扩容为1.5倍</p><h2 id="LinkedList底层结构"><a href="#LinkedList底层结构" class="headerlink" title="LinkedList底层结构"></a>LinkedList底层结构</h2><p>基于&#x3D;&#x3D;双链表&#x3D;&#x3D;实现</p><p>增加了对首尾操作的方法</p><h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><p>无序，不重复，无索引</p><p>HashSet：无序</p><p>LinkedHashSet：有序</p><p>TreeSet：排序</p><h2 id="HashSet集合的底层原理"><a href="#HashSet集合的底层原理" class="headerlink" title="HashSet集合的底层原理"></a>HashSet集合的底层原理</h2><p>基于&#x3D;&#x3D;哈希表&#x3D;&#x3D;实现</p><p>JDK8前，哈希表&#x3D;数组+链表</p><p>JDK8后，哈希表&#x3D;数组+链表+红黑树，当链表长度超过8，数组长度&gt;&#x3D;64，自动将链表转成红黑树</p><p>创建一个默认长度为16的数组</p><p>默认加载因子为0.75，数组名为table</p><p>去重需要重写hashcode和equals方法</p><h2 id="LinkedHashSet的底层原理"><a href="#LinkedHashSet的底层原理" class="headerlink" title="LinkedHashSet的底层原理"></a>LinkedHashSet的底层原理</h2><p>每个元素多了一个双链表机制记录前后元素的位置</p><h2 id="TreeSet集合"><a href="#TreeSet集合" class="headerlink" title="TreeSet集合"></a>TreeSet集合</h2><p>默认升序</p><p>底层有红黑树实现</p><p>自定义类型无法排序，支持指定规则：自定义类实现Conparable接口重写compareto方法、通过TreeSet集合有参构造器设置Comparator对象</p><h2 id="Vector底层结构"><a href="#Vector底层结构" class="headerlink" title="Vector底层结构"></a>Vector底层结构</h2><p>底层也是对象数组protected Object[] elementData</p><p>vector是线程安全的</p><p>无参构造器默认构造大小为10</p><p>如果指定大小，每次扩容2倍</p><h2 id="如何解决集合并发修改问题"><a href="#如何解决集合并发修改问题" class="headerlink" title="如何解决集合并发修改问题"></a>如何解决集合并发修改问题</h2><p>每次处理完将索引值-1</p><p>从后往前删除</p><p>不使用集合本身提供的remove方法，使用迭代器的remove方法</p><h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p>双列集合</p><p>键不允许重复</p><p>HashMap：无序，不重复，无索引</p><p>LinkedMap：有序，不重复，无索引</p><p>TreeMap：默认升序，不重复，无索引</p><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><p><code>map.get(Object key)</code>：获取键对应的值</p><p><code>map.containsKey(Object key)</code>：判断是否包含某个键</p><p><code>map.containsValue(Object value)</code>：判断是否包含某个值</p><p><code>map.keySet()</code>：获取全部键</p><p><code>map.values()</code>：获取map集合全部值</p><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>：获取所有键值对的集合</p><p>将键值对封装为Entry对象，再将所有Entry对象放入set集合中</p><p>Lamda表达式遍历：</p><p><code>map.forEach((k, v)-&gt;&#123;</code></p><p><code>&#125;);</code></p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>基于哈希表实现</p><p>与hashset类似，数组+链表+红黑树实现</p><p>利用键计算哈希值</p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>底层原理与LinkedHashSet类似</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>底层原理与TreeSet类似</p><p>都是红黑树实现的</p><h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><p>用于操作集合或数组的数据</p><h2 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h2><p>获取stream流</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-06%20165435.png"></p><p>中间方法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-06%20170152.png"></p><p>终结方法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-06%20170429.png"></p><p>收集stream流</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-06%20170535.png"></p><h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><p>File不能读写文件存储的数据</p><p>既可以代表文件，也可以代表文件夹</p><h2 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h2><p><code>public File(String Pathname)</code></p><h2 id="创建、删除文件"><a href="#创建、删除文件" class="headerlink" title="创建、删除文件"></a>创建、删除文件</h2><p>创建文件：createNewFile()</p><p>创建文件夹：mkdir()</p><p>创建多级文件夹：mkdirs()</p><p>删除文件：delete()</p><h2 id="遍历文件夹"><a href="#遍历文件夹" class="headerlink" title="遍历文件夹"></a>遍历文件夹</h2><p>获取一级文件名称：<code>public String[] list()</code></p><p>获取一级文件对象：<code>public File[] listFiles()</code></p><h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><blockquote><p>UTF-8采用可变长编码方案</p><p>英文字符、数字只占一个字节，汉字字符占3个字节</p></blockquote><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p><code>byte[] getBytes()</code> </p><p><code>byte[] getBytes(String charsetName)</code></p><h2 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h2><p><code>String(byte[] bytes)</code></p><p><code>String(byte[] bytes, String charsetName)</code></p><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>用于读写数据</p><p>IO流可分为：输入&#x2F;输出流、字符&#x2F;字节流</p><p>Java.io包中，字节流有InputStream、OutputStream，字符流有Reader、Writer</p><h2 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h2><p><code>public FileInputStream(File file)</code></p><p><code>public FileInputStream(String pathname)</code></p><p><code>public int read() //每次读取一个字节，读取汉字会出现乱码</code></p><p><code>public int read(byte[] buffer) //返回字节数组读取了多少字节，读取完毕返回-1</code></p><p>一次性读取全部字节：<code>public int read(byte[] buffer)</code> <code>public byte[] readAllBytes() throws IOException</code></p><h2 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h2><p><code>public FileOutputStream(File file)</code></p><p><code>public FileOutPutStream(String filepath)</code></p><p><code>public void write(int a)</code></p><p><code>public void write(byte[] buffer)</code></p><h2 id="BufferedInput-x2F-OutputStream"><a href="#BufferedInput-x2F-OutputStream" class="headerlink" title="BufferedInput&#x2F;OutputStream"></a>BufferedInput&#x2F;OutputStream</h2><p>字节缓冲流自带8KB的缓冲池</p><p><code>public BufferedInputStream(InputStream is)</code></p><p><code>public BufferedOutputStream(OutputStream os)</code></p><h2 id="PrintStream-x2F-PrintWriter"><a href="#PrintStream-x2F-PrintWriter" class="headerlink" title="PrintStream&#x2F;PrintWriter"></a>PrintStream&#x2F;PrintWriter</h2><h2 id="DataInput-x2F-OutputStream"><a href="#DataInput-x2F-OutputStream" class="headerlink" title="DataInput&#x2F;OutputStream"></a>DataInput&#x2F;OutputStream</h2><h2 id="ObjectInput-x2F-OutputStream"><a href="#ObjectInput-x2F-OutputStream" class="headerlink" title="ObjectInput&#x2F;OutputStream"></a>ObjectInput&#x2F;OutputStream</h2><p>序列化流</p><p><code>publilc final void writeObject(Object o)</code></p><p><code>public final Object readObject()</code></p><p>对象如果要参与序列化，必须实现序列化接口（java.io.serializable）</p><h2 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h2><p>JDK7开始可以使用try-with-resource进行资源释放</p><p>资源一般指的是最终实现AutoCloseable接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">(</span>定义资源<span class="token punctuation">;</span>定义资源<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span>异常类名 变量名<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2><p><code>public FileReader(File file)</code></p><p><code>public FileReader(String pathname)</code></p><p><code>public int reader()</code></p><p><code>public int reader(char[] buffer)</code></p><h2 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h2><p><code>public FileWriter(File file)</code></p><p><code>public FIleWriter(String filepath)</code></p><p><code>public FileWriter(File file, boolean append)</code></p><p><code>public FIleWriter(String filepath, boolean append)</code></p><p><code>void write(int c)</code></p><p><code>void write(String str)</code></p><p><code>void write(char[] cbuf)</code></p><p>字符输出流写出数据后，必须刷新流或者关闭流，写出的数据才能生效</p><h2 id="BufferedReader-x2F-Writer"><a href="#BufferedReader-x2F-Writer" class="headerlink" title="BufferedReader&#x2F;Writer"></a>BufferedReader&#x2F;Writer</h2><p>字符缓冲流自带8K（8192）的字符缓冲池</p><p><code>public BufferedReader(Reader r)</code></p><p><code>public BufferedWriter(Writer r)</code></p><p><code>public String readline()</code></p><p><code>public void newLine()</code></p><h2 id="Input-x2F-OutputStreamReader"><a href="#Input-x2F-OutputStreamReader" class="headerlink" title="Input&#x2F;OutputStreamReader"></a>Input&#x2F;OutputStreamReader</h2><p>字符输入&#x2F;输出转换流</p><h1 id="IO框架"><a href="#IO框架" class="headerlink" title="IO框架"></a>IO框架</h1><p>commons-io</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-10%20103553.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-10%20103629.png"></p><h1 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h1><p>读写属性文件的内容</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-10%20104550.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-10%20104740.png"></p><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>日志框架：JUL、Log4j、Logback</p><p>日志接口：Commons Logging(JCL)、Simple Logging Facade for Java(SLF4F)</p><p>logback模块：logback-core、logback-classic、logback-access</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Acwing算法基础课</title>
      <link href="/2023/09/20/acwing-suan-fa-ji-chu-ke/"/>
      <url>/2023/09/20/acwing-suan-fa-ji-chu-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p><a href="https://www.acwing.com/activity/content/problem/content/819/">题目链接：785.快速排序</a></p><p>快排算法基于<strong>分治策略</strong></p><ol><li><p>确定分界点x</p><p>取左边界、右边界、中间值、随机值都可以</p></li><li><p>调整区间</p><p>划分为两个区间（<strong>分界点不一定是x</strong>）</p><p>小于等于x的数在左区间</p><p>大于等于x的数在右区间</p></li><li><p>递归的处理左右两区间</p></li></ol><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void quick_sort(int q[], int l,int r)&#123;    int i &#x3D; l - 1, j &#x3D; r + 1;    int x &#x3D; q[l];    while(i &lt; j)    &#123;        do i++; while(q[i] &lt; x);        do j--; while(q[j] &gt; x);        if(i &lt; j) swap(q[i], q[j]);    &#125;    quick_sort(q, l, j);    quick_sort(q, j + 1;r);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><a href="https://www.acwing.com/activity/content/problem/content/821/">题目链接：787.归并排序</a><br>$$<br>O(nlogn)<br>$$</p><p>归并排序算法也是基于<strong>分治策略</strong></p><ol><li>以中间为分界点 <em>mid &#x3D; (l+r)&#x2F;2</em></li><li>递归排序左区间右区间</li><li>归并两个有序区间</li></ol><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void merge_sort(int q[], int l, int r)&#123;    if(l &gt;&#x3D; r) return;    int mid &#x3D; l + r &gt;&gt; 1;    merge_sort(q, l, mid);    merge_sort(q, mid + 1, r);        int k &#x3D; 0, i &#x3D; l, j &#x3D; mid + 1;    while(i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)        if(q[i] &lt;&#x3D; q[j]) tmp[k++] &#x3D; q[i++];    else tmp[k++] &#x3D; q[j++];    while(i &lt;&#x3D; mid) tmp[k++] &#x3D; q[i++];    while(j &lt;&#x3D; r) tmp[k++] &#x3D; q[j++];        for(i &#x3D; l, j &#x3D; 0;i &lt;&#x3D; r;i++, j++)        q[i] &#x3D; tmp[j];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>快排是不稳定的，归并是稳定的</p><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p><a href="https://www.acwing.com/activity/content/problem/content/823/">题目链接：789.数的范围</a></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-22%20183215.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int bsearch_1(int l, int r)&#123;    while(l &lt; r)    &#123;        int mid &#x3D; l+r &gt;&gt; 1;        if(check(mid)) r &#x3D; mid;        else l &#x3D; mid + 1;            &#125;    return 1;&#125;int bsearch_2(int l, int r)&#123;    while(l &lt; r)    &#123;        int mid &#x3D; l + r + 1 &gt;&gt;1;        if(check(mid)) l &#x3D; mid;        else r &#x3D; mid -1;    &#125;    return 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><a href="https://www.acwing.com/activity/content/problem/content/824/">题目链接：790.数的三次方根</a></p><p>浮点数二分无需处理边界</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double bsearch_3(int l, int r)&#123;    const double eps &#x3D; 1e-6; &#x2F;&#x2F;精度要求    while(r-1&gt;eps)    &#123;        double mid &#x3D; (l+r)&#x2F;2;        if(check(mid)) r &#x3D; mid;        else l&#x3D;mid;    &#125;    return 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><p>用数组存储大整数，个位先存，即存储在数组下标为0的位置，十位存在1，以此类推</p><h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;    int t;    for(int i&#x3D;0;i&lt;A.size() || i&lt;B.size();i++)    &#123;        if(i&lt;A.size()) t+&#x3D;A[i];        if(i&lt;B.size()) t+&#x3D;B[i];        C.push_back(t%10);        t&#x2F;&#x3D;10;    &#125;    if(t) C.push_back(1);    return C;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-24%20155127.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt;  sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;    for(int i&#x3D;0,t&#x3D;0;i&lt;A.size();i++)    &#123;        t &#x3D; A[i]-t;        if(i&lt;B.size()) t-&#x3D;B[i];        C.push_back((t+10)%10);        if(t&lt;0) t&#x3D;1;        else t&#x3D;0;    &#125;    while(C.size()&gt;1 &amp;&amp; C.back()&#x3D;&#x3D;0) C.pop_back();    return C;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)&#123;    vector&lt;int&gt; C;    int t&#x3D;0;    for(int i&#x3D;0;i&lt;A.size() || t;i++)    &#123;        if(i &lt; A.size()) t+&#x3D;A[i]*b;        C.push_back(t%10);        t&#x2F;&#x3D;10;    &#125;    return C;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123;    vector&lt;int&gt; C;    r&#x3D;0;    for(int i&#x3D;0;i&#x3D;A.size()-1;i--)    &#123;        r &#x3D; r*10 + A[i];        C.push_back(r &#x2F; b);        r%&#x3D;b;    &#125;    reverse(C.begin(), C.end());    while(C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();    return C;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h2><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-24%20164847.png"></p><h3 id="子矩阵的和"><a href="#子矩阵的和" class="headerlink" title="子矩阵的和"></a>子矩阵的和</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-24%20181723.png"></p><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p>一维差分</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-25%20200510.png"></p><p>注意此处代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i&#x3D;1;i&lt;&#x3D;n;i++) insert(i, i, a[i]);&#x2F;&#x2F;假定a数组最开始都是0，那么b数组初始时就是a数组的差分数组&#x2F;&#x2F;对于每一个a[i]，相当于插入了一个数，可以直接调用insert函数即可<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="差分矩阵"><a href="#差分矩阵" class="headerlink" title="差分矩阵"></a>差分矩阵</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-25%20210003.png"></p><h3 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h3><h4 id="利用i与j的单调关系来降低时间复杂度"><a href="#利用i与j的单调关系来降低时间复杂度" class="headerlink" title="利用i与j的单调关系来降低时间复杂度"></a>利用i与j的单调关系来降低时间复杂度</h4><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-16%20133432.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-16%20134034.png"></p><h4 id="最长连续不重复子序列问题"><a href="#最长连续不重复子序列问题" class="headerlink" title="最长连续不重复子序列问题"></a>最长连续不重复子序列问题</h4><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-16%20143727.png"></p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h4 id="n的二进制表示中，第k位是几"><a href="#n的二进制表示中，第k位是几" class="headerlink" title="n的二进制表示中，第k位是几"></a>n的二进制表示中，第k位是几</h4><ol><li>先把第k位移到最后一位 x&gt;&gt;K</li><li>看个位是几 x&amp;1</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()&#123;    int n&#x3D;10;    for(int k&#x3D;3;k&gt;&#x3D;0;k--) cout&lt;&lt;(n &gt;&gt; k &amp; 1); &#x2F;&#x2F;输出1010&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="lowbit-x-：返回x的最后一位"><a href="#lowbit-x-：返回x的最后一位" class="headerlink" title="**lowbit(x)**：返回x的最后一位"></a>**lowbit(x)**：返回x的最后一位</h4><p><strong>原理：x&amp;-x &#x3D; x&amp;(~x+1)</strong></p><p>x&#x3D;1010 </p><p><em>lowbit</em>(x)&#x3D;10</p><p>x&#x3D;101000</p><p><em>lowbit</em>(x)&#x3D;1000</p><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>只用到大量数据之间的相对关系</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-16%20161646.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-16%20161640.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; alls; &#x2F;&#x2F;存储所有待离散化的值sort(alls.begins(), alls.end());alls.erase(unique(alls.begin(), alls.end()), alls.end()); &#x2F;&#x2F;去重&#x2F;&#x2F;二分求出x对应的离散化的值int find(int x)&#123;    int l&#x3D;0, i&#x3D;alls.size()-1;    while(l&lt;r)    &#123;        int mid &#x3D; l + r &gt;&gt; 1;        if(alls[mid]&gt;&#x3D;x) r&#x3D;mid;        else l &#x3D; mid + 1;    &#125;    return r + 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-16%20171937.png"></p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="链表与邻接表"><a href="#链表与邻接表" class="headerlink" title="链表与邻接表"></a>链表与邻接表</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>邻接表：存储图和树</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-25%20163719.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;定义：head：头节点下标，e：节点i的值，ne：next指针，idx：当前节点int head, e[N], ne[N], idx; &#x2F;&#x2F;初始化void init()&#123;    head &#x3D; -1；    idx &#x3D; 0;&#125;&#x2F;&#x2F;插入头节点后void add_to_head(int x)&#123;    e[idx] &#x3D; x;    ne[idx] &#x3D; head;    head &#x3D; idx;    idx++;&#125;&#x2F;&#x2F;插入到下标为k的节点后void add(int k, int x)&#123;    e[idx] &#x3D; x;    ne[idx] &#x3D; ne[k];    ne[k] &#x3D; idx;    idx++;&#125;&#x2F;&#x2F;删除下标为k节点后的节点void remove(int x)&#123;    ne[k] &#x3D; ne[ne[k]];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int e[N], l[N], r[N], idx;&#x2F;&#x2F;初始化void init()&#123;    &#x2F;&#x2F;0是左端点，1是右端点    r[0] &#x3D; 1;    l[1] &#x3D; 0;    idx &#x3D; 2;&#125;&#x2F;&#x2F;在第k个节点后插入xvoid add(int k, int x)&#123;    e[idx] &#x3D; x    r[idx] &#x3D; r[k];    l[idx] &#x3D; k;    l[r[k]] &#x3D; idx;    r[k] &#x3D; idx;    &#125;&#x2F;&#x2F;删除void remove(int k)&#123;    r[l[k]] &#x3D; r[k];    l[r[k]] &#x3D; l[k];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;***************栈******************int stk[N], tt;&#x2F;&#x2F;插入stk[++tt] &#x3D; x;&#x2F;&#x2F;弹出tt--;&#x2F;&#x2F;判断栈是否为空if(tt &gt; 0) not empty    else empty &#x2F;&#x2F;栈顶元素 stk[tt];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;*****************队列******************int q[N], hh, tt &#x3D; -1;&#x2F;&#x2F;插入q[++tt] &#x3D; x;&#x2F;&#x2F;弹出hh++;&#x2F;&#x2F;判断是否为空if(hh &lt;&#x3D; tt) not empty    else empty&#x2F;&#x2F;取出队头q[hh];&#x2F;&#x2F;队尾q[tt];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>常用场景：求序列中每个数左边离它最近的符合条件的数</p><p>删掉所有逆序值</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;部分代码for(int i&#x3D;0;i &lt; n;i++)&#123;    cin &gt;&gt; x;    while(tt &amp;&amp; stk[tt] &gt;&#x3D; x) tt--;    if(tt) cout &lt;&lt; stk[tt] &lt;&lt; endl;    else cout &lt;&lt; -1 &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>常用场景：求滑动窗口中的最大值或最小值</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;部分代码((求最小值)int hh &#x3D; 0, tt &#x3D; -1;for(int i&#x3D;0;i &lt; n; i++)&#123;    &#x2F;&#x2F;判断队头是否已经滑出窗口    if(hh &lt;&#x3D; tt &amp;&amp; i-k + 1 &gt; q[hh]) hh++;    while(hh &lt;&#x3D; tt &amp;&amp; a[q[tt]] &gt;&#x3D; a[i]) tt--;        q[++tt] &#x3D; i;    if(i &gt;&#x3D; k - 1) cout&lt;&lt;a[q[hh]];    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-28%20191022.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-28%20192022.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;匹配过程int n, m;int p[N], s[M];int next[N];int main()&#123;    &#x2F;&#x2F;求next数组    for(int i&#x3D;2, j&#x3D;0;i &lt;&#x3D;n;i++)    &#123;        while(j &amp;&amp; p[i] !&#x3D; p[j+1]) j &#x3D; next[j];         if(p[i] &#x3D;&#x3D; p[j+1]) j++;         next[i] &#x3D; j;&#125;        &#x2F;&#x2F;KMP匹配过程    for(int i&#x3D;1, j&#x3D;0;i&lt;&#x3D;m;i++)    &#123;        &#x2F;&#x2F;j没退回起点且当前的s[i]无法匹配        while(j &amp;&amp; s[i] !&#x3D; p[j+1]) j &#x3D; next[j];        if(s[i] &#x3D;&#x3D; p[j+1]) j++;        if(j &#x3D;&#x3D; n)&#123;            &#x2F;&#x2F;匹配成功            printf(&quot;%d&quot;,i - n + 1);            j &#x3D; next[j];        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p>存储和查找字符串集合</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;cnt[p]：以p为结尾的单词的单词数量int son[N][26], cnt[N], idx;&#x2F;&#x2F;插入void insert(char str[])&#123;    int p &#x3D; 0;    for(int i &#x3D; 0; str[i]; i++)    &#123;        int u &#x3D; str[i] - &#39;a&#39;;        if(!son[p][u]) son[p][u] &#x3D; ++ idx;        p &#x3D; son[p][u];    &#125;    cnt[p]++;&#125;&#x2F;&#x2F;查询int query(char str[])&#123;    int p &#x3D; 0;    for(int i&#x3D;0;str[i]; i++)    &#123;        int u &#x3D; str[i] &#x3D; &#39;a&#39;;        if(!son[p][u]) return 0;        p &#x3D; son[p][u];    &#125;    return cnt[p];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>1.将两个集合合并</p><p>2.询问两个元素是否在一个集合中</p><p>每个集合用一棵树来表示，每棵树根节点的编号是集合的编号，存储每个节点的父节点<code>p[x]</code></p><p>问题一：如何判断树根<code>if(p[x]==x)</code></p><p>问题二：如何求x的集合编号：<code>while(p[x] != x) x = p[x];</code></p><p>问题三：如何合并两个集合：<code>p[x] = y</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;返回x的祖宗节点 + 路径压缩int find(int x)&#123;    if(p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);    return p[x];&#125;&#x2F;&#x2F;合并集合p[find(a)] &#x3D; find(b);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>以小根堆为例</p><p>heap数组下标从1开始</p><p>1.插入一个数 <code>heap[++size] = x; up(size);</code></p><p>2.求集合中最小值 <code>heap[1]；</code></p><p>3.删除最小值 <code>heap[1] = heap[size]; size--; down(1);</code></p><p>4.删除任意一个元素 <code>heap[k] = heap[size]; size--; down(k); up(k);</code></p><p>5.修改任意一个元素 <code>heap[k] = x; down(k); up(k);</code></p><p>6.建堆：<code>for(int i = n/2;i;i--) down(i);</code></p><p>存储：x的左儿子是2x，右儿子是2x+1</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void down(int u)&#123;    int t &#x3D; u;    if(u * 2 &lt;&#x3D;size &amp;&amp; h[u * 2] &lt; h[t]) t &#x3D; u * 2;    if(u * 2 + 1 &lt;&#x3D; size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t &#x3D; u * 2 + 1;    if(u !&#x3D; t)&#123;        swap(h[u], h[t]);        down(t);    &#125;&#125;void up(int u)&#123;    while(u &#x2F; 2 &amp;&amp; h[u &#x2F; 2] &gt; h[u])&#123;    swap(h[u &#x2F; 2], h[u]);     u &#x2F;&#x3D; 2;       &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表存储结构：开放寻址法、拉链法</p><h3 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h3><p>取模一般取质数，并且离2的的整次幂尽可能远</p><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p>创建一个一维数组，每个位置是相同位置数的链接</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-25%20133638.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int N &#x3D; 100003;int h[N], e[N], ne[N], idx;void insert(int  x)&#123;    int k &#x3D; (x % N + N) % N; &#x2F;&#x2F;加N模N的目的是为了让k不等于负数    e[idx] &#x3D;  x;    ne[idx] &#x3D; h[k];    h[k] &#x3D; idx++;&#125;bool find(int x)&#123;    int k &#x3D; (x % N + N) % N;    for(int i &#x3D; h[k];i !&#x3D; -1;i &#x3D; ne[i])&#123;        if(e[i] &#x3D;&#x3D; x)            return true;&#125;    return false;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>创建一个一维数组，范围是题目数组的2~3倍</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int N &#x3D; 200003, null &#x3D; 0x3f3f3f3f;int h[N];int find(int x)&#123; &#x2F;&#x2F;如果x存在，返回x的位置；如果x不存在，找到x应该放置的位置    int k &#x3D; (x % N + N) % N;     while(h[k] !&#x3D; null &amp;&amp; h[k] !&#x3D; x)&#123;        k++;        if(k &#x3D;&#x3D;N) k &#x3D; 0;    &#125;    return k;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符串哈希方式"><a href="#字符串哈希方式" class="headerlink" title="字符串哈希方式"></a>字符串哈希方式</h3><p>快速判断两个字符串相不相等</p><p>把字符串看作是P进制的数</p><p>求出该数后取模，将该数映射到小范围Q上</p><p>当P &#x3D; 131 或 13331，Q一般取2的64次方</p><p>一般情况不会映射成0</p><p>假设不会出现冲突</p><p><strong>字符串前缀哈希</strong></p><p>求出前缀哈希，可以算出所有子段的哈希值</p><p>使用unsigned long long存储可以不需要取模</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int N &#x3D; 100010, P &#x3D; 131;typedef unsigned long long ULL;char str[N];ULL h[N], p[N];&#x2F;&#x2F;初始化p[0] &#x3D; 1;for(int i&#x3D;1;i &lt;&#x3D; n;i++)&#123;    p[i] &#x3D; p[i - 1] * P;    h[i] &#x3D; h[i - 1] * P + str[i];&#125;ULL get(int l, int r)&#123;    return h[r] - h[l - 1] * p[r - l + 1];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h1><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>数字全排列</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void dfs(int u)&#123;    if(u &#x3D;&#x3D; n) &#123;        for(int i&#x3D;0;i&lt;n;i++) cout&lt;&lt;path[i];        puts(&quot;&quot;);        return;    &#125;    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;        path[u]&#x3D;i;        st[i]&#x3D;true;        dfs(u+1);        st[i]&#x3D;false;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>n后问题</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char g[N][N];bool col[N], dg[N], udg[N];void dfs(int u)&#123;    if(u &#x3D;&#x3D; n)    &#123;        for(int i&#x3D;0;i&lt;n;i++) puts(g[i]);        puts(&quot;&quot;);        return;    &#125;    for(int i&#x3D;0;i&lt;n;i++)    &#123;        if(!col[i] &amp;&amp; !dg[u+i] &amp;&amp; !udg[n-u+i])        &#123;            g[u][i] &#x3D; &#39;Q&#39;;            col[i] &#x3D; dg[u+i] &#x3D; udg[n-u+i] &#x3D; true;            dfs(u+1);            col[i] &#x3D; dg[u+i] &#x3D; udg[n-u+i] &#x3D; false;            g[u][i] &#x3D; &#39;.&#39;;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>走迷宫</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int bfs()&#123;    int hh&#x3D;0,tt&#x3D;0;    q[0] &#x3D; &#123;0,0&#125;;    memset(d, -1, sizeof d);    d[0][0] &#x3D; 0;    int dx[4]&#x3D;&#123;-1, 0, 1, 0&#125;;    int dy[4]&#x3D;&#123;0, 1, 0, -1&#125;;        while(hh &lt;&#x3D; tt)    &#123;        auto t &#x3D; q[hh++];        for(int i&#x3D;0;i&lt;4;i++)        &#123;            int x&#x3D;t.first+dx[i];            int y&#x3D;t.second+dy[i];            if(x &gt;&#x3D; 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;&#x3D; 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] &#x3D;&#x3D; 0 &amp;&amp; d[x][y] &#x3D;&#x3D; -1)            &#123;                d[x][y]&#x3D;d[t.first][t.second] + 1;                q[++tt] &#x3D; &#123;x, y&#125;;            &#125;        &#125;    &#125;    return d[n - 1][m - 1];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="树的DFS"><a href="#树的DFS" class="headerlink" title="树的DFS"></a>树的DFS</h2><p>有向图：</p><ul><li>邻接矩阵</li><li>邻接表</li></ul><p>树的存储</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int h[N], e[M], ne[M], idx;void add(int a, int b)&#123;    e[idx]&#x3D;b;    ne[idx]&#x3D;h[a];    h[a]&#x3D;idx++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>树的遍历</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int st[N];void dfs(int u)&#123;    st[u]&#x3D;true;    for(int i&#x3D;h[u];i !&#x3D; -1;i&#x3D;ne[i])    &#123;        int j&#x3D;e[i];        if(!st[j]) dfs(j);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="树的BFS"><a href="#树的BFS" class="headerlink" title="树的BFS"></a>树的BFS</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int h[N],e[N],ne[N],idx;int d[N],q[N]; &#x2F;&#x2F;d[N]: 每个点到起点的距离  q[N]:  模拟队列void add(int a, int b)&#123;    e[idx] &#x3D; b;    ne[idx] &#x3D; h[a];    h[a] &#x3D; idx++;&#125;int bfs()&#123;    int hh&#x3D;0,tt&#x3D;0;    q[0] &#x3D; 1;    memset(d, -1, sizeof d);    d[1] &#x3D; 0;    while(hh &lt;&#x3D; tt)    &#123;        int t &#x3D; q[hh++];        for(int i&#x3D;h[t];i !&#x3D; -1;i &#x3D; ne[i])        &#123;            int j &#x3D; e[i];            if(d[j] &#x3D;&#x3D; -1)            &#123;                d[j] &#x3D; d[t] + 1;                q[++tt] &#x3D; j;            &#125;        &#125;    &#125;    return d[n];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="有向图的拓扑序列"><a href="#有向图的拓扑序列" class="headerlink" title="有向图的拓扑序列"></a>有向图的拓扑序列</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int h[N],e[N],ne[N],idx;int d[N],q[N]; &#x2F;&#x2F;d[N]:  节点的入度void add(int a, int b)&#123;    e[idx]&#x3D;b;    ne[idx]&#x3D;h[a];    h[a]&#x3D;idx++;&#125;bool topsort()&#123;    int hh&#x3D;0,tt&#x3D;-1;    for(int i&#x3D;1;i&lt;&#x3D;n;i++)        if( ! d[i]) q[++tt] &#x3D; i;    while(hh &lt;&#x3D; tt)    &#123;        int t&#x3D;q[hh++];        for(int i&#x3D;h[t];i !&#x3D; -1;i&#x3D;ne[i])        &#123;            int j&#x3D;e[i];            d[j]--;            if(d[j]&#x3D;&#x3D;0) q[++tt]&#x3D;j;        &#125;    &#125;    return tt&#x3D;&#x3D;n-1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h2><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-05%20103240.png"></p><h3 id="朴素Dijkstra"><a href="#朴素Dijkstra" class="headerlink" title="朴素Dijkstra"></a>朴素Dijkstra</h3><ol><li><p>dist[1] &#x3D; 0, dist[i] &#x3D; ∞，s: 当前已确定最短距离的点</p></li><li><p>for(i &#x3D; 0~n)</p><p>t&lt;-不在s中的距离最近的点</p><p>s&lt;-t</p><p>用t来更新其他点的距离</p></li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int g[N][N]; &#x2F;&#x2F;稠密图int dist[N];bool st[N];int dijkstra()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1]&#x3D;0;    for(int i&#x3D;0;i&lt;n;i++)    &#123;        int t&#x3D;-1;        for(int j&#x3D;1;j&lt;&#x3D;n;j++)            if(!st[j] &amp;&amp; (t&#x3D;&#x3D;-1 || dist[t] &gt; dist[j]))                t&#x3D;j;        for(int j&#x3D;1;j&lt;n;j++)        &#123;            dist[j] &#x3D; min(dist[j], dist[t] + g[t][j]);        &#125;        st[t] &#x3D; true;    &#125;    if(dist[n]&#x3D;&#x3D;0x3f3f3f3f) return -1;    return dist[n];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="堆优化的Dijkstra"><a href="#堆优化的Dijkstra" class="headerlink" title="堆优化的Dijkstra"></a>堆优化的Dijkstra</h3><p>手写堆或者优先队列</p><p>此处采用优先队列</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int h[N], e[N], ne[N], w[N], idx;int dist[N];bool st[N];typedef pair&lt;int, int&gt; PII;void add(int a, int b, int c)&#123;    e[idx] &#x3D; b;    w[idx] &#x3D; c;    ne[idx] &#x3D; h[a];    h[a] &#x3D; idx++;&#125;int dijkstra()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1] &#x3D; 0;    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;    heap.push(&#123;0, 1&#125;);        while(heap.size())    &#123;        auto t &#x3D; heap.top();        int ver &#x3D; t.second, distance&#x3D;t.first;        if(st[ver]) continue;        st[ver] &#x3D; true;        for(int i&#x3D;h[ver],i!&#x3D;-1;i&#x3D;ne[i])        &#123;            int j&#x3D;e[i];            if(dist[j] &gt; distance + w[i])            &#123;                dist[j] &#x3D; distance + w[i];                heap.push(&#123;dist[j], j&#125;);            &#125;        &#125;    &#125;    if(dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;    else return dist[n];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int dist[N];int backup[N];struct Edge&#123;    int a,b,w;&#125;edges[M];int bellmanford()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1]&#x3D;0;    for(int i&#x3D;0;i&lt;n;i++)    &#123;        memcpy(backup, dist, sizeof dist);        for(int j&#x3D;0;j&lt;m;j++)        &#123;            int a&#x3D; edges[i].a, b&#x3D;edges[i].b, w&#x3D;edges[i].w;            dist[b] &#x3D; min(dist[b], dist[a]+w);        &#125;    &#125;    if(dist[n] &gt; 0x3f3f3f3f &#x2F; 2) return -1;    else return dist[n];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h3><p>queue-&gt;1</p><p>while queue不空</p><p>​t&lt;-q.front</p><p>​q.pop()</p><p>​更新t的所有出边</p><p>​queue&lt;-b</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int h[N], e[N], w[N], ne[N], idx;int dist[N];bool st[N];void spfa()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1]&#x3D;0;        queue&lt;int&gt; q;    q.push(1);        while(q.size())    &#123;        int t&#x3D;q.front();        q.pop();        st[t]&#x3D;false;        for(int i&#x3D;h[t];i!&#x3D;-1;i&#x3D;ne[i])        &#123;            int j&#x3D;e[i];            if(dist[j] &gt; dist[t]+w[i])            &#123;                dist[j] &#x3D; dist[t]+w[i];                if(!st[j])                &#123;                    q.push(j);                    st[j]&#x3D;false;                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int d[N][N];void floyd()&#123;    for(int k&#x3D;1;k&lt;&#x3D;n;k++)        for(int i&#x3D;1;i&lt;&#x3D;n;i++)            for(int j&#x3D;1;j&lt;&#x3D;n;j++)                d[i][j] &#x3D; min(d[i][j], d[i][k] + d[k][j]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int g[N][N];int dist[N];bool st[N];int prim()&#123;    memset(dist, 0x3f, sizeof dist );    int res &#x3D; 0;    for(int i&#x3D;0; i&lt;n; i++)    &#123;        int t &#x3D; -1;        for(int j&#x3D;1;j &lt;&#x3D; n; j++)        if( !st[t] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[t] &gt; dist[j]))                t&#x3D;j;        if(i &amp;&amp; dist[t]&#x3D;&#x3D;INF) return INF;        if(i) res+&#x3D;dist[t];        st[t] &#x3D; true;        for(int j&#x3D;1;j&lt;&#x3D;n;j++)            dist[j] &#x3D; min(dist[j], g[t][j]);    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Kruscal算法"><a href="#Kruscal算法" class="headerlink" title="Kruscal算法"></a>Kruscal算法</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int p[N];struct Edge&#123;int a,b,w;    bool operator&lt; (const Edge &amp;W)const&#123;        return w&lt;W.w;    &#125;&#125;edges[N];int find(int x)&#123;    if(p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);    return p[x];&#125;int main()&#123;    int res &#x3D; 0, cnt &#x3D; 0;    sort(edges, edges + m);    for(int i&#x3D;0;i&lt;m;i++)    &#123;        int a &#x3D; edges[i].a, b &#x3D; edges[i].b, w &#x3D; edges[i].w;        a&#x3D;find(a);        b&#x3D;find(b);        if(a!&#x3D;b)        &#123;            p[a]&#x3D;b;            res+&#x3D;w;            cnt++;        &#125;    &#125;    if(cnt &lt; n-1) puts(&quot;impossible&quot;);    else cout&lt;&lt;res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p>一个图为二分图当且仅当图中不含有奇数环</p><h3 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool bfs(int u, int c)&#123;    color[u] &#x3D; c;    for(int i&#x3D;h[u]; i!&#x3D;-1; i&#x3D;ne[i])    &#123;        int j&#x3D;e[i];        if(!color[j])        &#123;            if(!dfs(j, 3-c)) return false;        &#125;        else if(color[j] &#x3D;&#x3D; c) return false;    &#125;    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p>求二分图最大匹配数</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool find(int x)&#123;    for(int i&#x3D;h[x]; i !&#x3D; -1; i&#x3D;ne[i])&#123;        if( ! st[j])&#123;            st[j] &#x3D; true;            if(match[i] &#x3D;&#x3D; 0 || find(match[j])) &#123;                match[j] &#x3D; x;                return true;            &#125;        &#125;    &#125;    return false;&#125;int main()&#123;    int res &#x3D; 0;    for(int i&#x3D;1; i&lt;n1; i++)&#123;        memset(st, false, sizeof st);        if(find(i)) res++;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-18%20193456.png"></p><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h2><p>一维优化</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i&#x3D;0;i&lt;&#x3D;n;i++)    for(int j&#x3D;m;j&gt;&#x3D;v[i];j--)        f[j] &#x3D; max(f[j], f[j-v[i]] + w[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>优化</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-18%20204237.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i&#x3D;1;i&lt;&#x3D;n;i++)    for(int j&#x3D;v[i];j&lt;&#x3D;m;j++)        f[j] &#x3D; max(f[j], f[j - v[i]] + w[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i&#x3D;0;i&lt;&#x3D;n;i++)    for(int j&#x3D;0;j&lt;&#x3D;m;j++)        for(int k&#x3D;0;k&lt;&#x3D;s[i];k++)            f[i][j] &#x3D; max(f[i][j], f[i-1][j-v[i] * j] + w[i] * k);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="优化多重背包"><a href="#优化多重背包" class="headerlink" title="优化多重背包"></a>优化多重背包</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int cnt &#x3D; 0;for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;    int a,b,s;    int k &#x3D; 1;    while(k &lt;&#x3D; s)    &#123;cnt++;        v[cnt] &#x3D; a * k;        w[cnt] &#x3D; b * k;        s-&#x3D;k;        k*&#x3D;2;    &#125;    if(s&gt;0)    &#123;cnt++;        v[cnt] &#x3D; a * s;        w[cnt] &#x3D; b * s;    &#125;&#125;n &#x3D; cnt;for(int i&#x3D;1;i&lt;&#x3D;n;i++)    for(int j&#x3D;m;j&gt;&#x3D;v[i];j++)        f[j] &#x3D; max(f[j], f[j-v[i]] + w[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i&#x3D;1;i&lt;&#x3D;n;i++)    for(int j&#x3D;m;j&gt;&#x3D;0;j--)        for(int k&#x3D;0;k&lt;s[i];k++)            if(v[i][k] &lt;&#x3D; j)                f[j] &#x3D; max(f[j], f[j - v[i][k]] + w[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【MIT6.S081】-Lab3</title>
      <link href="/2023/09/19/mit6.s081-lab3/"/>
      <url>/2023/09/19/mit6.s081-lab3/</url>
      
        <content type="html"><![CDATA[<p>由于Chapter 2的内容比较容易理解，此处仅总结部分内容</p><p>很好的课程翻译的文章：</p><p><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081">https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081</a></p><p>课程链接：</p><p>MIT6.S081：<a href="https://pdos.csail.mit.edu/6.828/2020/overview.html">https://pdos.csail.mit.edu/6.828/2020/overview.html</a></p><p>b站课程视频（中字）：</p><p><a href="https://www.bilibili.com/video/BV19k4y1C7kA/?spm_id_from=333.337.search-card.all.click&vd_source=340915f3230d1ae45078727ac8d6732f">https://www.bilibili.com/video/BV19k4y1C7kA/?spm_id_from=333.337.search-card.all.click&amp;vd_source=340915f3230d1ae45078727ac8d6732f</a></p><h1 id="Chapter-2：Operating-system-organization"><a href="#Chapter-2：Operating-system-organization" class="headerlink" title="Chapter 2：Operating system organization"></a>Chapter 2：Operating system organization</h1><p>虚拟地址va：VPN+oddset</p><p>物理地址paPPN+offset</p><p>页内偏移量offset：决定一页的大小</p><p>物理页帧：page frame</p><p>虚拟页面号：virtual page number</p><p>操作系统必须满足三个要求：复用、隔离和交互</p><h2 id="2-1-Abstracting-physical-resources"><a href="#2-1-Abstracting-physical-resources" class="headerlink" title="2.1 Abstracting physical resources"></a>2.1 Abstracting physical resources</h2><p>为了实现隔离，避免让应用直接接触硬件资源，操作系统将资源抽象为服务</p><p>Unix 进程使用 exec 来构建它们的内存映像，而不是直接与物理内存交互。 这允许操作系统决定将进程放置在内存中的位置</p><p>Unix 进程之间的许多形式的交互都是通过文件描述符发生的。 文件描述符不仅抽象了许多细节（例如，管道或文件中数据的存储位置），而且还以简化交互的方式定义。</p><h2 id="2-2-User-mode-supervisor-mode-and-system-calls"><a href="#2-2-User-mode-supervisor-mode-and-system-calls" class="headerlink" title="2.2 User mode, supervisor mode,  and system calls"></a>2.2 User mode, supervisor mode,  and system calls</h2><p>RISC-V有三种模式，机器模式、管理员模式和用户模式</p><p>xv6会在机器模式下运行几行之后转到管理员模式</p><p>在管理者模式，CPU可以执行特权指令</p><p>如果用户模式下的应用程序尝试执行特权指令，则 CPU 不会执行该指令，而是切换到管理员模式，终止该应用程序</p><p>应用程序只能执行用户模式指令，在用户空间中运行，而管理模式下的软件也可以执行特权指令，在内核空间中运行。</p><p>运行在内核空间（或管理模式）的软件称为内核</p><p>CPU提供相关的指令来在内核指定的入口进入内核，并且有内核来验证系统调用的参数是否合理、应用程序的请求是否可以执行</p><h2 id="2-3-Kernel-organization"><a href="#2-3-Kernel-organization" class="headerlink" title="2.3 Kernel organization"></a>2.3 Kernel organization</h2><p>如果内核拥有全部的操作系统，则该内核被称作宏内核</p><p>在宏内核中，操作系统各个部分的接口可能会很复杂</p><p>在用户模式下执行操作系统的大部分内容，在管理模式下运行的操作系统代码量被尽可能地减少。，这种内核组织称为微内核</p><p>在微内核中，为了允许应用程序与文件服务器交互，内核提供了一种进程间通信机制，将消息从一个用户模式进程发送到另一个用户模式进程</p><h2 id="2-5-Process-overview"><a href="#2-5-Process-overview" class="headerlink" title="2.5 Process overview"></a>2.5 Process overview</h2><p>Xv6 使用页表（由硬件实现）为每个进程提供自己的地址空间，通过页表，可以将虚拟地址转换为物理地址</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-01%20160628.png"></p><p><strong>struct proc</strong>描述了跟进程有关的信息，最重要的几个部分有页表、内核栈、运行阶段</p><p>使用p-&gt;xxx来引用proc结构体中的内容，例如p-&gt;pagetable</p><p>每个进程都有一个执行线程，用于执行进程的指令。线程可以被挂起并稍后恢复。</p><p>为了在进程之间无缝切换，内核会挂起当前正在运行的线程并恢复另一个进程的线程。线程的大部分状态，如局部变量和函数调用返回地址，都存储在线程的堆栈中。</p><p>每个进程有两个堆栈：用户堆栈和内核堆栈（p-&gt;kstack）。</p><p>当进程执行用户指令时，只使用用户堆栈，内核堆栈为空。当进程进入内核（进行系统调用或中断）时，内核代码在进程的内核堆栈上执行。进程位于内核中时，用户堆栈仍然包含保存的数据，但不会主动使用。</p><p>进程的线程在用户堆栈和内核堆栈之间交替使用。内核堆栈是独立的，并受到用户代码的保护，因此即使进程破坏了其用户堆栈，内核仍然可以执行。</p><h1 id="Chapter-3-Page-tables"><a href="#Chapter-3-Page-tables" class="headerlink" title="Chapter 3 Page tables"></a>Chapter 3 Page tables</h1><p>页表通过隔离不同进程的地址空间来复用单个地址空间</p><h2 id="3-1-Paging-hardware"><a href="#3-1-Paging-hardware" class="headerlink" title="3.1 Paging hardware"></a>3.1 Paging hardware</h2><p>xv6使用64位虚拟地址的低39位，高25位不被使用</p><p>RISC-V逻辑上是存储2的27次方个<strong>PTE</strong>（page table entries 页表项）的数组</p><p>在xv6中，页表在物理内存中分三级存储：</p><p>每级页表有4096字节，包含512个<strong>PTE</strong>，用来寻找下一级页表的<strong>物理地址</strong>，每个PTE包括44位的<strong>PNN</strong>（物理页号）和12位的<strong>标志位</strong></p><p>标志位以及所有页表硬件相关的结构定义在kernel&#x2F;riscv.h中</p><blockquote><p>一些标志位的含义：</p><p>PTE_V: PTE是否存在</p><p>PTE_R: 是否可读</p><p>PTE_W: 是否可写 </p><p>PTE_X: CPU是否应将页的内容编译为指令并执行</p><p>PTE_U: 用户模式中的指令是否可以控制页</p></blockquote><p>内核会将最低一级的页表的物理地址的起始处（0）存储在satp寄存器中，即satp指向最低一级页表的零地址</p><p>硬件将虚拟地址被使用的那39位的高27位转换为索引来寻找PTE，低12位会传递给物理地址</p><p>xv6中，这27位被分为三部分，每个部分有9位，分别用来寻找最低一级、中间级、最高一级的页表</p><p>通过页表转换出的物理地址有56位，高44位来自PTE的PNN，剩下的12位来自虚拟地址的低12位（offset）</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-01%20170021.png"></p><h2 id="3-2-Kernel-address-space"><a href="#3-2-Kernel-address-space" class="headerlink" title="3.2 Kernel address space"></a>3.2 Kernel address space</h2><p>xv6为每个进程维护一个页表来描述用户地址空间，另一个单个页表来描述内核地址空间</p><p>xv6中，物理地址从0x80000000开始，一直持续到至少0x86400000，0x86400000这个位置叫做PHYSTOP</p><p>0x80000000以下的地址空间被分配给了设备接口，把作为内存映射控制寄存器提供给软件，内核可以通过读&#x2F;写这些特殊的物理地址来与设备进行交互； 此类读取和写入与设备硬件而不是 RAM 进行通信</p><blockquote><p>trampoline（跳板）： </p><p>在操作系统中，trampoline（跳板）是一种特殊的代码结构，用于在用户态和内核态之间进行切换或传递控制。  当一个进程需要执行系统调用或触发中断时，它需要从用户态切换到内核态。这个切换过程需要确保安全性和正确性，并且需要一些特定的代码来处理这个切换。  Trampoline是在内核中为此目的而设计的代码块。它通常位于内核的固定地址中，可以被所有进程访问。当进程触发系统调用或中断时，它会跳转到trampoline代码，然后由trampoline代码负责完成切换到内核态的工作。  Trampoline代码的主要任务是保存进程的上下文（如寄存器的值）和参数，然后执行相应的内核函数。一旦内核函数执行完毕，trampoline代码会负责将控制权返回给进程，并恢复进程的上下文。  通过使用trampoline，操作系统可以实现用户态和内核态之间的安全切换，并提供了一种统一的接口，使得进程可以方便地触发系统调用或中断。(来源chatGPT)</p><p>trampoline在虚拟地址的最顶部，为进行用户态和内核态的切换或传递控制，映射到KERNELBASE，即内核的起始处。</p></blockquote><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-01%20171403.png"></p><h2 id="3-3-Code-creating-an-address-space"><a href="#3-3-Code-creating-an-address-space" class="headerlink" title="3.3 Code: creating an address space"></a>3.3 Code: creating an address space</h2><p>vm.c中的核心数据结构是pagetable_t，指向RISC-V根页表</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-01%20182310.png" alt="pagetable_t"></p><p>核心功能是<strong>walk</strong>：查找虚拟地址的PTE和<strong>mappages</strong>：为新映射安装PTE</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/2.png"></p><p><strong>mappages中，虚拟地址的起始位置在va，物理地址的起始地址在pa</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/1.png"></p><p>以kvm开头的函数操作内核页表，以uvm开头的函数操作用户页表</p><p>copyin和copyout从用户提供的虚拟地址中提取数据作为系统调用的参数</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-01%20182648.png" alt="vm.c/copyout"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-01%20182753.png" alt="vm.c/copyin"></p><blockquote><p>main 调用 kvminit (kernel&#x2F;vm.c:22) 来创建内核的页表。 此调用发生在 xv6 在 RISC-V 上启用分页之前，因此地址直接引用物理内存。 Kvminit 首先分配一个物理内存页来保存根页表页。 然后它调用 kvmmap 来安装内核所需的翻译。 翻译包括内核的指令和数据、直至 PHYSTOP 的物理内存以及实际上是设备的内存范围。</p></blockquote><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-01%20183134.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-01%20185004.png" alt="vm.c/kvminit"></p><p>main调用的kvminithart</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-01%20193728.png" alt="main.c"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-01%20193453.png"></p><p>main 调用的 procinit</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-01%20194557.png"></p><h2 id="3-4-Physical-memory-allocation"><a href="#3-4-Physical-memory-allocation" class="headerlink" title="3.4 Physical memory allocation"></a>3.4 Physical memory allocation</h2><p>xv6使用内核末尾和PHYSTOP之间的物理内存进行运行时的分配</p><p>xv6一次分配和释放整个4196字节页面</p><h2 id="3-5-Code-Physical-memory-allocator"><a href="#3-5-Code-Physical-memory-allocator" class="headerlink" title="3.5 Code: Physical memory allocator"></a>3.5 Code: Physical memory allocator</h2><p>Allocator的数据结构是可用于分配的物理内存页的空闲列表，且该空闲列表受自旋锁的保护，列表和锁被定义在同一个结构体内</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-01%20215917.png"></p><p>每个空闲页面的列表元素都是一个结构体 run</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-01%20215924.png"></p><p>main调用knit来初始化allocator，kinit初始化空闲列表来保存内核末尾和PHYSTOP之间的每个页面</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-01%20220434.png"></p><p>关于kfree函数</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-01%20221422.png"></p><h2 id="3-6-Process-address-space"><a href="#3-6-Process-address-space" class="headerlink" title="3.6 Process address space"></a>3.6 Process address space</h2><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-14%20113740.png"></p><p>堆栈是一个单页，并显示由 exec 创建的初始内容。 包含命令行参数的字符串以及指向它们的指针数组位于刚刚被调用的 main(argc, argv) 处。</p><p>xv6 在堆栈正下方放置了一个无效的保护页。 如果用户堆栈溢出并且进程尝试使用堆栈下方的地址，则硬件将生成页面错误异常，因为映射无效。</p><h2 id="3-7-Code：exec"><a href="#3-7-Code：exec" class="headerlink" title="3.7 Code：exec"></a>3.7 Code：exec</h2><p>exec实际是一个系统调用，用于创建用户地址空间</p><p>exec利用存储的文件来初始化用户地址空间</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-14%20114537.png"></p><p>exec每次只分配一个堆栈页，它将参数字符串复制到堆栈顶部，将指向这些参数的指针记录在ustack中</p><p>映像完成后，，exec提交新页表，释放旧页表</p><h1 id="Lab-page-tables"><a href="#Lab-page-tables" class="headerlink" title="Lab: page tables"></a>Lab: page tables</h1><p>在本实验中，您将探索页表并修改它们以简化将数据从用户空间复制到内核空间的功能。</p><blockquote><p>在开始编码之前，请阅读xv6书的第3章以及相关文件：</p><ul><li>kern&#x2F;memlayout.h，它描述了内存的布局。 </li><li>kern&#x2F;vm.c，其中包含大部分虚拟内存（VM）代码。 </li><li>kernel&#x2F;kalloc.c，其中包含用于分配和释放物理内存的代码。</li></ul></blockquote><p>切换到pgtbl分支来开始实验</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> fetch$ <span class="token function">git</span> checkout pgtbl$ <span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h2><p>帮助你学习RISC-V页表，并可能帮助未来的调试，你的第一个任务是编写一个打印页表内容的函数。</p><blockquote><p>定义一个名为vmprint()的函数。它应该接受一个pagetable_t参数，并以下面描述的格式打印该pagetable。</p><p>在exec.c中，在return argc之前插入if(p-&gt;pid&#x3D;&#x3D;1) vmprint(p-&gt;pagetable)，以打印第一个进程的页表。如果您通过make grade的pte打印测试，则获得此任务的全部学分。</p></blockquote><p>现在当您启动xv6时，它应该打印出类似于这样的输出，描述了第一个进程的页表，此时它刚刚完成了exec()ing init的过程：</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-19%20162439.png"></p><p>第一行显示了vmprint的参数。之后，每个PTE都有一行，包括引用树中更深层次的页表页的PTE。每个PTE行都以一些” ..”缩进，表示其在树中的深度。每个PTE行显示其页表页中的PTE索引、pte位和从PTE中提取的物理地址。不要打印无效的PTE。在上面的示例中，顶层页表页具有条目0和255的映射。下一级的条目0只有索引0被映射，而该索引0的底层具有条目0、1和2的映射。</p><p>您的代码可能会产生与上面显示的物理地址不同的地址。 条目数和虚拟地址应该是相同的。</p><blockquote><p>一些提示：  </p><ul><li>您可以将vmprint()放在kernel&#x2F;vm.c中。 </li><li>使用文件kernel&#x2F;riscv.h末尾的宏。 </li><li>函数freewalk可能会给您灵感。 </li><li>在kernel&#x2F;defs.h中定义vmprint的原型，以便您可以从exec.c中调用它。 </li><li>在printf调用中使用%p来打印出完整的64位十六进制PTEs和地址，如示例所示。</li></ul></blockquote><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-19%20164406.png" alt="freewalk函数"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-20%20201144.png" alt="risv.h"></p><p>在exec.c中添加语句</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-20%20204236.png"></p><p>在def.h中定义函数原型</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-20%20204221.png"></p><p>具体的函数实现如下</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-20%20204203.png"></p><p>运行qemu后</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-09%20203948.png"></p><h2 id="A-kernel-page-table-per-process"><a href="#A-kernel-page-table-per-process" class="headerlink" title="A kernel page table per process"></a>A kernel page table per process</h2><p>Xv6 有一个内核页表，每当它在内核中执行时就会使用该页表。 </p><p>内核页表是到物理地址的直接映射，这样内核虚拟地址x就映射到物理地址x。</p><p> Xv6 还为每个进程的用户地址空间提供一个单独的页表，仅包含该进程的用户内存的映射，从虚拟地址零开始。 由于内核页表不包含这些映射，因此用户地址在内核中无效。 </p><p>因此，当内核需要使用系统调用中传递的用户指针（例如传递给 write() 的缓冲区指针）时，内核必须首先将指针转换为物理地址。 本节和下一节的目标是允许内核直接取消引用用户指针。</p><blockquote><p>您的第一项工作是修改内核，以便每个进程在内核中执行时都使用自己的内核页表副本。 修改struct proc为每个进程维护一个内核页表，修改调度器在切换进程时切换内核页表。 对于此步骤，每个进程内核页表应与现有的全局内核页表相同。 如果 usertests 正确运行，您就可以通过这部分实验。</p></blockquote><p>阅读本作业开始时提到的书籍章节和代码； 了解虚拟内存的工作原理后，可以更轻松地正确修改虚拟内存代码。 页表设置中的错误可能会因缺少映射而导致陷阱，可能导致加载和存储影响意外的物理内存页面，并可能导致从不正确的内存页面执行指令。</p><blockquote><p>一些建议：  </p><ul><li>在struct proc中为进程的内核页表添加一个字段。 </li><li>为了为新进程生成一个内核页表，一种合理的方法是实现一个修改过的kvminit版本，该版本生成一个新的页表，而不是修改kernel_pagetable。您将希望从allocproc中调用此函数。 </li><li>确保每个进程的内核页表都有一个映射到该进程的内核堆栈的条目。在未修改的xv6中，所有的内核堆栈都在procinit中设置。您需要将某些或所有这些功能移动到allocproc中。 </li><li>修改scheduler()函数，将进程的内核页表加载到核心的satp寄存器中（参见kvminithart以获取灵感）。不要忘记在调用w_satp()之后调用sfence_vma()。 </li><li>当没有进程运行时，scheduler()函数应使用kernel_pagetable。 </li><li>在freeproc中释放进程的内核页表。 </li><li>您需要一种方法来释放页表，而不会同时释放叶子物理内存页。 vmprint可能对调试页表很有用。</li><li>可以修改xv6函数或添加新函数；您可能需要在至少<code>kernel/vm.c</code>和<code>kernel/proc.c</code>中进行修改。 （但是，请不要修改kernel&#x2F;vmcopyin.c、kernel&#x2F;stats.c、user&#x2F;usertests.c和user&#x2F;stats.c。） </li><li>缺少的页表映射可能会导致内核遇到页错误。它将打印一个包含sepc&#x3D;0x00000000XXXXXXXX的错误。您可以通过在<code>kernel/kernel.asm</code>中搜索XXXXXXXX来找出故障发生的位置。</li></ul></blockquote><p>在<code>kernel/proc.h</code>的<code>struct proc</code>中添加<code>kpagetable</code>字段</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-14%20143438.png"></p><p>仿照<code>kvminit()</code>，在<code>kernel/vm.c</code>中添加<code>proc_kvminit()</code>函数，初始化内核页表</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-14%20150223.png"></p><p>将<code>procinit</code>函数中映射内核栈的代码迁移到<code>allocproc</code>函数（<code>kernel/proc.c</code>）中  在<code>allocproc</code>函数中生成进程的内核页表，然后添加关于该进程对应的内核栈映射。</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-14%20150722.png"></p><p>修改<code>scheduler</code>函数（<code>kernel/proc.c</code>）加载进程的内核页表到核心的satp寄存器。</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-14%20151212.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-14%20151333.png"></p><p><code>kvmpa</code>函数（<code>kernel/vm.c</code>）完成内核虚拟地址到物理地址的转换，因此需要更改其中用到的内核页表。<img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-14%20151656.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-14%20151812.png"></p><p>释放进程的内核页表</p><p><code>freeproc</code>函数（<code>kernel/proc.c</code>）中添加如下代码：</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-14%20152127.png"></p><p><code>proc_free_kernel_pagetable</code>函数（<code>kernel/proc.c</code>）调用<code>uvmunmap</code>函数（<code>kernel/vm.c</code>）解除映射关系，调用<code>uvmfree</code>函数（<code>kernel/vm.c</code>）释放内核页表所占物理内存。</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-14%20152947.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【MIT6.S081】-Lab2</title>
      <link href="/2023/08/23/mit6.s081-lab2/"/>
      <url>/2023/08/23/mit6.s081-lab2/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-system-calls"><a href="#Lab-system-calls" class="headerlink" title="Lab: system calls"></a>Lab: system calls</h1><p>在本实验中，您将向 xv6 添加一些新的系统调用，这将帮助您了解它们的工作原理，并向您展示 xv6 内核的一些内部结构</p><p>您将在后面的实验中添加更多系统调用</p><blockquote><p>准备：</p><p>阅读xv6 book的chapter 2，以及section 4.3，chapter 4的4.4</p><p>阅读以下源文件</p><ul><li>系统调用的用户空间代码（位于 user&#x2F;user.h 和 user&#x2F;usys.pl 中）</li><li>内核空间代码（kernel&#x2F;syscall.h、kernel&#x2F;syscall.c）</li><li>进程相关的代码（kernel&#x2F;proc.h和kernel&#x2F;proc.c）</li></ul></blockquote><p>要开始实验，请切换到系统调用分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> fetch$ <span class="token function">git</span> checkout syscall$ <span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此处出现的问题：</p><p>切换分支时出现下面这种情况</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-23%20164349.png"></p><p>解决方法：</p><p>输入git stash</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-23%20164449.png"></p><p>成功切换分支</p><h2 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h2><blockquote><p>在此作业中，您将添加系统调用跟踪功能，该功能可以在调试后续实验时为您提供帮助。您将创建一个新的跟踪系统调用来控制跟踪。它应该采用一个参数，一个整数“掩码”，其位指定要跟踪哪些系统调用。例如，要跟踪 fork 系统调用，程序调用trace(1 &lt;&lt; SYS_fork)，其中 SYS_fork 是来自 kernel&#x2F;syscall.h 的系统调用号。如果掩码中设置了系统调用的编号，则必须修改 xv6 内核，以便在每个系统调用即将返回时打印一行。该行应包含进程 ID、系统调用名称和返回值；您不需要打印系统调用参数。跟踪系统调用应该启用对调用它的进程及其随后派生的任何子进程的跟踪，但不应影响其他进程。</p></blockquote><p>我们提供了一个跟踪用户级程序，它运行另一个启用了跟踪的程序（请参阅 user&#x2F;trace.c）。完成后，您应该看到如下输出：</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-23%20165631.png"></p><p>在上面的第一个示例中，trace 仅调用 read 系统调用 grep 跟踪。 32 是 1&lt;&lt;SYS_read。在第二个示例中，trace 在跟踪所有系统调用的同时运行 grep； 2147583647 已设置所有 31 个低位。在第三个示例中，未跟踪程序，因此不会打印跟踪输出。在第四个示例中，正在跟踪 usertests 中 forkforkfork 测试的所有后代的 fork 系统调用。如果您的程序的行为如上所示（尽管进程 ID 可能不同），则您的解决方案是正确的。</p><blockquote><p>在Makefile中添加$U_trace</p><p>运行 make qemu ，您将看到编译器无法编译 user&#x2F;trace.c，因为系统调用的用户空间存根尚不存在：将系统调用的原型添加到 user&#x2F;user.h，将存根添加到 user&#x2F;usys.pl，并将系统调用号添加到 kernel&#x2F;syscall.h。Makefile 调用 perl 脚本 user&#x2F;usys.pl，该脚本生成 user&#x2F;usys.S，即实际的系统调用存根，它使用 RISC-V ecall 指令转换到内核。修复编译问题后，运行trace 32 grep hello README;它会失败，因为你还没有在内核中实现系统调用。</p><p>在 kernel&#x2F;sysproc.c 中添加 sys_trace() 函数，该函数通过在 proc 结构中的新变量中记住其参数来实现新的系统调用（请参阅 kernel&#x2F;proc.h）。从用户空间检索系统调用参数的函数位于 kernel&#x2F;syscall.c 中，您可以在 kernel&#x2F;sysproc.c 中查看它们的使用示例。</p><p>修改 fork() （参见 kernel&#x2F;proc.c）以将跟踪掩码从父进程复制到子进程</p><p>修改 kernel&#x2F;syscall.c 中的 syscall() 函数以打印跟踪输出。您将需要添加要索引的系统调用名称数组。</p></blockquote><p>1.在结构体proc(kernel&#x2F;proc.h)中加入一个用于进程追踪的掩码</p><p>此处在proc结构体中添加int mask</p><p>见结构体的最后一行</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-23%20172610.png"></p><p>2.在sysproc.c中实现sys_trace</p><blockquote><p>xv6book中提到，函数argint,argaddr,argstr等可以从trapframe中将用户态传递的参数读取到内核态</p><p>查看.kernel&#x2F;syscall.c文件可知</p><p>argraw从对应的trapframe中返回a0~a7寄存器</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-23%20173240.png"></p></blockquote><p>将用户态传递来的掩码存入当前进程的mask中</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-23%20173806.png"></p><p>3.为了能够追踪当前进程的子进程，进程在调用fork时，子进程应当复制mask的值，所以还要修改.kernel&#x2F;proc.c中fork函数的内容</p><p>如图第278行</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-23%20174503.png"></p><p>4.修改函数syscall(.kernel&#x2F;syscall.c)</p><p>如图第143行</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-23%20175520.png"></p><p>5.在syscall.c中加入系统调用号到名称的映射表</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-23%20181053.png"></p><p><strong>此处若将表加入到syscall.h中则会出现错误，所以务必加入到syscall.c中</strong></p><h4 id="测试输出结果如下："><a href="#测试输出结果如下：" class="headerlink" title="测试输出结果如下："></a>测试输出结果如下：</h4><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-26%20195125.png"></p><h2 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h2><blockquote><p>在此作业中，您将添加一个系统调用 sysinfo，用于收集有关正在运行的系统的信息。系统调用采用一个参数：指向 struct sysinfo 的指针（参见 kernel&#x2F;sysinfo.h）。内核应填写此结构体的字段：freemem 字段应设置为可用内存的字节数，nproc 字段应设置为状态不是 UNUSED 的进程数。我们提供了一个测试程序sysinfotest；如果打印出“sysinfotest: OK”，则说明您通过了此作业。</p></blockquote><blockquote><p>将 $U&#x2F;_sysinfotest 添加到 Makefile 中的 UPROGS</p><p>运行 make qemu，user&#x2F;sysinfotest.c 将无法编译。添加系统调用 sysinfo，遵循与之前作业相同的步骤。要在 user&#x2F;user.h 中声明 sysinfo() 的原型，您需要预先声明 struct sysinfo 的存在：</p><pre class="line-numbers language-none"><code class="language-none">struct sysinfo;   int sysinfo(struct sysinfo *);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>修复编译问题后，运行 sysinfotest；它会失败，因为你还没有在内核中实现系统调用。</p><p>sysinfo需要将struct sysinfo复制回用户空间；有关如何使用 copyout() 执行此操作的示例，请参阅 sys_fstat() (kernel&#x2F;sysfile.c) 和 filestat() (kernel&#x2F;file.c)。</p><p>要收集可用内存量，请向 kernel&#x2F;kalloc.c 添加一个函数</p><p>要收集进程数，请在 kernel&#x2F;proc.c 中添加一个函数</p></blockquote><p>1.在makefile的UPROGS中添加$U&#x2F;_sysinfotest</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20164644.png"></p><p>2.将系统调用原型添加到user&#x2F;user.h头文件中</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20164814.png"></p><p>3.将存根添加到user&#x2F;usys.pl</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20164910.png"></p><p>4.将系统调用编号添加到kernel&#x2F;syscall.h中</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20165030.png"></p><p>5.查看copyout()的用法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20170303.png" alt="kernel/file.c"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20170406.png" alt="kernel/sysfile.c"></p><p>6.添加收集可用内存量的函数</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20171620.png"></p><p>7.添加获取进程数的函数</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20172354.png"></p><p>8.在kernel&#x2F;defs.h中添加函数声明</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20173504.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20173551.png"></p><p>9.实现sys_sysinfo函数</p><p><strong>通过argaddr系统调用，将用户传进来的指向结构体的指针读入dstaddr来记录这个地址</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20175438.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go_review</title>
      <link href="/2023/08/12/go-review/"/>
      <url>/2023/08/12/go-review/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是CodeReview"><a href="#什么是CodeReview" class="headerlink" title="什么是CodeReview"></a>什么是CodeReview</h1><p>Code Review（CR）即代码评审，又名代码走查，是一种通过复查代码来提高代码质量的过程，一般体现在一个团队的开发过程中。CR要求团队成员有意识地、系统地检查彼此的代码，从而验证需求、发现错误，同时指出其中不合规范的“低质量”代码，从而提高整个团队的代码质量。</p><p>一次 CR 可以是一次 Commit，也可以是一次 Merge Request。因此，实践课系统支持团队内部的 MR 评审以及 Commit 评审，供大家学习和交流</p><h1 id="Go-Code-Review-Comments"><a href="#Go-Code-Review-Comments" class="headerlink" title="Go Code Review Comments"></a>Go Code Review Comments</h1><h2 id="Comment-Sentence"><a href="#Comment-Sentence" class="headerlink" title="Comment Sentence"></a>Comment Sentence</h2><p>注释应以所描述事物的名称开头并以句点结束</p><p>这种方法使得它们在提取到 godoc 文档时格式良好</p><h2 id="Contexts"><a href="#Contexts" class="headerlink" title="Contexts"></a>Contexts</h2><p>context是Go语言独有的功能，用于上下文控制，可以在goroutine中进行传递</p><p>context.Context 类型的值携带跨 API 和进程边界的安全凭证、跟踪信息、截止日期和取消信号</p><p>Go 程序沿着从传入 RPC 和 HTTP 请求到传出请求的整个函数调用链显式传递上下文</p><p>大多数使用 Context 的函数都应该接受它作为第一个参数：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">F</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> <span class="token comment">/* other arguments */</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>默认情况是传递一个Context；仅当您有充分的理由说明替代方法是错误时，才直接使用 context.Background() </p><p>不要将 Context 成员添加到结构类型；相反，向需要传递该类型的每个方法添加一个 ctx 参数</p><p>一个例外是其签名必须与标准库或第三方库中的接口匹配的方法</p><p>不要创建自定义 Context 类型或在函数签名中使用 Context 以外的接口</p><p>如果您有要传递的应用程序数据，请将其放入参数、接收器、全局变量中，或者，如果它确实属于那里，则放在 Context 值中</p><p>上下文是不可变的，因此可以将相同的 ctx 传递给共享相同截止日期、取消信号、凭证、父跟踪等的多个调用</p><h2 id="Copying"><a href="#Copying" class="headerlink" title="Copying"></a>Copying</h2><p>为了避免意外的别名，从另一个包复制结构时要小心</p><p>Buffer类型包含一个[]byte切片。如果复制 Buffer，副本中的切片可能会别名化原始数组中的数组，从而导致后续方法调用产生令人惊讶的效果</p><p>通常，如果 T 类型的方法与指针类型 *T 关联，则不要复制该值</p><h2 id="Crypto-Rand"><a href="#Crypto-Rand" class="headerlink" title="Crypto Rand"></a>Crypto Rand</h2><p>不要使用 math&#x2F;rand 包来生成密钥，即使是一次性的密钥。没有种子，生成器是完全可预测的</p><p>用 time.Nanoseconds() 作为种子，只有一些熵</p><p>相反，请使用 crypto&#x2F;rand 的 Reader，如果您需要文本，请打印为十六进制或 base64：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"crypto/rand"</span><span class="token comment">// "encoding/base64"</span><span class="token comment">// "encoding/hex"</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">Key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>buf <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> rand<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>  <span class="token comment">// out of randomness, should never happen</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%x"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token comment">// or hex.EncodeToString(buf)</span><span class="token comment">// or base64.StdEncoding.EncodeToString(buf)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Declaring-Empty-Slices"><a href="#Declaring-Empty-Slices" class="headerlink" title="Declaring Empty Slices"></a>Declaring Empty Slices</h2><p>声明切片时，建议用下面这种形式</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> t <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而不是</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">t <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>前者声明一个 nil 切片值，而后者非 nil 但长度为零</p><p>它们在功能上是等效的，它们的 len 和 cap 都为零，但 nil 切片是首选样式</p><p>请注意，在有限的情况下，首选非 nil 但零长度的切片</p><p>例如在编码 JSON 对象时（nil 切片编码为 null，而 []string{} 编码为 JSON 数组 []）</p><h2 id="Doc-Comments"><a href="#Doc-Comments" class="headerlink" title="Doc Comments"></a>Doc Comments</h2><p>所有top-level导出名称都应具有文档注释，重要的未导出类型或函数声明也应具有文档注释</p><h2 id="Don’t-Panic"><a href="#Don’t-Panic" class="headerlink" title="Don’t Panic"></a>Don’t Panic</h2><p>不要使用panic来进行正常的错误处理</p><p>使用error和多个返回值。</p><h2 id="Error-Strings"><a href="#Error-Strings" class="headerlink" title="Error Strings"></a>Error Strings</h2><p>错误字符串不应大写（除非以专有名词或首字母缩略词开头）或以标点符号结尾，因为它们通常是在其他上下文之后打印的</p><p>也就是说，使用 </p><p>fmt.Errorf(“something bad”) </p><p>而不是 </p><p>fmt.Errorf(“Something bad”)</p><p>以便 log.Printf(“Reading %s: %v”, filename, err) 格式没有虚假的大写字母 mid -信息</p><p>这不适用于日志记录，日志记录是隐式面向行的并且不会组合在其他消息中</p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p>添加新包时，请包含预期用途的示例：可运行的示例，或演示完整调用序列的简单测试。</p><h2 id="Goroutinue-Lifetimes"><a href="#Goroutinue-Lifetimes" class="headerlink" title="Goroutinue Lifetimes"></a>Goroutinue Lifetimes</h2><p>当生成 goroutine 时，请明确它们何时退出或是否退出</p><p>Goroutine 可能会因阻塞通道发送或接收而发生泄漏：即使阻塞的通道无法访问，垃圾收集器也不会终止 Goroutine</p><p>在关闭的通道上发送panic</p><p> “在不需要结果之后”修改仍在使用的输入仍然可能导致数据争用。</p><p>尝试使并发代码足够简单，以便 goroutine 生命周期显而易见。如果这不可行，请记录 goroutine 退出的时间和原因</p><h2 id="Handle-Errors"><a href="#Handle-Errors" class="headerlink" title="Handle Errors"></a>Handle Errors</h2><p>不要使用 _ 变量丢弃错误。如果函数返回错误，请检查它以确保函数成功运行</p><p>处理error，返回error，或者，panic。</p><h2 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h2><p>避免重命名导入，除非是为了避免名称冲突</p><p>如果发生冲突，最好重命名最本地或特定于项目的导入</p><p>导入按组进行组织，组之间有空行</p><p>标准库包始终位于第一组中</p><p>示例</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"hash/adler32"</span><span class="token string">"os"</span><span class="token string">"github.com/foo/bar"</span><span class="token string">"rsc.io/goversion/version"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Import-Blank"><a href="#Import-Blank" class="headerlink" title="Import Blank"></a>Import Blank</h2><p>仅因其副作用而导入的包（使用语法 import _ “pkg”）只能在程序的主包中导入，或者在需要它们的测试中导入</p><h2 id="Import-Dot"><a href="#Import-Dot" class="headerlink" title="Import Dot"></a>Import Dot</h2><p>import . form 在由于循环依赖而无法成为被测试包的一部分的测试中非常有用：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> foo_test<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"bar/testutil"</span> <span class="token comment">// also imports "foo"</span><span class="token punctuation">.</span> <span class="token string">"foo"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下，测试文件不能位于包 foo 中，因为它使用 bar&#x2F;testutil，它导入了 foo。所以我们使用“import”.形式让文件假装是包 foo 的一部分，即使它不是。</p><p>除这一种情况外，不要使用 import 。在你的程序中。它使程序更难阅读，因为不清楚像 Quux 这样的名称是否是当前包或导入包中的顶级标识符</p><h2 id="In-Band-Errors"><a href="#In-Band-Errors" class="headerlink" title="In-Band Errors"></a>In-Band Errors</h2><p>在 C 和类似语言中，函数通常返回 -1 或 null 等值来表示错误或丢失结果：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Lookup返回key的值，如果没有key的映射，则返回""。</span><span class="token keyword">func</span> <span class="token function">Lookup</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span class="token comment">// 未能检查in-band错误值可能会导致错误</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token function">Lookup</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// 返回"parse failure for value"而不是"no value for key"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Go 对多个返回值的支持提供了更好的解决方案</p><p>函数不应要求客户端检查in-band错误值，而应返回一个附加值来指示其其他返回值是否有效。</p><p>当不需要解释时，此返回值可能是错误，也可能是布尔值，这可以防止调用者错误地使用结果：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Lookup返回key的值，如果没有key的映射，则返回ok=false</span><span class="token keyword">func</span> <span class="token function">Lookup</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>value <span class="token builtin">string</span><span class="token punctuation">,</span> ok <span class="token builtin">bool</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>更建议以下这种写法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">value<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token function">Lookup</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span><span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"no value for %q"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token function">Parse</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此规则适用于导出的函数，但对于未导出的函数也很有用</p><p>当像 nil、””、0 和 -1 这样的返回值是函数的有效结果时，也就是说，当调用者不需要以与其他值不同的方式处理它们时，它们就可以了</p><p>某些标准库函数（例如“strings”包中的函数）会返回带内错误值。这极大地简化了字符串操作代码</p><p>一般来说，Go 代码应该返回错误的附加值</p><h2 id="Indent-Error-Flow"><a href="#Indent-Error-Flow" class="headerlink" title="Indent Error Flow"></a>Indent Error Flow</h2><p>尽量使正常的代码路径保持最小的缩进，并缩进错误处理，首先处理它。通过允许快速视觉扫描正常路径，提高了代码的可读性。</p><p>例如，不要写：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// error handling</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">// normal code</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>建议的写法是：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// error handling</span><span class="token keyword">return</span> <span class="token comment">// or continue, etc.</span><span class="token punctuation">&#125;</span><span class="token comment">// normal code</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果if语句有初始化语句，如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> x<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// error handling</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">// use x</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么这可能需要将短变量声明移至其自己的行：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">x<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// error handling</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token comment">// use x</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Initialisms"><a href="#Initialisms" class="headerlink" title="Initialisms"></a>Initialisms</h2><p>名称中的首字母缩写词或首字母缩写词（例如“URL”或“NATO”）具有一致的大小写。例如，“URL”应显示为“URL”或“url”（如“urlPony”或“URLPony”），而不是“Url”</p><p>举个例子：ServeHTTP 不是 ServeHttp。对于具有多个初始化“单词”的标识符，请使用“xmlHTTPRequest”或“XMLHTTPRequest”等</p><p>当“ID”是“identifier”的缩写时，此规则也适用于“ID”（这几乎是所有情况，当它不是“ego”、“superego”中的“id”时），因此写“appID”而不是“appId” ”</p><h1 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h1><p>Go 接口通常属于使用接口类型值的包，而不是实现这些值的包</p><p>实现包应该返回具体的（通常是指针或结构）类型：这样，可以将新方法添加到实现中，而不需要大量重构</p><p>不要在 API 的实现者端定义“用于模拟”的接口；相反，设计 API 以便可以使用实际实现的公共 API 进行测试</p><p>不要在使用之前定义接口：如果没有实际的使用示例，就很难看出接口是否必要，更不用说它应该包含哪些方法了</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> consumer  <span class="token comment">// consumer.go</span><span class="token keyword">type</span> Thinger <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span> <span class="token function">Thing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">Foo</span><span class="token punctuation">(</span>t Thinger<span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span> … <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> consumer <span class="token comment">// consumer_test.go</span><span class="token keyword">type</span> fakeThinger <span class="token keyword">struct</span><span class="token punctuation">&#123;</span> … <span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>t fakeThinger<span class="token punctuation">)</span> <span class="token function">Thing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span> … <span class="token punctuation">&#125;</span>…<span class="token keyword">if</span> <span class="token function">Foo</span><span class="token punctuation">(</span>fakeThinger<span class="token punctuation">&#123;</span>…<span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"x"</span> <span class="token punctuation">&#123;</span> … <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// DO NOT DO IT!!!</span><span class="token keyword">package</span> producer<span class="token keyword">type</span> Thinger <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span> <span class="token function">Thing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#125;</span><span class="token keyword">type</span> defaultThinger <span class="token keyword">struct</span><span class="token punctuation">&#123;</span> … <span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>t defaultThinger<span class="token punctuation">)</span> <span class="token function">Thing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span> … <span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">NewThinger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Thinger <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> defaultThinger<span class="token punctuation">&#123;</span> … <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Line-Length"><a href="#Line-Length" class="headerlink" title="Line Length"></a>Line Length</h2><p>根据语义进行断行，而不是行的长度</p><p>如果一个函数的过长，可以通过改变函数的边界来改变函数的长度</p><h2 id="Named-Result-Parameters"><a href="#Named-Result-Parameters" class="headerlink" title="Named Result Parameters"></a>Named Result Parameters</h2><p>这样命名：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token function">Parent1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>Node <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token function">Parent2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>Node<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>而不是：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token function">Parent1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>node <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token function">Parent2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>node <span class="token operator">*</span>Node<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>另一方面，如果一个函数返回两个或三个相同类型的参数，或者从上下文中不清楚结果的含义，则在某些上下文中添加名称是有必要的</p><p>这样命名：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Location returns f's latitude and longitude.</span><span class="token comment">// Negative values mean south and west, respectively.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>Foo<span class="token punctuation">)</span> <span class="token function">Location</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>lat<span class="token punctuation">,</span> long <span class="token builtin">float64</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>而不是：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>Foo<span class="token punctuation">)</span> <span class="token function">Location</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">float64</span><span class="token punctuation">,</span> <span class="token builtin">float64</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Naked-Returns"><a href="#Naked-Returns" class="headerlink" title="Naked Returns"></a>Naked Returns</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">split</span><span class="token punctuation">(</span>sum <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>x <span class="token operator">=</span> sum <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">/</span> <span class="token number">9</span>y <span class="token operator">=</span> sum <span class="token operator">-</span> x<span class="token keyword">return</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Package-Comments"><a href="#Package-Comments" class="headerlink" title="Package Comments"></a>Package Comments</h2><p>包的注释必须出现在Package字句的旁边，不能有空行</p><h2 id="Package-Names"><a href="#Package-Names" class="headerlink" title="Package Names"></a>Package Names</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go_Testing</title>
      <link href="/2023/08/11/go-testing/"/>
      <url>/2023/08/11/go-testing/</url>
      
        <content type="html"><![CDATA[<h1 id="如何写一个正确的测试函数"><a href="#如何写一个正确的测试函数" class="headerlink" title="如何写一个正确的测试函数"></a>如何写一个正确的测试函数</h1><p>包测试为 Go 包的自动化测试提供支持。它旨在与“go test”命令配合使用，该命令自动执行以下形式的任何函数</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">TestXxx</span><span class="token punctuation">(</span><span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>包含测试函数的测试文件的文件名应以”_test.go”结尾</p><p>该文件将从常规包构件中排除，但在运行”go test”命令时将包含该文件</p><p>测试文件可以与被测文件在同一个包中，也可以在对应的后缀为“_test”的包中。</p><p>如果测试文件位于同一个包中，则它可能引用包内未导出的标识符，如下例所示：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> abs<span class="token keyword">import</span> <span class="token string">"testing"</span><span class="token keyword">func</span> <span class="token function">TestAbs</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    got <span class="token operator">:=</span> <span class="token function">Abs</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> got <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">&#123;</span>        t<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Abs(-1) = %d; want 1"</span><span class="token punctuation">,</span> got<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果文件位于单独的“_test”包中，则必须显式导入正在测试的包，并且只能使用其导出的标识符。这称为“黑盒”测试。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> abs_test<span class="token keyword">import</span><span class="token punctuation">(</span>    <span class="token string">"testing"</span>    <span class="token string">"path_to_pkg/abs"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">TestAbs</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    got <span class="token operator">:=</span> abs<span class="token punctuation">.</span><span class="token function">Abs</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> got <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">&#123;</span>        t<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">"Abs(-1) = %d; want 1"</span><span class="token punctuation">,</span> got<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Benchmarks"><a href="#Benchmarks" class="headerlink" title="Benchmarks"></a>Benchmarks</h1><p> 函数形式</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">BenchmarkXxx</span><span class="token punctuation">(</span><span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在提供 -bench 标志时由“go test”命令执行。Benchmarks按顺序运行。</p><p>一个简单的banchmark函数如下</p><p><em>基准测试函数必须运行目标代码 b.N 次。在基准测试执行期间，b.N 会被调整，直到基准测试函数持续足够长的时间以可靠地计时。</em></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">BenchmarkRandInt</span><span class="token punctuation">(</span>b <span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">&#123;</span>        rand<span class="token punctuation">.</span><span class="token function">Int</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">BenchmarkRandInt<span class="token operator">-</span><span class="token number">8</span>   <span class="token number">68453040</span>        <span class="token number">17.8</span> ns<span class="token operator">/</span>op<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>意味着循环以每个循环 17.8 ns 的速度运行了 68453040 次。</p><p>如果基准测试在运行之前需要一些复杂的设置，则计时器可能会被重置：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">BenchmarkBigLen</span><span class="token punctuation">(</span>b <span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    big <span class="token operator">:=</span> <span class="token function">NewBig</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    b<span class="token punctuation">.</span><span class="token function">ResetTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        big<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果基准测试需要在并行设置中测试性能，则可以使用 RunParallel 辅助函数；此类基准测试旨在与 go test -cpu 标志一起使用：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">BenchmarkTemplateParallel</span><span class="token punctuation">(</span>b <span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    templ <span class="token operator">:=</span> template<span class="token punctuation">.</span><span class="token function">Must</span><span class="token punctuation">(</span>template<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token string">"Hello, &#123;&#123;.&#125;&#125;!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    b<span class="token punctuation">.</span><span class="token function">RunParallel</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>pb <span class="token operator">*</span>testing<span class="token punctuation">.</span>PB<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> buf bytes<span class="token punctuation">.</span>Buffer        <span class="token keyword">for</span> pb<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            buf<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            templ<span class="token punctuation">.</span><span class="token function">Execute</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token string">"World"</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考文档：</p><p><a href="https://pkg.go.dev/testing#hdr-Benchmarks">https://pkg.go.dev/testing#hdr-Benchmarks</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go语言学习路线</title>
      <link href="/2023/08/11/go-yu-yan-xue-xi-lu-xian/"/>
      <url>/2023/08/11/go-yu-yan-xue-xi-lu-xian/</url>
      
        <content type="html"><![CDATA[<p>学习 Go 语言并进行项目开发需要一系列的基础知识和技能。以下是一个逐步学习和掌握 Go 语言的学习路线：</p><p><strong>阶段一：入门基础</strong></p><ol><li><p><strong>安装和设置：</strong> 下载并安装 Go 编程语言。配置你的开发环境，确保 Go 的环境变量设置正确。</p></li><li><p><strong>语法基础：</strong> 学习 Go 语言的基础语法，包括变量、常量、数据类型、运算符、控制结构（条件语句和循环）、函数等。</p></li><li><p><strong>数据类型和集合：</strong> 学习 Go 的内置数据类型，如字符串、数组、切片、映射（map）、结构体等。</p></li><li><p><strong>指针和内存管理：</strong> 了解指针的概念以及如何在 Go 中使用。熟悉垃圾回收机制。</p></li><li><p><strong>错误处理：</strong> 学习如何处理错误以及 Go 中的错误处理机制。</p></li></ol><p><strong>阶段二：深入学习</strong><br>6. <strong>面向对象编程：</strong> 学习 Go 中的面向对象编程概念，如方法、接口、组合等。</p><ol start="7"><li><p><strong>并发与并行：</strong> 了解 Go 的并发编程模型（goroutines 和 channels），以及如何使用它们来实现高效的并发和并行程序。</p></li><li><p><strong>包和模块：</strong> 学习如何组织代码，创建和使用包（packages），以及 Go Modules 的使用。</p></li><li><p><strong>文件操作：</strong> 学习如何读写文件，处理文件路径，以及基本的文件操作。</p></li></ol><p><strong>阶段三：项目实践</strong><br>10. <strong>Web 开发：</strong> 学习使用 Go 进行 Web 开发，包括使用 Web 框架（如 Gin、Echo）创建 Web 应用、处理路由、中间件、HTTP 请求和响应等。</p><ol start="11"><li><p><strong>数据库操作：</strong> 学习如何使用 Go 连接和操作数据库，掌握 SQL 查询、事务管理、数据库ORM（如 GORM）等。</p></li><li><p><strong>RESTful API：</strong> 实现基于 Go 的 RESTful API，了解 API 设计原则、路由管理、认证和授权等。</p></li><li><p><strong>测试和调试：</strong> 学习如何编写单元测试和集成测试，使用 Go 内置的测试框架进行测试，以及调试技巧。</p></li></ol><p><strong>阶段四：高级主题</strong><br>14. <strong>性能优化：</strong> 学习如何优化 Go 代码的性能，包括内存管理、并发调优、性能分析工具的使用等。</p><ol start="15"><li><p><strong>网络编程：</strong> 探索网络编程领域，了解 TCP&#x2F;UDP 编程、Socket 编程等。</p></li><li><p><strong>工具和生态系统：</strong> 探索 Go 生态系统，学习使用一些常用的第三方库，熟悉 Go 的工具链，如 gofmt、golint、go vet 等。</p></li><li><p><strong>部署和发布：</strong> 学习如何将 Go 项目部署到生产环境，包括 Docker 化、CI&#x2F;CD 流程、部署工具等。</p></li></ol><p><strong>阶段五：个人项目</strong><br>18. <strong>个人项目：</strong> 开始一个小型的个人项目，将之前学到的知识应用到实际项目中，不断完善和扩展。</p><ol start="19"><li><strong>持续学习：</strong> 跟随 Go 社区的发展，学习新的特性和最佳实践，不断提升自己的技能。</li></ol><p>在学习过程中，建议你阅读官方文档、书籍、教程，并且实践项目，不断积累经验。还可以参与开源项目、社区讨论，从其他开发者中获取更多的知识和经验。记住，持续的实践和学习是掌握任何编程语言的关键。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go_Map</title>
      <link href="/2023/08/10/go-map/"/>
      <url>/2023/08/10/go-map/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    m <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">//创建一个空map</span>       <span class="token comment">//使用name[key] = val来设置键值对</span>    m<span class="token punctuation">[</span><span class="token string">"k1"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">7</span>    m<span class="token punctuation">[</span><span class="token string">"k2"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">13</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"map:"</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span> <span class="token comment">//输出所有键值对</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"len:"</span><span class="token punctuation">,</span><span class="token function">len</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//返回键值对数量</span>    <span class="token function">delete</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span><span class="token string">"k2"</span><span class="token punctuation">)</span> <span class="token comment">//删除键值对</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go_读文件</title>
      <link href="/2023/08/10/go-du-wen-jian/"/>
      <url>/2023/08/10/go-du-wen-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="错误检查"><a href="#错误检查" class="headerlink" title="错误检查"></a>错误检查</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">check</span><span class="token punctuation">(</span>e <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> e <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">&#123;</span>        <span class="token function">panic</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    dat<span class="token punctuation">,</span>err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">ReadFile</span><span class="token punctuation">(</span><span class="token string">"/tmp/dat"</span><span class="token punctuation">)</span>    <span class="token function">check</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>dat<span class="token punctuation">)</span><span class="token punctuation">)</span>        f<span class="token punctuation">,</span>err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"/tmp/dat"</span><span class="token punctuation">)</span> <span class="token comment">//获取一个os.File值</span>    <span class="token function">check</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>        b1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>    n1<span class="token punctuation">,</span>err <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span>    <span class="token function">check</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"%d bytes: %s\n"</span><span class="token punctuation">,</span>n1<span class="token punctuation">,</span><span class="token function">string</span><span class="token punctuation">(</span>b1<span class="token punctuation">[</span><span class="token punctuation">:</span>n1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Golang_sysnc.Once</title>
      <link href="/2023/08/10/go-sysnc.once/"/>
      <url>/2023/08/10/go-sysnc.once/</url>
      
        <content type="html"><![CDATA[<p>当一个函数在程序启动后不想被多次执行，可以使用sync.Once</p><p>sync.Once结构体仅包括两个属性，done记录执行状态，sync.Mutex和sync.atomic确保done变量的线程安全</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Once <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    done <span class="token builtin">uint32</span>    m Mutex<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>sync.Once仅提供了一个Do()方法，参数为待执行的函数</p><p>首先，<a href="https://so.csdn.net/so/search?q=atomic&spm=1001.2101.3001.7020">atomic</a>读取done字段值是否被改变，然后当如果没有改变时执行doSlow方法。当进入doSlow方法，开始执行锁操作，在并发环境下仅有一个线程被执行，然后基于done字段是否被改变执行待执行函数，如果没有改变则执行f函数。当代码块执行后，done字段被激活。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>o <span class="token operator">*</span>Once<span class="token punctuation">)</span> <span class="token function">Do</span><span class="token punctuation">(</span>f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">LoadUint32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>o<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span>    <span class="token punctuation">&#125;</span>    o<span class="token punctuation">.</span>m<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> o<span class="token punctuation">.</span>m<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> o<span class="token punctuation">.</span>done <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">&#123;</span>        <span class="token keyword">defer</span> atomic<span class="token punctuation">.</span><span class="token function">StoreUint32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>o<span class="token punctuation">.</span>done<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"sync"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">var</span> once sync<span class="token punctuation">.</span>Once<span class="token keyword">var</span> onceBody <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Only Once"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">&#123;</span>        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            once<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span>onceBody<span class="token punctuation">)</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"i="</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录—回溯算法</title>
      <link href="/2023/07/13/suan-fa-shua-ti-ji-lu-hui-su-suan-fa/"/>
      <url>/2023/07/13/suan-fa-shua-ti-ji-lu-hui-su-suan-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="回溯算法理论基础"><a href="#回溯算法理论基础" class="headerlink" title="回溯算法理论基础"></a>回溯算法理论基础</h3><p>回溯法一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定的规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独</li></ul><p><strong>回溯法解决的问题都可以抽象为树形结构</strong></p><p><strong>集合的大小构成的树的宽度，递归的深度构成了树的深度</strong></p><p><strong>回溯法的三个要点</strong>：</p><ul><li><p>回溯函数<em>backtracking</em>模板以及参数</p><p>返回值一般为<em>void</em></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void backtracking(参数)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>回溯函数终止条件</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(终止条件)&#123;    存放结果;    return;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>回溯搜索的遍历过程</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(选择：本层集合中元素（树中节点孩子的数量就是集合的大小）)&#123;    处理节点;    backtracking（路径，选择列表）;    回溯，撤销处理结果&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77.组合"></a>77.组合</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;private:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; path;    void backtracking(int n, int k, int startIndex)    &#123;        if(path.size() &#x3D;&#x3D; k)        &#123;            result.push_back(path);            return;        &#125;        for(int i&#x3D;startIndex;i&lt;&#x3D;n;i++)        &#123;            path.push_back(i);            backtracking(n, k, i+1);            path.pop_back();        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k)    &#123;        backtracking(n, k, 1);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="216-组合总和Ⅲ"><a href="#216-组合总和Ⅲ" class="headerlink" title="216.组合总和Ⅲ"></a>216.组合总和Ⅲ</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solutiom&#123;private:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; path;    void backtracking(int k, int n, int sum, int startIndex)    &#123;        if(path.size() &#x3D;&#x3D; k)        &#123;            if(sum &#x3D;&#x3D; n) result.push_back(path);            return;        &#125;        for(int i&#x3D;startIndex;i&lt;&#x3D;9;i++)        &#123;            sum +&#x3D;i;            path.push_back(i);            baccktracking(k, n, sum, i+1);            sum -&#x3D;i;            path.pop_back();        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n)    &#123;        backtracking(k, n, 0, 1);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;private:    const string map[10]&#x3D;&#123;        &quot;&quot;,&#x2F;&#x2F;0        &quot;&quot;,&#x2F;&#x2F;1        &quot;abc&quot;,&#x2F;&#x2F;2        &quot;def&quot;,&#x2F;&#x2F;3        &quot;ghi&quot;,&#x2F;&#x2F;4        &quot;jkl&quot;,&#x2F;&#x2F;5        &quot;mno&quot;,&#x2F;&#x2F;6        &quot;pqrs&quot;,&#x2F;&#x2F;7        &quot;tuv&quot;,&#x2F;&#x2F;8        &quot;wxyz&quot;&#x2F;&#x2F;9    &#125;;public:    vector&lt;string&gt; result;    string s;    void backtracking(const string&amp; digits, int index)    &#123;        if(index &#x3D;&#x3D; digits.size())        &#123;            result.push_back(s);            return;        &#125;        int digit &#x3D; digits[index] - &#39;0&#39;;        string letters &#x3D; map[digit];        for(int i&#x3D;0;i &lt; letters.size();i++)        &#123;            s.push_back(letters[i]);            backtracking(digits, index+1);            s.pop_back();        &#125;    &#125;    vector&lt;string&gt; letterCombination(string digits)    &#123;        if(digits.size() &#x3D;&#x3D; 0)        &#123;            return result;        &#125;        backtracking(digits,0);        return result;            &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.组合总和</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;private:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; path;    void backtracking(vector&lt;int&gt;&amp; candicates, int target, int sum, int startindex)    &#123;        if(sum &#x3D;&#x3D; target)        &#123;            result.push_back(path);            return;                    &#125;        for(int i&#x3D;startindex;i &lt; candicates.size() &amp;&amp; sum + candicates[i]&lt;&#x3D;target;i++)        &#123;            sum+&#x3D;candicates[i];            path.push_back(candicates[i]);            backtracking(candicates, target, sum, i);            sum-&#x3D;candicates[i];            path.pop_back();        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candicates, int target)    &#123;        result.clear();        path.clear();        sort(candicates.begin(), candicates.end());        backtracking(candicates, target, 0, 0);        return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="40-组合总和Ⅱ"><a href="#40-组合总和Ⅱ" class="headerlink" title="40.组合总和Ⅱ"></a>40.组合总和Ⅱ</h3><p>去重的是同一树层上使用过的，同一树枝上都是同一组合的元素，不用去重</p><p>并且需要对数组进行<strong>排序</strong></p><p><strong>如果candidates[i] &#x3D;&#x3D; candidates[i-1]且used[i-1] &#x3D;&#x3D; false，说明前一个树枝，使用了candidatea[i-1]，也就是说同一树层使用过candidates[i-1]</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;private:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; path;    void backtracking(vector&lt;int&gt;&amp; candidates, int target, int sum, int startIndex, vector&lt;bool&gt;&amp; used) &#123;        if (sum &#x3D;&#x3D; target) &#123;            result.push_back(path);            return;        &#125;        for (int i &#x3D; startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;&#x3D; target; i++) &#123;            &#x2F;&#x2F; used[i - 1] &#x3D;&#x3D; true，说明同一树枝candidates[i - 1]使用过            &#x2F;&#x2F; used[i - 1] &#x3D;&#x3D; false，说明同一树层candidates[i - 1]使用过            &#x2F;&#x2F; 要对同一树层使用过的元素进行跳过            if (i &gt; 0 &amp;&amp; candidates[i] &#x3D;&#x3D; candidates[i - 1] &amp;&amp; used[i - 1] &#x3D;&#x3D; false) &#123;                continue;            &#125;            sum +&#x3D; candidates[i];            path.push_back(candidates[i]);            used[i] &#x3D; true;            backtracking(candidates, target, sum, i + 1, used); &#x2F;&#x2F; 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次            used[i] &#x3D; false;            sum -&#x3D; candidates[i];            path.pop_back();        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;        vector&lt;bool&gt; used(candidates.size(), false);        path.clear();        result.clear();        &#x2F;&#x2F; 首先把给candidates排序，让其相同的元素都挨在一起。        sort(candidates.begin(), candidates.end());        backtracking(candidates, target, 0, 0, used);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;private:    vector&lt;vector&lt;string&gt;&gt; result;    vector&lt;string&gt; path; &#x2F;&#x2F; 放已经回文的子串    void backtracking (const string&amp; s, int startIndex) &#123;        &#x2F;&#x2F; 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了        if (startIndex &gt;&#x3D; s.size()) &#123;            result.push_back(path);            return;        &#125;        for (int i &#x3D; startIndex; i &lt; s.size(); i++) &#123;            if (isPalindrome(s, startIndex, i)) &#123;   &#x2F;&#x2F; 是回文子串                &#x2F;&#x2F; 获取[startIndex,i]在s中的子串                string str &#x3D; s.substr(startIndex, i - startIndex + 1);                path.push_back(str);            &#125; else &#123;                                &#x2F;&#x2F; 不是回文，跳过                continue;            &#125;            backtracking(s, i + 1); &#x2F;&#x2F; 寻找i+1为起始位置的子串            path.pop_back(); &#x2F;&#x2F; 回溯过程，弹出本次已经添加的子串        &#125;    &#125;    bool isPalindrome(const string&amp; s, int start, int end) &#123;        for (int i &#x3D; start, j &#x3D; end; i &lt; j; i++, j--) &#123;            if (s[i] !&#x3D; s[j]) &#123;                return false;            &#125;        &#125;        return true;    &#125;public:    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;        result.clear();        path.clear();        backtracking(s, 0);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git使用</title>
      <link href="/2023/07/06/git-shi-yong/"/>
      <url>/2023/07/06/git-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>Git 是一个开源的分布式的版本控制系统</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>克隆Git资源位工作目录</p><p>在克隆的资源上添加或修改文件</p><p>更新资源</p><p>在提交前查看修改状态</p><p>提交修改</p><p>修改完成后，可以撤回提交并再次修改提交</p><h3 id="Git工作区、暂存区、版本库"><a href="#Git工作区、暂存区、版本库" class="headerlink" title="Git工作区、暂存区、版本库"></a>Git工作区、暂存区、版本库</h3><p><strong>工作区</strong>：电脑里能看到的目录</p><p><strong>暂存区</strong>：<strong>stage 或 index</strong>，一般放在 <strong>.git</strong> 目录下的<strong>index</strong>文件（**.git&#x2F;index**）中，也叫做索引</p><p><strong>版本库</strong>：工作区有一个隐藏目录，**.git** ，实际上是Git的本地版本仓库</p><h3 id="Git基本命令"><a href="#Git基本命令" class="headerlink" title="Git基本命令"></a>Git基本命令</h3><p><strong>创建版本库</strong></p><p>创建一个gitspace空目录（可选），用作以后创建本地版本仓库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mkdir</span> <span class="token builtin class-name">test</span> <span class="token comment">#创建目录</span>$ <span class="token builtin class-name">cd</span> <span class="token builtin class-name">test</span> <span class="token comment">#进入目录</span>$ <span class="token builtin class-name">pwd</span>/d/gitspace/test$ <span class="token function">git</span> init <span class="token comment">#初始化当前仓库</span>Initialized empty Git respository <span class="token keyword">in</span> D:/gitspace/test/.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>.git</em> 目录是Git用来跟踪管理版本仓库的</p><p>可使用<em>ls -ah</em>查看隐藏目录</p><p><strong>新建文件</strong></p><p>-<em>add</em>：将文件添加到缓存区</p><p>-<em>commit</em>：提交到本地仓库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">touch</span> test.c <span class="token comment">#创建新文件</span>$ <span class="token function">git</span> <span class="token function">add</span> test.c <span class="token comment">#将文件添加到本地仓库的提交缓存</span><span class="token comment">#简单描述我们做了什么 使用-m命令简写描述信息</span>$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"add new file <span class="token entity" title="\&quot;">\"</span>test.c<span class="token entity" title="\&quot;">\"</span>"</span>$ <span class="token function">git</span> status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>版本回退</strong></p><p><em>git log</em>命令显示从最近到最远的提交日志</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token comment">#查看日志记录</span>$ <span class="token function">git</span> log <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> reset <span class="token parameter variable">--hard</span> HEAD^ <span class="token comment">#回到第一个版本</span>$ <span class="token function">git</span> reset <span class="token parameter variable">--hard</span> 7fs9vj47 <span class="token comment">#版本号写出前8位即可</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><em>Git</em>内部有个指向当前版本的<em>HEAD</em>指针，当回退版本时，<em>Git</em>仅仅是把<em>HEAD</em>指向当前的版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token comment">#查看日志</span>$ <span class="token function">git</span> reflog <span class="token comment">#展示每次的命令，commit id</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Git的管理和修改</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">diff</span> HEAD -- 文件名 <span class="token comment">#对比工作区和本地仓库中文件的区别</span>$ <span class="token function">git</span> restore 文件名 <span class="token comment">#撤销文件在工作区做的修改</span>$ <span class="token function">git</span> checkout -- 文件名 <span class="token comment">#不能撤销已经添加到暂存区的内容</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> restore <span class="token parameter variable">--staged</span> 文件名 <span class="token comment">#从暂存区撤回，退回到工作状态</span>$ <span class="token function">git</span> reset HEAD 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Git删除文件</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">rm</span> 文件名 <span class="token comment">#仅删除工作区的文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">rm</span> 文件名 <span class="token comment">#同时删除工作区和暂存区的文件</span>$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"commit del 文件名"</span> <span class="token comment">#将删除修改提交到版本库中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Selenium-Webdrier框架的使用</title>
      <link href="/2023/07/04/selenium-webdrier-kuang-jia-de-shi-yong/"/>
      <url>/2023/07/04/selenium-webdrier-kuang-jia-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Webdriver"><a href="#Webdriver" class="headerlink" title="Webdriver"></a>Webdriver</h1><p>面向对象的API</p><p>有效的驱动浏览器</p><h2 id="操作浏览器的基本方法"><a href="#操作浏览器的基本方法" class="headerlink" title="操作浏览器的基本方法"></a>操作浏览器的基本方法</h2><h3 id="打开网页"><a href="#打开网页" class="headerlink" title="打开网页"></a>打开网页</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#导入Webdriver模块</span><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token comment">#打开浏览器</span>driver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#谷歌</span><span class="token comment">#driver = webdriver.Firefox() 火狐</span><span class="token comment">#driver = webdriver.Ie() IE</span><span class="token comment">#打开网站</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"http://www.baidu.com"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置休眠"><a href="#设置休眠" class="headerlink" title="设置休眠"></a>设置休眠</h3><p>由于打开网址后，页面加载需要几秒钟，定时等待几秒钟等到页面加载完毕后再进行下一步操作</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token keyword">import</span> timedriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chorme<span class="token punctuation">(</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"http://ww.baidu.com"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="页面刷新"><a href="#页面刷新" class="headerlink" title="页面刷新"></a>页面刷新</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">driver<span class="token punctuation">.</span>refresh<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="页面切换"><a href="#页面切换" class="headerlink" title="页面切换"></a>页面切换</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#返回上一页</span>driver<span class="token punctuation">.</span>back<span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">#切换到下一页</span>driver<span class="token punctuation">.</span>forward<span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置窗口大小"><a href="#设置窗口大小" class="headerlink" title="设置窗口大小"></a>设置窗口大小</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#设置窗口大小</span>driver<span class="token punctuation">.</span>set_window_size<span class="token punctuation">(</span><span class="token number">1920</span><span class="token punctuation">,</span> <span class="token number">1080</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">#将浏览器窗口最大化</span>driver<span class="token punctuation">.</span>maximxze_window<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h3><p>截屏后可以设置保存路径+文件名+后缀</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">driver<span class="token punctuation">.</span>get_screenshot_as_file<span class="token punctuation">(</span><span class="token string">"D//screenshot.jpg"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>退出有两种方式</p><p>close：关闭当前窗口</p><p>quit：结束进程，关闭所有窗口</p><p>结束测试用quit，可以回收c盘的临时文件</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">driver<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="请求浏览器信息"><a href="#请求浏览器信息" class="headerlink" title="请求浏览器信息"></a>请求浏览器信息</h3><p>包括窗口句柄、浏览器尺寸位置、cookie</p><h3 id="建立等待策略"><a href="#建立等待策略" class="headerlink" title="建立等待策略"></a>建立等待策略</h3><p>在尝试定位元素之前，确保该元素位于页面上，并且在尝试与该元素交互之前，该元素处于可交互状态</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">driver<span class="token punctuation">.</span>implicitly_wait<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="发送命令、查找元素"><a href="#发送命令、查找元素" class="headerlink" title="发送命令、查找元素"></a>发送命令、查找元素</h3><p>在Selenium会话中，要先找到元素才能与其交互</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">text_box <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>by<span class="token operator">=</span>By<span class="token punctuation">.</span>NAME<span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">"my-text"</span><span class="token punctuation">)</span>submit_button <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>by<span class="token operator">=</span>By<span class="token punctuation">.</span>CSS_SELECTOR<span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">"button"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">text_box<span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span><span class="token string">"Selenuium"</span><span class="token punctuation">)</span>submit_button<span class="token punctuation">.</span>click<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="获取元素信息"><a href="#获取元素信息" class="headerlink" title="获取元素信息"></a>获取元素信息</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">value <span class="token operator">=</span> message<span class="token punctuation">.</span>text<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>下面是一个简单脚本</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>common<span class="token punctuation">.</span>by <span class="token keyword">import</span> Bydriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"http://ww.baidu.com"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token comment">#查找元素</span>search_box <span class="token operator">=</span> chrome<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>NAME<span class="token punctuation">,</span> <span class="token string">'q'</span><span class="token punctuation">)</span><span class="token comment">#模拟按键输入</span>search_box<span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span><span class="token string">'ChromeDriver'</span><span class="token punctuation">)</span><span class="token comment">#搜索框模拟回车</span>search_box<span class="token punctuation">.</span>submit<span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【MIT6.S81】-Lab1</title>
      <link href="/2023/06/30/mit6.s81-lab1/"/>
      <url>/2023/06/30/mit6.s81-lab1/</url>
      
        <content type="html"><![CDATA[<p>课程链接</p><p><strong>MIT6.S081</strong>：<a href="https://pdos.csail.mit.edu/6.828/2020/overview.html">https://pdos.csail.mit.edu/6.828/2020/overview.html</a></p><p>在做到lab3时卡壳，准备重新看一下前面的内容再继续实验，感觉对前面的内容理解的还是不透彻，所以在文档中加入一些6.S081的相关内容</p><p>本文档部分内容参考网上的文章和视频</p><p>Chapter 1部分的总结如下，参考xv6 book英文原文，如有错误，敬请指正。</p><h1 id="Chapter-1-Operating-system-interfaces"><a href="#Chapter-1-Operating-system-interfaces" class="headerlink" title="Chapter 1: Operating system interfaces"></a>Chapter 1: Operating system interfaces</h1><h2 id="1-1-process-and-memory"><a href="#1-1-process-and-memory" class="headerlink" title="1.1 process and memory"></a>1.1 process and memory</h2><blockquote><p>**int fork(): **创建一个新的进程，在父进程中返回子进程的PID， 在子进程中返回0</p><p>**int exit(int status): **终止现有的进程，释放资源，将结束进程的状态报告给wait()</p><p>**int wait(int *status): **返回刚刚结束的子进程的PID，将子进程的退出状态复制到传入wait()的地址，若调用wait的进程无子进程，则返回-1，若无子进程终止，则继续等待</p><p>**int exec(char *file, char *argv[]): **加载文件并传参运行</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"echo"</span><span class="token punctuation">;</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"/bin/echo"</span><span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"exec error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>xv6<strong>shell</strong>利用以上调用来代替用户运行程序</p><p>xv6<strong>shell</strong>的代码如下</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161324.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161423.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161454.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161526.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161611.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161651.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161727.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161755.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161831.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161903.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161929.png"></p><blockquote><p>当shell开始运行时，main函数首先通过getcmd来获取用户输入，接着调用fork，创建一个子进程，在子进程中调用runcmd函数，runcmd函数再通过exec来运行用户输入的命令，在exec中会调用exit来退出子进程返回到父进程，对应的是父进程的wait函数。</p></blockquote><h2 id="1-2-I-x2F-O-and-file-descriptors"><a href="#1-2-I-x2F-O-and-file-descriptors" class="headerlink" title="1.2 I&#x2F;O and file descriptors"></a>1.2 I&#x2F;O and file descriptors</h2><blockquote><p>文件描述符是一个小整数，表示进程可以读取或写入的内核管理对象。</p></blockquote><p>文件描述符将不同的文件抽象成字节流。</p><p>xv6 内核使用文件描述符作为每个进程表的索引，以便每个进程都有一个从零开始的文件描述符的私有空间。通常情况下，0代表读，1代表写，2代表错误。</p><p>&#x3D;&#x3D;新分配的文件描述符始终是当前进程中编号最小的未使用描述符。&#x3D;&#x3D;</p><p>下图中，子进程会关闭0，再将0用于input.txt，cat在使用0来执行</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-20%20101621.png"></p><blockquote><p>为什么fork和exec要分别定义为不同的系统调用？</p><p>将fork和exec分开定义可以再不干扰主shell I&#x2F;O设置的情况下重定向子进程的I&#x2F;O</p></blockquote><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-20%20103047.png"></p><p>&#x3D;&#x3D;两个文件描述符共享offset的情况：这两个文件描述符是必须从fork或者dup调用中的原始文件描述符中产生的&#x3D;&#x3D;</p><h2 id="1-3-pipe"><a href="#1-3-pipe" class="headerlink" title="1.3 pipe"></a>1.3 pipe</h2><blockquote><p>A pipe is a small kernel buffer exposed to processes as a pair of file descriptors, one for reading and one for writing.</p><p>管道是一个小的内核缓冲区，作为一对文件描述符暴露给进程，一个用于读取，一个用于写入。</p></blockquote><p><strong>wc中对pipe的简单应用：</strong></p><p>如果pipe的读端无可读数据，pipe等待数据写入或等待写入端的所有文件描述符关闭，在后一种情况下，read 将返回 0，就像已到达数据文件末尾一样，所以及时关闭pipe的写端是很有必要的</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-20%20105442.png"></p><p>xv6<strong>shell</strong>实现管道如下图代码所示(user&#x2F;sh.c:100)，例如grep fork sh.c | wc -1</p><p>和wc中类似，子进程创建pipe连接”|“的左右两端</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20161454.png"></p><h2 id="1-4-file-system"><a href="#1-4-file-system" class="headerlink" title="1.4 file system"></a>1.4 file system</h2><p>这部分内容比较简单，xv6 book中已详细说明，此处不再赘述。</p><h1 id="Lab-Xv6-and-Unix-utilities"><a href="#Lab-Xv6-and-Unix-utilities" class="headerlink" title="Lab: Xv6 and Unix utilities"></a>Lab: Xv6 and Unix utilities</h1><h2 id="Lab-guidance"><a href="#Lab-guidance" class="headerlink" title="Lab guidance"></a>Lab guidance</h2><p>调试技巧</p><p>以下是调试解决方案的一些提示：</p><ul><li>确保您了解 C 和指针。 Kernighan 和 Ritchie 所著的《C 编程语言（第二版）》一书对 C 进行了简洁的描述。<a href="https://pdos.csail.mit.edu/6.828/2019/lec/pointers.c">这里</a>有一些有用的指针练习。 除非您已经精通 C 语言，否则请勿跳过或浏览上面的指针练习。 如果你不真正理解 C 中的指针，你将在实验室中遭受难以言喻的痛苦和痛苦，然后最终以艰难的方式理解它们。 相信我们; 你不想知道什么是“艰难的道路”。</li><li>如果您的练习部分有效，请通过提交代码来检查进度。 如果您稍后破坏了某些内容，则可以回滚到检查点并以较小的步骤前进。 要了解有关 Git 的更多信息，请查看 <a href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html">Git 用户手册</a>，或者您可能会发现此<a href="">面向 CS 的 Git 概述</a><a href="http://eagain.net/articles/git-for-computer-scientists/%E5%BE%88%E6%9C%89%E7%94%A8%E3%80%82">http://eagain.net/articles/git-for-computer-scientists/很有用。</a></li><li>如果测试失败，请确保您了解代码未通过测试的原因。 插入打印语句，直到您了解发生了什么。</li><li>您可能会发现您的 print 语句可能会产生很多您想要搜索的输出； 一种方法是在<em>script</em>内运行 <em>make qemu</em> （在您的计算机上运行 <em>man script</em>），它将所有控制台输出记录到一个文件中，然后您可以搜索该文件。 不要忘记退出<em>script</em>。</li><li>在许多情况下，打印语句就足够了，但有时能够单步执行某些汇编代码或检查堆栈上的变量会很有帮助。 要将 <em>gdb</em> 与 <em>xv6</em> 一起使用，请在一个窗口中运行  <em>make qemu-gdb</em>，在另一个窗口中运行 <em>gdb</em>（或 <em>riscv64-linux-gnu-gdb</em>），设置一个断点，然后是“c”（<em>continue</em>）和 <em>xv6</em> 将运行直到到达断点。 （有关有用的 <em>GDB</em> 提示，请参阅使用 <a href="https://pdos.csail.mit.edu/6.828/2019/lec/gdb_slides.pdf">GNU 调试器</a>。</li><li>如果您想查看编译器为内核生成的程序集是什么，或者想了解特定内核地址处的指令是什么，请查看文件 <em>kernel.asm</em>，该文件是 Makefile 在编译内核时生成的。 （Makefile 还为所有用户程序生成 <em>.asm</em>。）</li><li>如果内核<em>panics</em>，它将打印一条错误消息，列出崩溃时程序计数器的值； 您可以搜索 <em>kernel.asm</em> 以找出程序计数器崩溃时所在的函数，或者您可以运行 <em>addr2line -e kernel&#x2F;kernel pc-value</em> （运行 <em>man addr2line</em> 了解详细信息）。 如果你想获得回溯，请使用 <em>gdb8 重新启动：在一个窗口中运行“</em>make qemu-gdb<em>”，在另一个窗口中运行 <em>gdb</em>（或 <em>riscv64-linux-gnu-gdb</em>），在</em>panic<em>中设置断点（“</em>b panic<em>”），然后 by 后跟“c”（</em>continue<em>）。 当内核到达断点时，输入“</em>bt*”以获取回溯。</li><li>如果您的内核挂起（例如，由于死锁）或无法进一步执行（例如，由于执行内核指令时出现页面错误），您可以使用 <em>gdb</em> 找出挂起的位置。 在一个窗口中运行<em>make qemu-gdb</em>，在另一个窗口中运行 <em>gdb</em>   ( <em>riscv64-linux-gnu-gdb</em>)，然后运行“c”（<em>continue</em>）。 当内核出现挂起时，在 <em>qemu-gdb</em> 窗口中按 <em>Ctrl-C</em> 并输入“bt”以获取回溯。</li><li><em>qemu</em> 有一个“监视器”，可以让您查询模拟机器的状态。 您可以通过输入<em>control-a c</em>（“c”代表控制台）来获取它。 一个特别有用的监视命令是 <em>info mem</em>，用于打印页表。 您可能需要使用 cpu 命令来选择要查看哪个核心信息 <em>mem</em>，或者您可以使用 <em>make CPUS&#x3D;1 qemu</em> 来启动 *qemu8，以导致只有一个核心。</li></ul><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>VMware：<a href="https://www.vmware.com/cn.html">https://www.vmware.com/cn.html</a></p><p>Ubuntu20.04：<a href="https://ubuntu.com/download/desktop/thank-you?version=20.04.2.0&architecture=amd64">https://ubuntu.com/download/desktop/thank-you?version=20.04.2.0&amp;architecture=amd64</a></p><p><strong>尽量使用20.04版本进行环境的搭建，不然容易出现错误</strong></p><p>安装后还需要进行更换软件源等初步准备工作，这里不在赘述</p><p><strong>安装xv6</strong></p><p>打开终端，输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">git</span> build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu libglib2.0-dev libpixman-1-dev gcc-riscv64-unknown-elf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>下载xv6源码</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone git://g.csail.mit.edu/xv6-labs-2020<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> xv6-riscv<span class="token function">make</span> qemu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>gdb调试</strong></p><p>打开一个终端窗口，输入 <em>make-gdb</em></p><p>再打开一个终端窗口，输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"add-auto-load-safe-path YOUR_PATH/xv6-riscv/.gdbinit "</span> <span class="token operator">>></span> ~/.gdbinit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入<em>gdb-multiarch</em></p><p>接下来就可以进行调试了</p><p><strong>退出qemu</strong>：按下ctrl - a 放开后按x（之前一直搞错，要放开ctrl - a以后在按x）</p><h2 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h2><p>为 xv6 实现 UNIX 程序 sleep； sleep应该暂停用户指定的ticks。 时钟周期是 xv6 内核定义的时间概念，即定时器芯片两次中断之间的时间。 您的解决方案应该位于文件user&#x2F;sleep.c中</p><p>原文如下</p><blockquote><p>Implement the UNIX program <code>sleep</code> for xv6; your <code>sleep</code> should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file <code>user/sleep.c</code>.</p></blockquote><p>提示：</p><ul><li>在开始编码之前，请阅读 <a href="https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf">xv6</a> 书的第一章。</li><li>查看 user&#x2F; 中的一些其他程序（例如 user&#x2F;echo.c、user&#x2F;grep.c 和 user&#x2F;rm.c），了解如何获取传递给程序的命令行参数。</li><li>如果用户忘记传递参数，sleep 应该打印一条错误消息。</li><li>命令行参数作为字符串传递；您可以使用 atoi 将其转换为整数（请参阅 user&#x2F;ulib.c）。</li><li>使用系统调用sleep。</li><li>请参阅 kernel&#x2F;sysproc.c 了解实现 sleep 系统调用的 xv6 内核代码（查找 sys_sleep），参见 user&#x2F;user.h 了解可从用户程序调用 sleep 的 C 定义，以及 user&#x2F;usys.S 了解汇编代码从用户代码跳转到内核的sleep。</li><li>确保 main 调用 exit() 以退出程序。</li><li>将你的睡眠程序添加到Makefile中的UPROGS中；完成此操作后，make qemu 将编译您的程序，您将能够从 xv6 shell 运行它。</li><li>查看 Kernighan 和 Ritchie 的书《C 编程语言（第二版）》（K&amp;R）来了解 C。</li></ul><p>原文如下</p><blockquote><p>Some hints:</p><ul><li>Before you start coding, read Chapter 1 of the <a href="https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf">xv6 book</a>.</li><li>Look at some of the other programs in <code>user/</code> (e.g., <code>user/echo.c</code>, <code>user/grep.c</code>, and <code>user/rm.c</code>) to see how you can obtain the command-line arguments passed to a program.</li><li>If the user forgets to pass an argument, sleep should print an error message.</li><li>The command-line argument is passed as a string; you can convert it to an integer using <code>atoi</code> (see user&#x2F;ulib.c).</li><li>Use the system call <code>sleep</code>.</li><li>See <code>kernel/sysproc.c</code> for the xv6 kernel code that implements the <code>sleep</code> system call (look for <code>sys_sleep</code>), <code>user/user.h</code> for the C definition of <code>sleep</code> callable from a user program, and <code>user/usys.S</code> for the assembler code that jumps from user code into the kernel for <code>sleep</code>.</li><li>Make sure <code>main</code> calls <code>exit()</code> in order to exit your program.</li><li>Add your <code>sleep</code> program to <code>UPROGS</code> in Makefile; once you’ve done that, <code>make qemu</code> will compile your program and you’ll be able to run it from the xv6 shell.</li><li>Look at Kernighan and Ritchie’s book <em>The C programming language (second edition)</em> (K&amp;R) to learn about C.</li></ul></blockquote><p>传入main函数的argc表示参数的个数，argv[]表示传入的参数，argv[0]通常为，命令名</p><p>完整代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/stat.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//传入的参数个数不为2，即不是sleep 3格式的</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"Usage: sleep..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//exit传入参数1表示错误结束</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//exit传入参数0表示成功结束</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外，还要在Makefile的UPROGS中加入sleep函数</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$U</span>/_sleep<span class="token punctuation">\</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Pingpong"><a href="#Pingpong" class="headerlink" title="Pingpong"></a>Pingpong</h2><p>编写一个程序，使用 UNIX 系统调用通过一对管道（每个方向一个）在两个进程之间“pingpong”一个字节。 父进程应向子进程发送一个字节； 子进程应打印“<pid>：已收到 ping”，其中 <pid> 是其进程 ID，将管道上的字节写入到父进程，然后退出； 父进程应该从子进程读取字节，打印“<pid>：收到 pong”，然后退出。 您的解决方案应该位于文件 user&#x2F;pingpong.c 中。</p><p>原文如下</p><blockquote><p>Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “<pid>: received ping”, where <pid> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “<pid>: received pong”, and exit. Your solution should be in the file <code>user/pingpong.c</code>.</p></blockquote><p>提示：</p><ul><li>使用pipe创建一个管道</li><li>使用fork创建一个子进程</li><li>使用read来读管道，write来写管道</li><li>使用 getpid 查找调用进程的进程 ID</li><li>将程序添加到 Makefile 中的 UPROGS 中</li><li>xv6 上的用户程序具有一组有限的可用库函数。您可以在 user&#x2F;user.h 中看到该列表；源代码（系统调用除外）位于 user&#x2F;ulib.c、user&#x2F;printf.c 和 user&#x2F;umalloc.c 中</li></ul><p>原文如下</p><blockquote><p>Some hints:</p><ul><li>Use <code>pipe</code> to create a pipe.</li><li>Use <code>fork</code> to create a child.</li><li>Use <code>read</code> to read from the pipe, and <code>write</code> to write to the pipe.</li><li>Use <code>getpid</code> to find the process ID of the calling process.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li><li>User programs on xv6 have a limited set of library functions available to them. You can see the list in <code>user/user.h</code>; the source (other than for system calls) is in <code>user/ulib.c</code>, <code>user/printf.c</code>, and <code>user/umalloc.c</code>.</li></ul></blockquote><p>完整代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/stat.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token keyword">int</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> p1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> p2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">pipe</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//父进程到子进程</span><span class="token function">pipe</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//子进程到父进程</span><span class="token keyword">if</span><span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"Usage: pingpong"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//子进程</span><span class="token punctuation">&#123;</span><span class="token function">close</span><span class="token punctuation">(</span>p1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//关闭管道的写端(父进程到子进程)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>p1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//子进程开始读</span><span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"%d:received ping"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"%d received failed!"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>        <span class="token function">close</span><span class="token punctuation">(</span>p2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//关闭管道的读端(子进程到父进程)</span><span class="token function">write</span><span class="token punctuation">(</span>p2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"pong\n"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//子进程开始写</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token comment">//父进程</span><span class="token function">close</span><span class="token punctuation">(</span>p1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//关闭管道的读端(父进程到子进程)</span><span class="token function">write</span><span class="token punctuation">(</span>p1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"ping\n"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//父进程开始写</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>p2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//关闭管道的写端(子进程到父进程)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>p2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//父进程开始读</span><span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"%d:received ping"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"%d received failed!"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Primes"><a href="#Primes" class="headerlink" title="Primes"></a>Primes</h2><p>使用管道编写素数筛的并发版本。这个想法源自 Unix 管道的发明者 Doug McIlroy。<a href="http://swtch.com/~rsc/thread/">本页</a>中间的图片和周围的文字解释了如何操作。您的解决方案应该位于文件 user&#x2F;primes.c 中。</p><p>原文如下</p><blockquote><p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a href="http://swtch.com/~rsc/thread/">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</p></blockquote><p>您的目标是使用pipe和fork来设置管道。第一个进程将数字 2 到 35 输入管道。对于每个质数，您将安排创建一个进程，通过管道从其左邻居读取数据，并通过另一管道向其右邻居写入数据。由于xv6的文件描述符和进程数量有限，第一个进程可以停在35</p><p>原文如下</p><blockquote><p>Your goal is to use <code>pipe</code> and <code>fork</code> to set up the pipeline. The first process feeds the numbers 2 through 35 into the pipeline. For each prime number, you will arrange to create one process that reads from its left neighbor over a pipe and writes to its right neighbor over another pipe. Since xv6 has limited number of file descriptors and processes, the first process can stop at 35.</p></blockquote><p>提示：</p><ul><li>请小心关闭进程不需要的文件描述符，否则您的程序将在第一个进程达到 35 之前耗尽资源来运行 xv6。</li><li>一旦第一个进程达到 35，它应该等待整个管道终止，包括所有子进程、孙进程等。 因此，主 primes 进程仅应在所有输出打印完毕以及所有其他 primes 进程退出后退出。</li><li>提示：当管道的写入端关闭时，read返回零。</li><li>最简单的方法是直接将 32 位（4 字节）整数写入管道，而不是使用格式化的 ASCII I&#x2F;O</li><li>您应该仅在需要时在管道中创建进程</li><li>将程序添加到 Makefile 中的 UPROGS 中。</li></ul><p>原文如下</p><blockquote><p>Some hints:</p><ul><li>Be careful to close file descriptors that a process doesn’t need, because otherwise your program will run xv6 out of resources before the first process reaches 35.</li><li>Once the first process reaches 35, it should wait until the entire pipeline terminates, including all children, grandchildren, &amp;c. Thus the main primes process should only exit after all the output has been printed, and after all the other primes processes have exited.</li><li>Hint: <code>read</code> returns zero when the write-side of a pipe is closed.</li><li>It’s simplest to directly write 32-bit (4-byte) <code>int</code>s to the pipes, rather than using formatted ASCII I&#x2F;O.</li><li>You should create the processes in the pipeline only as they are needed.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li></ul></blockquote><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-12%20155809.png"></p><p>素数筛：</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-29%20181002.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//递归创建进程的函数</span>    <span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> prime<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>prime<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//从该进程的父进程中读入第一个数</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"prime %d\n"</span><span class="token punctuation">,</span> prime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出读到的这个数</span>        <span class="token keyword">int</span> p2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">pipe</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建该进程与其子进程的管道</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">close</span><span class="token punctuation">(</span>p2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> i<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//从该进程的父进程中读入剩下的数</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> prime <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//将第一个数后的值，除了第一个数的倍数，通过pipe全部传给下一个子进程</span>                    <span class="token function">write</span><span class="token punctuation">(</span>p2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">close</span><span class="token punctuation">(</span>p2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">process</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//子进程继续创建子进程</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">pipe</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//最初的父进程</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"prime 2\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//由于是第一个进程，也就是最早的父进程，所以先输出第一个数2</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">35</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//将2后的值，除了2的倍数，通过pipe全部传给下一个子进程</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">write</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//在pipe的写端写入4字节(int)的数据</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">process</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//如果是子进程则调用函数</span>    <span class="token punctuation">&#125;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>编写一个简单版本的 UNIX 查找程序：查找目录树中具有特定名称的所有文件。您的解决方案应该位于文件 user&#x2F;find.c 中。</p><blockquote><p>Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file <code>user/find.c</code>.</p></blockquote><p>提示：</p><ul><li>查看 user&#x2F;ls.c 以了解如何读取目录</li><li>使用递归允许 find 深入到子目录</li><li>不要递归成“.” 和 ”..”</li><li>文件系统的更改在 qemu 运行期间持续存在； 要获得干净的文件系统，请运行 make clean，然后运行 make qemu</li><li>您需要使用 C 字符串。 看一下 K&amp;R，例如第 5.5 节</li><li>请注意，&#x3D;&#x3D; 并不像 Python 中那样比较字符串。 请改用 strcmp()</li><li>将程序添加到 Makefile 中的 UPROGS 中</li></ul><blockquote><p>Some hints:</p><ul><li>Look at user&#x2F;ls.c to see how to read directories.</li><li>Use recursion to allow find to descend into sub-directories.</li><li>Don’t recurse into “.” and “..”.</li><li>Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu.</li><li>You’ll need to use C strings. Have a look at K&amp;R (the C book), for example Section 5.5.</li><li>Note that &#x3D;&#x3D; does not compare strings like in Python. Use strcmp() instead.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li></ul></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">T_DIR</span> <span class="token expression"><span class="token number">1</span> </span><span class="token comment">//Directory</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">T_FILE</span> <span class="token expression"><span class="token number">2</span> </span><span class="token comment">//File</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">T_DEVICE</span> <span class="token expression"><span class="token number">3</span> </span><span class="token comment">//Device</span></span><span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> dev<span class="token punctuation">;</span> <span class="token comment">//file system's disk device</span>    uint ino<span class="token punctuation">;</span> <span class="token comment">//inode number</span>    <span class="token keyword">short</span> type<span class="token punctuation">;</span> <span class="token comment">//type of file</span>    <span class="token keyword">short</span> nlink<span class="token punctuation">;</span> <span class="token comment">//number of links to file</span>    unit64 size<span class="token punctuation">;</span> <span class="token comment">//size of file in bytes</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/stat.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/fs.h"</span></span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">fmtname</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//将文件名格式化</span>  <span class="token keyword">static</span> <span class="token keyword">char</span> buf<span class="token punctuation">[</span>DIRSIZ <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> path <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">>=</span> path <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>p <span class="token operator">!=</span> <span class="token char">'/'</span><span class="token punctuation">;</span>p<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  p<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">>=</span> DIRSIZ<span class="token punctuation">)</span> <span class="token keyword">return</span> p<span class="token punctuation">;</span>  <span class="token function">memmove</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> p<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token operator">+</span><span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">,</span> DIRSIZ<span class="token operator">-</span><span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  buf<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> buf<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>fileName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>  <span class="token keyword">int</span> fd<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">stat</span> st<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">dirent</span> de<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"find: cannot open %s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fstat</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>st<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"find: cannot stat %s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//printf("%s %s\n",path, fmtname(path));</span>  <span class="token keyword">switch</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">case</span> T_FILE<span class="token operator">:</span><span class="token comment">//printf("%s\n", fmtname(path));</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token function">fmtname</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">,</span> fileName<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token keyword">case</span> T_DIR<span class="token operator">:</span><span class="token comment">//printf("%s %s\n", path, fmtname(path));</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> DIRSIZ <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> <span class="token keyword">sizeof</span> buf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"find: path too long\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>p <span class="token operator">=</span> buf <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span>p<span class="token operator">++</span> <span class="token operator">=</span> <span class="token char">'/'</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>de<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>de<span class="token punctuation">.</span>inum <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>de<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>de<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">".."</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">continue</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">memmove</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> de<span class="token punctuation">.</span>name<span class="token punctuation">,</span> DIRSIZ<span class="token punctuation">)</span><span class="token punctuation">;</span>  p<span class="token punctuation">[</span>DIRSIZ<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">find</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> fileName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">find</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><p>编写一个简单版本的 UNIX xargs 程序：从标准输入读取行并为每行运行一个命令，将该行作为参数提供给命令。您的解决方案应该位于文件 user&#x2F;xargs.c 中</p><blockquote><p>Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file <code>user/xargs.c</code>.</p></blockquote><p>提示：</p><ul><li>使用 fork 和 exec 在每一行输入上调用命令。 在父级中使用 wait 来等待子级完成命令</li><li>要读取单行输入，请一次读取一个字符，直到出现换行符 (‘\n’)。kernel&#x2F;param.h 声明了 MAXARG，如果您需要声明 argv 数组，这可能很有用。</li><li>将程序添加到 Makefile 中的 UPROGS 中。</li><li>文件系统的更改在 qemu 运行期间持续存在； 要获得干净的文件系统，请运行 make clean，然后运行 make qemu。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/stat.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/param.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>args<span class="token punctuation">[</span>MAXARG<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token comment">//将xargs的参数保存在args中</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        args<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//从标准输入读入一行</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> buf <span class="token operator">+</span> j<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> buf<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>            <span class="token operator">++</span>j<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">//全部读完</span>        buf<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//添加结尾</span>        <span class="token comment">//将标准输入传进的一行参数加到args后</span>        args<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">;</span>        args<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//添加字符串结尾</span>        <span class="token comment">//执行命令</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//args[0]是xargs，args[1]是要执行的命令，剩余的是参数</span>            <span class="token function">exec</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> args <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"exec error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络：自顶向下—Wireshark实验：HTTP和DNS</title>
      <link href="/2023/06/25/ji-suan-ji-wang-luo-zi-ding-xiang-xia-wireshark-shi-yan-http-he-dns/"/>
      <url>/2023/06/25/ji-suan-ji-wang-luo-zi-ding-xiang-xia-wireshark-shi-yan-http-he-dns/</url>
      
        <content type="html"><![CDATA[<h1 id="Wireshark实验：HTTP"><a href="#Wireshark实验：HTTP" class="headerlink" title="Wireshark实验：HTTP"></a>Wireshark实验：HTTP</h1><p><strong>执行操作：</strong></p><p>1.启动浏览器</p><p>2.启动wireshark数据包嗅探器，在display-filter-specification窗口中输入http，这样就在稍后的分组列表中只捕获http消息</p><p>3.稍等一会开始wireshark数据包捕获</p><p>4.4. 在浏览器中输入以下内容 <a href="http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html">http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html</a> ，您的浏览器应显示非常简单的单行HTML文件</p><ol start="5"><li>停止Wireshark数据包捕获。</li></ol><p>捕获到的http数据包如下图所示</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-11%20202941.png" alt="wireshark截图"></p><p>捕获的消息截图</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-11%20204459.png" alt="wireashark截图"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-11%20204538.png"></p><p>回答下列问题：</p><p>1.您的浏览器是否运行HTTP版本1.0或1.1？服务器运行什么版本的HTTP？</p><p>均匀运行http&#x2F;1.1</p><p>2.您的浏览器会从服务器接收哪种语言？</p><p>无</p><p>3.您的计算机的IP地址是什么？gaia.cs.umass.edu服务器地址呢？</p><p>我的计算机IP地址192.168.31.81</p><p>gaia.cs.umass.edu服务器地址是1.62.64.77</p><p>4.服务器返回到浏览器的状态代码是什么？</p><p>200 OK</p><p>5.服务器上的HTML文件的最近一次修改是什么时候？</p><p>Last-Modified: Thu, 16 Mar 2023 00:28:56</p><p>6.服务器返回多少字节的内容到您的浏览器？</p><p>352</p><p>7.通过检查数据包内容窗口中的原始书就，你是否看到有协议头在数据包列表窗口中未显示？如果是，请举一个例子</p><p>不到有没有</p><p>应该没有</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络自顶向下—第二章部分习题</title>
      <link href="/2023/06/25/ji-suan-ji-wang-luo-zi-ding-xiang-xia-di-er-zhang-bu-fen-xi-ti/"/>
      <url>/2023/06/25/ji-suan-ji-wang-luo-zi-ding-xiang-xia-di-er-zhang-bu-fen-xi-ti/</url>
      
        <content type="html"><![CDATA[<p><strong>P7.假定你在浏览器中点击一条超链接获得web页面。相关联的URL的IP地址没有缓存在本地主机上，因此必须使用DNSlookup以获得该IP地址。如果主机从DNS得到IP地址之前已经访问了n个DNS服务器；相继产生的RTT依次为RTT1,…,RTTn。进一步假定与链路相关的web页面只包含一个对象，即由少量的HTML文本组成。令RTT0表示本地主机和包含对象的服务器之间的RTT值。假定该对象传输时间为零，则从该客户点击该超链接到它接收到该对象需要多长时间？</strong></p><p>从DNS获得服务器的IP地址所需要的时间：<br>$$<br>RTT_1+…+RTT_n<br>$$<br>建立TCP连接，发送对象所需的时间<br>$$<br>2RTT_0<br>$$<br><strong>P8.参照习题P7，假定在同一服务器上某HTML文件引用了8个非常小的对象。忽略发送时间，在下列情况下需要多长时间</strong></p><p><strong>a.没有并行TCP连接的非持续HTTP</strong></p><p><strong>b.配置有5个并行连接的非持续HTTP</strong>、</p><p><strong>c.持续HTTP</strong></p><p>a.传输引用对象<br>$$<br>2<em>8RTT_0<br>$$<br>传输HTML基本文件<br>$$<br>2RTT_0<br>$$<br>总时间<br>$$<br>18RTT_0+RTT_1+…+RTT_n<br>$$<br>b.传输引用对象<br>$$<br>2</em>2RTT_0<br>$$<br>传输HTML基本文件<br>$$<br>2RTT_0<br>$$<br>总时间<br>$$<br>6RTT_0+RTT_1+…+RTT_n<br>$$<br>c.有管线连接<br>$$<br>RTT_0+RTT_1+…+RTT_n<br>$$<br>无管线连接<br>$$<br>10RTT_0+RTT_1+…+RTT_n<br>$$</p><p><strong>P9.考虑图2-12，其中有一个机构的网络和因特网相连。假定对象的平均长度为850 000比特，从这个机构网的浏览器到初始服务器的平均请求是每秒16个请求。还假定从接入链路的因特网一侧的路由器转发一个HTTP请求开始，到接收到其响应的平均时间是3秒。将总的平均响应时间建模为平均接入时延（即从因特网路由器到机构路由器的时延）和平均因特网时延之和了。对于平均接入时延，使用∆&#x2F;（1-∆β），∆是跨越接入链路发送一个对象的平均时间，β是对象对该接入链路的平均到达率。</strong></p><p><strong>a.求出总的平均响应时间</strong></p><p><strong>b.现在假定在这个机构LAN中安装了一个缓存器。假定命中率为0.4，求出总的响应时间</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230322223604.jpg"></p><p>a.<br>$$<br>∆&#x3D;0.85Mb&#x2F;15Mbps&#x3D;0.0567s<br>$$</p><p>$$<br>β&#x3D;16&#x2F;s<br>$$</p><p>$$<br>平均接入时延&#x3D;0.0567&#x2F;(1-0.0567*16)&#x3D;0.611s<br>$$</p><p>$$<br>总平均响应时间&#x3D;3+0.611&#x3D;3.611s<br>$$</p><p>b.<br>$$<br>β&#x3D;16*0.6<br>$$</p><p>$$<br>平均接入时延&#x3D;0.0567&#x2F;(1-0.0567*9.6)&#x3D;0.124s<br>$$</p><p>$$<br>命中总响应时间&#x3D;0.85Mb&#x2F;100Mb&#x3D;0.0085s<br>$$</p><p>$$<br>总平均响应时间&#x3D;0.0085<em>0.4+3.124</em>0.6&#x3D;1.8778s<br>$$</p><p><strong>P10.考虑一条10米短链路，某发送方经过它能够以150bps速率双向传输。假定包含数据的分组是100 000比特长，仅包含控制（如ACK或握手）的分组是200比特长。假定N个并行连接每个都获得1&#x2F;N的链路带宽。现在考虑HTTP协议，并且假定每个下载对象是100kb长，这些初始下载对象包含10个来自相同发送方的引用对象。在这种情况下，经非持续HTTP的并行实例的并行下载有意义吗？现在考虑持续HTTP。你期待这比非持续的情况有很大增益吗？评价并解释你的答案。</strong></p><p>发送方需与对方进行三次握手</p><p>若利用非持续HTTP进行下载：</p><p>前两次握手：<br>$$<br>控制分组传输+RTT<br>$$<br>总时间：<br>$$<br>(200&#x2F;150+Tp+200&#x2F;150+Tp+200&#x2F;150+Tp+100000&#x2F;150+Tp)+((200&#x2F;(150&#x2F;10)+Tp)*3+100000&#x2F;(150&#x2F;10)+Tp)<br>$$</p><p>若利用持续HTTP进行下载：</p><p>前两次握手所需时间与非持续HTTP相同</p><p>总时间为：<br>$$<br>(200&#x2F;150+Tp+200&#x2F;150+Tp+200&#x2F;150+Tp+100000&#x2F;150+Tp)+10*(200&#x2F;150+Tp+100000&#x2F;150+Tp)<br>$$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络自顶向下—第二章—套接字编程作业</title>
      <link href="/2023/06/25/ji-suan-ji-wang-luo-zi-ding-xiang-xia-di-er-zhang-tao-jie-zi-bian-cheng-zuo-ye/"/>
      <url>/2023/06/25/ji-suan-ji-wang-luo-zi-ding-xiang-xia-di-er-zhang-tao-jie-zi-bian-cheng-zuo-ye/</url>
      
        <content type="html"><![CDATA[<p><strong>网站<a href="http://www.pearsonhighered.com/cs-resource%E5%8F%AF%E4%BB%A5%E6%89%BE%E5%88%B0%E4%BD%9C%E4%B8%9A%E7%9A%84%E5%85%A8%E9%9D%A2%E7%BB%86%E8%8A%82">http://www.pearsonhighered.com/cs-resource可以找到作业的全面细节</a></strong></p><p>作业文档翻译以及解答参考</p><p><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer">https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer</a></p><h1 id="作业1：Web服务器"><a href="#作业1：Web服务器" class="headerlink" title="作业1：Web服务器"></a>作业1：Web服务器</h1><p><strong>在这个编程作业中，你将用Python语言开发一个简单的Web服务器，它仅能处理一个请求。具体而言，你的Web服务器将：（1）当一个客户（浏览器）联系时创建一个连接套接字；（2）从这个连接接收HTTP请求；（3）解释该请求以确定所请求的特定文件；（4）从服务器的文件系统获得请求的文件；（5）创建一个由请求的文件组成的HTTP响应报文，报文前面有首部行；（6）经TCP连接向请求的浏览器发送响应。如果浏览器请求一个在该服务器中不存在的文件，服务器应当返回一个“404 Not Found”差错报文。在配套网站中，我们提供了用于该服务器的框架代码。你的任务是完善该代码，运行你的服务器，通过在不同主机上运行的浏览器发送请求来测试服务器。如果运行你服务器的主机上已经有一个Web服务器在运行，你应当为该Web服务器使用一个不同于80端口的其他端口。</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span>serverSocket <span class="token operator">=</span>socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span> <span class="token comment">#socket类实例化，第一个参数是地址族（默认是socket.AF_INET,指定使用IPv4协议）；第二个参数是流（默认是socket.SOCK_STREAM,指定面向流的TCP协议）；第三个参数默认是0</span>serverPort<span class="token operator">=</span><span class="token number">6789</span><span class="token comment">#设置端口号为6789</span>serverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#将服务器套接字与端口号6789绑定</span>serverSocket<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#聆听来自客户端的请求，参数定义请求最大数（至少为1）</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Ready to serve...'</span><span class="token punctuation">)</span>    connectionSocket<span class="token punctuation">,</span> addr <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">#调用accept方法，创建名为connectionSocket的新的套接字供特定的客户使用</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        message <span class="token operator">=</span> connectionSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token comment">#获得客户端发送的报文，设定要发送的字节数</span>        filename <span class="token operator">=</span> message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment">#获得客户请求的文件名</span>        f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        outputdata <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#向客户端发送http首部</span>        header <span class="token operator">=</span> <span class="token string">'http/1.1 200 OK\nConnection: close\nContent-Type: text/html\nContent-Length: %d\n\n'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span>        connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>header<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>outputdata<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        connectionSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#报文发送完毕后关闭连接</span>    <span class="token keyword">except</span> IOError<span class="token punctuation">:</span><span class="token comment">#错误提示</span>        outputdata <span class="token operator">=</span> <span class="token string">'http/1.1 404 Not Found\r\n\r\n'</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>outputdata<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>emcode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    connectionSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>severSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在本地浏览器输入localhost:6789&#x2F;f.html</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-24%20174512.png" alt="发送成功"></p><p><strong>可选练习</strong></p><p><strong>1.目前，这个Web服务器一次只处理一个HTTP请求。请实现一个能够同时处理多个请求的多线程服务器。使用线程，首先创建一个主线程，在固定端口监听客户端请求。当从客户端收到TCP连接请求时，它将通过另一个端口建立TCP连接，并在另外的单独线程中为客户端请求提供服务。这样在每个请求&#x2F;响应对的独立线程中将有一个独立的TCP连接。</strong></p><p>程序中需要用到python的threading模块进行多线程编程</p><blockquote><p>在代码中引用threading模块</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="创建thread对象"><a href="#创建thread对象" class="headerlink" title="创建thread对象"></a>创建thread对象</h3><p>每个thread对象代表一个线程，在每个线程中我们可以让程序处理不同的任务</p><p>1.直接创建thread对象</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">threading</span><span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>group<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> target<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> kwargs<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> daemon<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>thread构造方法中，需要将一个callable对象赋值给target，线程才能正常运行</p><p>调用start()方法启动thread对象</p><p><strong>thread的名字</strong></p><p>每个thread都有一个name的属性，代表的就是线程的名字，可以在构造方法中赋值</p><p>默认为“Thread-number”的形式</p><p>可以通过is_alive的方法查询线程是否还在运行</p><p>在主线程结束时，若要使子线程也立即结束，可在子线程调用start()方法之前设置deamon的值为true</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">import</span> threading serverSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_IENT<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span><span class="token comment">#实例化socket类 </span><span class="token comment">#设置接收请求的端口号 </span>serverPort <span class="token operator">=</span> <span class="token number">1111</span> serverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#绑定 </span>serverSocekt<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>  <span class="token keyword">def</span> <span class="token function">function</span><span class="token punctuation">(</span>connectionSocket<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">try</span><span class="token punctuation">:</span>                 message <span class="token operator">=</span> connectionSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>                 filename <span class="token operator">=</span> message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                 f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                 outputdata <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>                 header <span class="token operator">=</span> <span class="token string">' HTTP/1.1 200 OK\nConnection: close\nContent-Type: text/html\nContent-Length: %d\n\n'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span>                       connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>header<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                 connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>outputdata<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                         connectionSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token keyword">except</span> IOError<span class="token punctuation">:</span>                 outputdata <span class="token operator">=</span> <span class="token string">'HTTP/1.1 404 Not Found\r\n\r\n'</span>                 <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                         connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>outputdata<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                      connectionSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span> <span class="token string">'Ready to serve...'</span><span class="token punctuation">)</span>         connectionSocket<span class="token punctuation">,</span> addr <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>         thread <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>webProcess<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>connectionSocket<span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#多线程     </span>    thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>   serverSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**2.不使用浏览器，编写自己的HTTP客户端来测试你的服务器。您的客户端将使用一个TCP连接用于连接到服务器，向服务器发送HTTP请求，并将服务器响应显示出来。您可以假定发送的HTTP请求将使用GET方法。    客户端应使用命令行参数指定服务器IP地址或主机名，服务器正在监听的端口，以及被请求对象在服务器上的路径。以下是运行客户端的输入命令格式。 **</p><blockquote><p>client.py server_host server_port filename</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span> serverName <span class="token operator">=</span> <span class="token string">'192.0.0.0'</span> serverPort <span class="token operator">=</span> <span class="token number">6789</span> clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_IENT<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span> clientSocket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>serverName<span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>  outputdata <span class="token operator">=</span> <span class="token string">'GET /f.html HTTP/1.1\r\n Host: 192.168.137.1\r\n\r\n'</span> clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>outputdata<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> data <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">while</span> data<span class="token punctuation">:</span>         data <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">)</span>      clientSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="作业2：UDP-ping程序"><a href="#作业2：UDP-ping程序" class="headerlink" title="作业2：UDP ping程序"></a>作业2：UDP ping程序</h1><p><strong>在这个编程作业中，你将用python编写一个客户ping程序。该客户将发送一个简单的ping报文，接受一个从服务器返回的对应pong报文，并确定从该客户发送ping报文到接收到pong报文为止的时延。该时延称为往返时延（RTT）。由该客户和服务器提供的功能类似于在现代操作系统中可用的标准ping程序。然而，标准的ping使用互联网控制报文协议（ICMP）。此时我们将创建一个非标准（但简单的）基于UDP的ping程序。</strong></p><p><strong>你的ping程序经UDP向目标服务器发送10个ping报文。对于每个报文，当对应的pong报文返回时，你的客户要确定和打印RTT。因为UDP是一个不可靠的协议，由客户发送的分组可能会丢失。为此，客户不能无限期地等待对ping报文的回答。客户等待服务器回答的时间至多为一秒；如果没有收到回答，客户假定该分组丢失并相应的打印一条报文。</strong></p><p><strong>在此作业中，你将给出服务器的完整代码，你的任务是编写客户代码，可以随意地从服务器代码中剪贴代码行。</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#UDPserver.py</span><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> random <span class="token comment">#随机数生成</span>serverSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">)</span>serverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> <span class="token number">1111</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>                  rand <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>                  message<span class="token punctuation">,</span> address <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>                  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"收到来自 %s 的报文：（%s）"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>address<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">)</span>                  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"随机数是：%d"</span> <span class="token operator">%</span> rand<span class="token punctuation">)</span>                  message <span class="token operator">=</span> message<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span>                                    <span class="token keyword">if</span> rand <span class="token operator">&lt;</span> <span class="token number">4</span>                     comtinue                  serverSocket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>message<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#UDPclient.py</span><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> timeserverName <span class="token operator">=</span> <span class="token string">'localhost'</span>serverPort <span class="token operator">=</span> <span class="token number">1111</span>clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        time_start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#开始计时</span>        message <span class="token operator">=</span> <span class="token string">'Ping *'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>time_start<span class="token punctuation">)</span> <span class="token comment">#要发送的ping报文</span>        clientSocket<span class="token punctuation">.</span>settimeout<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">#超时处理时间设置为1s</span>        clientSocket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>message<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">,</span><span class="token number">1111</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">try</span><span class="token punctuation">:</span>            modified<span class="token punctuation">,</span> serveraddress <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>            Time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> time_start <span class="token comment">#计算RTT</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cost'</span><span class="token punctuation">,</span> Time<span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">)</span>        <span class="token keyword">except</span> timeout<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Request Time Out'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>            clientSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写程序时遇到的问题与解决方法：</p><p>1.将服务器端代码与客户端代码运行后，客户端收到的消息一直为“Request Time Out”，将except后错误类型改为timeout解决</p><p><strong>可选练习</strong></p><p>**1.目前，程序计算每个数据包的往返时间（RTT），并单独打印出来。请按照标准ping程序的模式修改。您需要在客户端每次ping后显示最小，最大和平均RTT。另外，还需计算丢包率（百分比）。 **</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">import</span> time  serverName <span class="token operator">=</span> <span class="token string">'localhost'</span> serverPort <span class="token operator">=</span> <span class="token number">1111</span> recvnum<span class="token operator">=</span><span class="token number">0</span> <span class="token builtin">max</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token builtin">min</span> <span class="token operator">=</span> <span class="token number">2</span> aver <span class="token operator">=</span> <span class="token number">0</span> clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">)</span> <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>         <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                      time_start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>                     message <span class="token operator">=</span> <span class="token string">'Ping *'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>time_start<span class="token punctuation">)</span>                    clientSocket<span class="token punctuation">.</span>settimeout<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                     clientSocket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>message<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> <span class="token number">1111</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                      <span class="token keyword">try</span><span class="token punctuation">:</span>                             modified<span class="token punctuation">,</span> serveraddress <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>                               Time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span> time_start                             <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cost'</span><span class="token punctuation">,</span> Time<span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">)</span>                             recvnum<span class="token operator">+=</span><span class="token number">1</span>                             aver <span class="token operator">+=</span>Time                            <span class="token keyword">if</span><span class="token punctuation">(</span>Time<span class="token operator">></span><span class="token builtin">max</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                                     <span class="token builtin">max</span><span class="token operator">=</span>Time                             <span class="token keyword">if</span><span class="token punctuation">(</span>Time<span class="token operator">&lt;</span><span class="token builtin">min</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                                     <span class="token builtin">min</span><span class="token operator">=</span>Time                       <span class="token keyword">except</span> timeout<span class="token punctuation">:</span>                             <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Request Time Out'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"丢失率"</span><span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">-</span>recvnum<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">100</span><span class="token operator">/</span>recvnum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"%"</span><span class="token punctuation">)</span> <span class="token keyword">if</span><span class="token punctuation">(</span>recvnum<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"最短"</span><span class="token punctuation">,</span> <span class="token builtin">min</span><span class="token punctuation">,</span> <span class="token string">"最长"</span><span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token punctuation">,</span> <span class="token string">"平均"</span><span class="token punctuation">,</span> aver<span class="token operator">/</span>recvnum<span class="token punctuation">)</span>  clientSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.  UDP Ping的另一个类似的应用是UDP Heartbeat。心跳可用于检查应用程序是否已启动并运行，并报告单向丢包。客户端在UDP数据包中将一个序列号和当前时间戳发送给正在监听客户端心跳的服务器。服务器收到数据包后，计算时差，报告丢包（若发生）。如果心跳数据包在指定的一段时间内丢失，我们可以假设客户端应用程序已经停止。实现UDP Heartbeat（客户端和服务器端）。您需要修改给定的UDPPingerServer.py和您自己的UDP ping客户端。</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#server</span><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span>serverSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">)</span>serverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> <span class="token number">1111</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    message<span class="token punctuation">,</span> address <span class="token operator">=</span> serverSocekt<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    message <span class="token operator">=</span> message<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    message <span class="token operator">=</span> message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    timeDiff <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token builtin">float</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"RTT is"</span><span class="token punctuation">,</span> timeDiff<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#client</span><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> timeserverName <span class="token operator">=</span> <span class="token string">'localhost'</span>serverPort <span class="token operator">=</span> <span class="token number">1111</span>clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    time1 <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    outputdata <span class="token operator">=</span> <span class="token string">'Heartbeat'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>time1<span class="token punctuation">)</span>    clientSocket<span class="token punctuation">.</span>seendto<span class="token punctuation">(</span>outputdata<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>serverName<span class="token punctuation">,</span> serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="作业三：邮件客户"><a href="#作业三：邮件客户" class="headerlink" title="作业三：邮件客户"></a>作业三：邮件客户</h1><p><strong>这个编程作业的目的是创建一个向任何接收方发送电子邮件的简单邮件客户。你的客户将必须与邮件服务器（如谷歌的电子邮件服务器）创建一个TCP连接，使用SMTP协议与邮件服务器进行交谈，经该邮件服务器向某接收方（如你的朋友）发送一个电子邮件报文，最后关闭与该邮件服务器的TCP连接。</strong></p><p><strong>对本作业，配套的web站点为你的客户提供了框架代码。你的任务是完善该代码并通过向不同的用户账户发送电子邮件来测试你的客户。你也可以尝试通过不同的服务器（例如谷歌的邮件服务器和你所在的大学的邮件服务器）进行发送</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socekt <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> base64mailserver <span class="token operator">=</span> <span class="token string">'smtp.qq.com'</span> <span class="token comment">#你所用邮件服务器的地址</span>mailUser <span class="token operator">=</span> <span class="token string">'aaa'</span>mailFromAddress <span class="token operator">=</span> <span class="token string">'aaa@qq.com'</span>mailPassword <span class="token operator">=</span> <span class="token string">'******'</span> <span class="token comment">#可以在邮箱设置授权码，使用授权码登录</span>mailToAddress <span class="token operator">=</span> <span class="token string">'bbb@163.com'</span>clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>mailserver<span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#qq的smtp端口号</span>recv <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>recv<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span><span class="token keyword">if</span> recv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'220'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"220 reply not received from server"</span><span class="token punctuation">)</span>        helloCommand <span class="token operator">=</span> <span class="token string">'HELO mailserver\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>helloCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    recv1 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv1 <span class="token operator">=</span> recv1<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv1<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv1<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'250'</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>        loginCommand <span class="token operator">=</span> <span class="token string">'AUTH LOGIN\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>loginCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    recv <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv <span class="token operator">=</span> recv<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'334'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>                userCommand <span class="token operator">=</span> base64<span class="token punctuation">.</span>b64encode<span class="token punctuation">(</span>mailUser<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">b'\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span>：clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>userCommand<span class="token punctuation">)</span>    recv <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv <span class="token operator">=</span> recv<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'334'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>                passCommand <span class="token operator">=</span> base64<span class="token punctuation">.</span>b64encode<span class="token punctuation">(</span>mailPassword<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">b'\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>passCommand<span class="token punctuation">)</span>    recv <span class="token operator">=</span> client<span class="token punctuation">.</span>socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>recv <span class="token operator">=</span> recv<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'235'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>                mailfromCommand <span class="token operator">=</span> <span class="token string">'MAIL FROM: &lt;aaa@qq.com>\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>mailfromCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    recv2 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv2 <span class="token operator">=</span> recv2<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv2<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'250'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>                rcptCommand <span class="token operator">=</span> <span class="token string">'RCPT TO: &lt;bbb@163.com>\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>rcptCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    recv3 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv3 <span class="token operator">=</span> recv3<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv3<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv3<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'250'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>                dataCommand <span class="token operator">=</span> <span class="token string">'DATA\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>DataCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    recv4 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv4 <span class="token operator">=</span> recv4<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv4<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv4<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'354'</span>    <span class="token keyword">break</span>                messageCommand <span class="token operator">=</span> <span class="token string">'\r\ni am doing my computer networking homework\r\n:)\r\n'</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>messageCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>endCommand <span class="token operator">=</span> <span class="token string">'\r\n.\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>endCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    recv5 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv5 <span class="token operator">=</span> recv5<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv5<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv5<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'250'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>                quitCommand <span class="token operator">=</span> <span class="token string">'QUIT\r\n'</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clientSocekt<span class="token punctuation">.</span>send<span class="token punctuation">(</span>quitCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    recv6 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    recv6 <span class="token operator">=</span> recv6<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>recv6<span class="token punctuation">)</span>    <span class="token keyword">if</span> recv5<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'221'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>clientSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-25%20230712.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-25%20233953.png"></p><p><strong>可选练习：</strong></p><p><strong>1.类似Google邮件的服务器（如地址：smtp.gmail.com，端口：587））要求您的客户端在发送MAIL FROM命令之前，需要为了身份验证和安全原因添加传输层安全（TLS）或安全套接字层（SSL）。将TLS &#x2F; SSL命令添加到现有的命令中，并使用上述地址和端口为Google邮件服务器实现客户端。</strong></p><p>代码部分只需在上一题基础上稍作更改</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#导入ssl模块</span><span class="token keyword">import</span> ssl<span class="token comment">#创建套接字</span>context <span class="token operator">=</span> ssl<span class="token punctuation">.</span>create_default_context<span class="token punctuation">(</span><span class="token punctuation">)</span>clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>mailserver<span class="token punctuation">,</span> <span class="token number">465</span><span class="token punctuation">)</span><span class="token punctuation">)</span>clientSocketSSL <span class="token operator">=</span> context<span class="token punctuation">.</span>wrap_socket<span class="token punctuation">(</span>clientSocket<span class="token punctuation">,</span> server_hostname<span class="token operator">=</span>mailserver<span class="token punctuation">)</span><span class="token comment">#套接字变成clientSocketSSL</span><span class="token comment">#需要更改的部分</span>recv <span class="token operator">=</span> clientSocketSSL<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>clientSocketSSL<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token operator">**</span><span class="token operator">*</span>Command<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>clientSocketSSL<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.您当前的SMTP邮件客户端只能在电子邮件正文中发送文本消息。修改您的客户端，使其可以发送包含文本和图像的电子邮件。</strong></p><h1 id="作业四：多线程web代理服务器"><a href="#作业四：多线程web代理服务器" class="headerlink" title="作业四：多线程web代理服务器"></a>作业四：多线程web代理服务器</h1><p><strong>在这个编程作业中，你将研发一个简单的web代理服务器。当你的代理服务器从一个浏览器接收到对某对象的HTTP请求，它生成对相同对象的一个新的HTTP请求并向初始服务器发送。当该代理服务器从初始服务器接收到具有该对象的HTTP响应时，它生成一个包括该对象的新HTTP响应，并发送给该客户。这个代理将是多线程的，使其在相同时间能够处理多个请求。</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os <span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">import</span> sys  <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Usage : "python ProxyServer.py server_ip"\n[server_ip : It is the IP Address Of Proxy Server'</span> <span class="token punctuation">)</span>         sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">#创建服务器套接字，与端口绑定，保持倾听 </span>tcpSerSock <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span> tcpSerPort <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>tcpSerSock<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> tcpSerPort<span class="token punctuation">)</span><span class="token punctuation">)</span> tcpSerSock<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>  <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'ready to serve...'</span><span class="token punctuation">)</span>         tcpCliSock<span class="token punctuation">,</span> addr <span class="token operator">=</span> tcpSerSock<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'received a connection from:'</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>        message <span class="token operator">=</span> tcpCliSock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"message: "</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>message <span class="token operator">==</span> <span class="token string">''</span><span class="token punctuation">)</span>             <span class="token keyword">continue</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        filename <span class="token operator">=</span> message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>partition<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span>         fileExist <span class="token operator">=</span> <span class="token string">'false'</span>         filetouse <span class="token operator">=</span> <span class="token string">"/"</span> <span class="token operator">+</span> filename         <span class="token keyword">print</span><span class="token punctuation">(</span>filetouse<span class="token punctuation">)</span>         <span class="token keyword">try</span><span class="token punctuation">:</span>                 f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"WEB/"</span><span class="token punctuation">,</span> filetouse<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span>                 outputdata <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>                 fileExist <span class="token operator">=</span> <span class="token string">"true"</span>                tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"HTTP/1.0 200 OK \r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                 tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"Content-type:text/html\r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                 tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span>                 <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'read from cache'</span><span class="token punctuation">)</span>          <span class="token keyword">except</span> IOError<span class="token punctuation">:</span>                 <span class="token keyword">if</span> fileExist <span class="token operator">==</span> <span class="token string">'false'</span><span class="token punctuation">:</span>                         c <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span>                        hosten <span class="token operator">=</span> filename<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"www."</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>                         <span class="token keyword">print</span><span class="token punctuation">(</span>hosten<span class="token punctuation">)</span>                         <span class="token keyword">try</span><span class="token punctuation">:</span>                                 serverName <span class="token operator">=</span> hosten<span class="token punctuation">.</span>partition<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                                 serverPort <span class="token operator">=</span> <span class="token number">80</span>                                 c<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>serverName<span class="token punctuation">,</span> serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>                                 askfile <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>filename<span class="token punctuation">.</span>partition<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                                 fileobj <span class="token operator">=</span> c<span class="token punctuation">.</span>makefile<span class="token punctuation">(</span><span class="token string">'rwb'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>                                 fileobj<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> askfile<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"HTTP/1.0\r\nHost: "</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\r\n\r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                 serverRespnse <span class="token operator">=</span> fileobj<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>                                  filename <span class="token operator">=</span> <span class="token string">"WEB/"</span> <span class="token operator">+</span> filename                                 filesplit <span class="token operator">=</span> filename<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>                                 <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>filesplit<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                                        <span class="token keyword">if</span> notos<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>filesplit<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>filesplit<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                  tmpFile <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">"wb"</span><span class="token punctuation">)</span>                                  <span class="token keyword">print</span><span class="token punctuation">(</span>serverResponse<span class="token punctuation">)</span>                                  serverResponse <span class="token operator">=</span> serverResponse<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">b'\r\n\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                                  <span class="token keyword">print</span><span class="token punctuation">(</span>serverResponse<span class="token punctuation">)</span>                                  tmpFile<span class="token punctuation">.</span>write<span class="token punctuation">(</span>serverResponse<span class="token punctuation">)</span>                                  tmpFile<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>                                  tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"HTTP/1.1 200 OK\r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                  tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"Content-Type:text/html\r\n\r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                     tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span>serverResponse<span class="token punctuation">)</span>                           <span class="token keyword">except</span><span class="token punctuation">:</span>                                 <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"illegal request"</span><span class="token punctuation">)</span>                             c<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>                     <span class="token keyword">else</span><span class="token punctuation">:</span>                             <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"net error"</span><span class="token punctuation">)</span>               tcpCliSock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>   tcpCliSock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>美赛绘图介绍</title>
      <link href="/2023/06/25/mei-sai-hui-tu-jie-shao/"/>
      <url>/2023/06/25/mei-sai-hui-tu-jie-shao/</url>
      
        <content type="html"><![CDATA[<h1 id="美赛绘图介绍"><a href="#美赛绘图介绍" class="headerlink" title="美赛绘图介绍"></a>美赛绘图介绍</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h3><p><a href="https://mycolor.space/">colorspace</a></p><h3 id="图片素材"><a href="#图片素材" class="headerlink" title="图片素材"></a>图片素材</h3><p><a href="https://www.freepik.com/">freepic</a></p><h3 id="python画图"><a href="#python画图" class="headerlink" title="python画图"></a>python画图</h3><p><a href="https://zhuanlan.zhihu.com/p/81553421?utm_source=wechat_session">seaborn库</a></p><h3 id="绘图网站"><a href="#绘图网站" class="headerlink" title="绘图网站"></a>绘图网站</h3><p><a href="https://www.bioladder.cn/web/#/pro/index">bioladder</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录—链表</title>
      <link href="/2023/06/25/suan-fa-shua-ti-ji-lu-lian-biao/"/>
      <url>/2023/06/25/suan-fa-shua-ti-ji-lu-lian-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">力扣题目链接</a></p><ul><li><p><strong>直接使用原来的链表进行删除操作</strong></p></li><li><p><strong>设置一个虚拟头节点在进行操作</strong></p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        ListNode* dummyHead &#x3D; new ListNode(0); &#x2F;&#x2F; 设置一个虚拟头结点        dummyHead-&gt;next &#x3D; head; &#x2F;&#x2F; 将虚拟头结点指向head，这样方面后面做删除操作        ListNode* cur &#x3D; dummyHead;        while (cur-&gt;next !&#x3D; NULL) &#123;            if(cur-&gt;next-&gt;val &#x3D;&#x3D; val) &#123;                ListNode* tmp &#x3D; cur-&gt;next;                cur-&gt;next &#x3D; cur-&gt;next-&gt;next;                delete tmp;            &#125; else &#123;                cur &#x3D; cur-&gt;next;            &#125;        &#125;        head &#x3D; dummyHead-&gt;next;        delete dummyHead;        return head;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><p><a href="https://leetcode.cn/problems/design-linked-list/">力扣题目链接</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;定义链表结构体struct LinkedNode&#123;    int val;    LinkedNode* next;    LinkedNode(int val):val(val),next(nullptr)&#123;&#125;    &#125;;MyLinkedList()&#123;    _dummyhead &#x3D; new LinkedNode(0);    _size&#x3D;0;&#125;int get(int index)&#123;    if(index &gt; (_size - 1)||index&lt;0)&#123;        return -1;    &#125;    LinkedNode* cur &#x3D; _dummyhead-&gt;next;    while(index--)&#123;        cur &#x3D; cur-&gt;next;    &#125;    return cur-&gt;val;&#125;void addAtHead(int val)&#123;    LinkedNode* newnode &#x3D; new LinkedNode(val);    newnode-&gt;next&#x3D;_dummyhead-&gt;next;    _dummyhead-&gt;next&#x3D;newnode;    _size++;&#125;void addAtTail(int val)&#123;    LinkedNode* newnode &#x3D; new LinkedNode(val);    LinkedNode* cur &#x3D; _dummyhead;    whlie(cur-&gt;next !&#x3D; nullptr)&#123;        cur &#x3D; cur-&gt;next;    &#125;    cur-&gt;next &#x3D; newnode;   _size++; &#125;void addAtIndex(int index, int val)&#123;    if(index &gt; _size) return;    if(index &lt; 0) index&#x3D;0;    LinkedNode* newnode &#x3D; new LinkedNode(val);    LinkedNode* cur &#x3D; _dummyhead;    whlie(index--)&#123;        cur&#x3D;cur-&gt;next;    &#125;    newnode-&gt;next &#x3D; cur-&gt;next;    cur-&gt;next &#x3D; newnode;    _size++;    &#125;void deleteAtIndex(int index)&#123;    if(index &gt;&#x3D; _size || index &lt; 0)&#123;        return;    &#125;    LinkedNode* cur &#x3D; _dunnyhead;    while(index--)&#123;        cur&#x3D;cur-&gt;next;    &#125;    LinkedNode* tmp &#x3D; cur-&gt;next;    cur-&gt;next &#x3D; cur-&gt;next-&gt;next;    delete tmp;    _size--;&#125;private: int _size; LinkedNode* _dummyhead;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/">力扣题目链接</a></p><p><strong>双指针法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">LinkNode* reverseList(ListNode* head)&#123;    ListNode* temp;    ListNode* cur &#x3D; head;    ListNode* pre &#x3D; nullptr;    while(cur)&#123;        temp &#x3D; cur-&gt;next;        pre &#x3D; cur;        cur &#x3D; temp;    &#125;    return pre;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>递归法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode* reverse(ListNOde* pre, ListNode* cur)&#123;    if(cur&#x3D;&#x3D;nullptr) return pre    ListNode* temp &#x3D; cur-&gt;next;    cur-&gt;next &#x3D; pre;    return reverse(cur, temp);&#125;ListNode* reverseList(ListNode* head)&#123;    return reverse(nullptr,head);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="19-删除链表倒数第n个结点"><a href="#19-删除链表倒数第n个结点" class="headerlink" title="19.删除链表倒数第n个结点"></a>19.删除链表倒数第n个结点</h3><p><strong>双指针法</strong></p><p>添加虚拟头节点</p><p>fast指针向后移动n+1步</p><p>fast和slow同时移动至fast指针指向末尾</p><p>删除slow后面的节点</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode* dummyhead&#x3D;new ListNode(0);dummyhead-&gt;next&#x3D;head;ListNode* fast&#x3D;dummyhead;ListNode* slow&#x3D;dummyhead;while(n-- &amp;&amp; fast!&#x3D;nullptr)&#123;    fast&#x3D;fast-&gt;next;&#125;fast-fast-&gt;next;while(fast!&#x3D;nullptr)&#123;    fast&#x3D;fast-&gt;next;    slow&#x3D;slow-&gt;next;&#125;slow-&gt;next&#x3D;slow-&gt;next-&gt;next;return dummyhead-&gt;next;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h3><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">力扣题目链接</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode* dummyhead&#x3D;new ListNode(0);dummyhead-&gt;next&#x3D;head;ListNode* cur&#x3D;dummyhead;while(cur-&gt;next !&#x3D; nullptr &amp;&amp; cur-&gt;next-&gt;next !&#x3D; nuulptr)&#123;    ListNode* temp1&#x3D;cur-&gt;next;  ListNode* temp2&#x3D;cur-&gt;next-&gt;next-&gt;next;    cur-&gt;next&#x3D;cur-&gt;next-&gt;next;    cur-&gt;next-&gt;next&#x3D;temp1;    cur-&gt;next-&gt;next-&gt;next&#x3D;temp2;    &#125;return dummyhead-&gt;next;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="160-链表相交"><a href="#160-链表相交" class="headerlink" title="160.链表相交"></a>160.链表相交</h3><p>计算两链表的长度</p><p>求出长度差值</p><p>让指针移动到末尾对其的位置</p><p>比较两指针是否相同，不相同则后移</p><p>直至两指针相等</p><h3 id="142-环形链表"><a href="#142-环形链表" class="headerlink" title="142.环形链表"></a>142.环形链表</h3><p><strong>双指针法</strong></p><p>fast走两个节点，slow走一个节点</p><p><strong>fast指针先进入环中，fast与slow一定在换环中相遇。</strong></p><p><strong>相对于slow来说，fast是一步步靠近slow的</strong></p><h4 id="如何找到环的入口"><a href="#如何找到环的入口" class="headerlink" title="如何找到环的入口"></a>如何找到环的入口</h4><p>从头节点出发一个指针，从相遇节点也出发一个指针，每次均走一个节点，两个指针相遇时就是环形入口的节点。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode* fast&#x3D;head;ListNode* slow&#x3D;head;while(fast!&#x3D;nullptr&amp;&amp;fast-&gt;next!&#x3D;nullptr)&#123;    slow&#x3D;slow-&gt;next;    fast&#x3D;fast-&gt;next-&gt;next;    if(slow&#x3D;&#x3D;fast)    &#123;        ListNode* index1&#x3D;fast;        ListNode* index2&#x3D;head;        while(index1!&#x3D;index2)        &#123;            index1&#x3D;index1-&gt;next;            index2&#x3D;index2-&gt;next;        &#125;        return index2;    &#125;&#125;return NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录—栈与队列</title>
      <link href="/2023/06/25/suan-fa-shua-ti-ji-lu-zhan-yu-dui-lie/"/>
      <url>/2023/06/25/suan-fa-shua-ti-ji-lu-zhan-yu-dui-lie/</url>
      
        <content type="html"><![CDATA[<h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说，我们可以控制使用哪种容器来实现栈的功能）</p><p>栈不提供走访功能，不提供迭代器</p><p>我们常用的SGI STL，如果没有指定其底层实现的话，默认是以deque为缺省情况下的底层结构</p><p>也可以指定vector为栈的底层实现</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::stack&lt;int, std::vector&lt;int&gt; &gt; third;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>队列的情况也是一样的</p><p>不允许有遍历行为，不提供迭代器</p><p>SGI STL中也是以deque缺省情况下的底部结构</p><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    bool isValid(string s)    &#123;        stack&lt;char&gt; ss;        if(s.size()%2 !&#x3D; 0) return false;                for(int i&#x3D;0;i&lt;s.size();i++)        &#123;            if(s[i]&#x3D;&#x3D;&#39;(&#39;) ss.push(&#39;)&#39;);            else if(s[i]&#x3D;&#x3D;&#39;[&#39;) ss.push(&#39;]&#39;);            else if(s[i]&#x3D;&#x3D;&#39;&#123;&#39;) ss.push(&#39;&#125;&#39;);            else if(ss.empty() || ss.top!&#x3D;s[i]) return false;            else ss.pop();        &#125;        return ss.empty();                &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1047-删除字符串中的相邻重复项"><a href="#1047-删除字符串中的相邻重复项" class="headerlink" title="1047.删除字符串中的相邻重复项"></a>1047.删除字符串中的相邻重复项</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123; public:         string removeDuplicates(string s)     &#123;                 stack&lt;char&gt; ss;                 for(char a:s)                 &#123;                         if(ss.empty() || a!&#x3D;ss.top())                        &#123;          ss.push(a);          &#125;              else                         &#123;                                ss.pop();             &#125;                     &#125;                  string result&#x3D;&quot;&quot;;                 while(!ss.empty())                 &#123;                     result+&#x3D;ss.top();                         ss.pop();                 &#125;                 reverse(result.begin(),result.end());                 return result;           &#125; &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="150-逆波兰表达式"><a href="#150-逆波兰表达式" class="headerlink" title="150.逆波兰表达式"></a>150.逆波兰表达式</h3><blockquote><p>字符串有关的函数</p><p>1.stoi()</p><p>将字符串转换为整型</p><p>2.stoll()</p><p>将字符串转换为long long</p><p>3.stof()</p><p>将字符串转换为float</p><p>4.stod()</p><p>将字符串转换为double<a href="https://www.comap-math.com/mcm/2023Certs/2303164.pdf">https://www.comap-math.com/mcm/2023Certs/2303164.pdf</a></p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    int evalRPN(vector&lt;string&gt;&amp; tokens)&#123;stack&lt;long long&gt; st;        for(int i&#x3D;0;i &lt; tokens.size();i++)        &#123;            if(tokens[i] &#x3D;&#x3D; &quot;+&quot; || tokens[i] &#x3D;&#x3D; &quot;-&quot; || tokens &#x3D;&#x3D; &quot;*&quot; || tokens &#x3D;&#x3D; &quot;&#x2F;&quot;)&#123;                long long num1 &#x3D; st.top();                st.pop();                long long num2 &#x3D; st.top();                st.pop();                if(tokens[i] &#x3D;&#x3D; &quot;+&quot;) st.push(num1 + num2);                if(tokens[i] &#x3D;&#x3D; &quot;-&quot;) st.push(num2 - num1);                if(tokens[i] &#x3D;&#x3D; &quot;*&quot;) st.push(num2 * num1);                if(tokens[i] &#x3D;&#x3D; &quot;&#x2F;&quot;) st.push(num2 &#x2F; num1);                            &#125;            else&#123;                st.push(stoll(tokens[i]));            &#125;&#125;        int result &#x3D; st.top();        st.pop();        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h3><p>对于此题，我们需要一个队列，随着窗口移动，队列一进一出，每次移动调用que.pop()（滑动窗口移除元素）、que.push()（滑动窗口添加元素）、que.front()（返回最大值）</p><p><strong>该队列只维护有可能成为窗口里最大值的元素（单调队列）</strong></p><p>单调队列如何配合窗口进行移动：</p><ol><li><p>pop(value)：<strong>窗口移除的元素value &#x3D; 队列出口元素，则弹出元素，否则不进行任何操作</strong></p></li><li><p>push(value)：<strong>push的元素value &gt; 入口元素的值，弹出入口元素，直到push元素的数值 &lt;&#x3D; 队列入口元素的数值</strong></p></li><li><p>que.front()返回窗口最大值</p></li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;private:    class Myqueue&#123;        public:        deque&lt;int&gt; que;        void pop(int value)            &#123;                if(!que.empty &amp;&amp; value &#x3D;&#x3D; que.front())                    que.pop_front();            &#125;        void push(int value)            &#123;                while(!que.empty &amp;&amp; value &gt; que.front())                &#123;                    que.pop_back();                &#125;                que.push_back(value);            &#125;        int front()        &#123;            return que.front();        &#125;            &#125;;public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k)    &#123;        Myqueue que;        vector&lt;int&gt; result;        for(int i&#x3D;0;i &lt; k;i++)        &#123;            que.push(nums[i]);        &#125;        result.push_back(que.front());        for(int i&#x3D;k;i &lt; nums.size();i++)        &#123;            que.pop(nums[i-k]);            que.push(nums[i]);            result.push_back(que.front());        &#125;        return result;    &#125;    &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="347-前k个高频元素"><a href="#347-前k个高频元素" class="headerlink" title="347.前k个高频元素"></a>347.前k个高频元素</h3><ol><li>利用map进行元素频率的统计</li><li>利用priority_queue对频率进行排列</li></ol><blockquote><p>优先级队列内部元素自动依照元素的权值排列</p><p>缺省情况下priority_queue利用max_heap完成对元素的排列，该大顶堆是以vector为表现形式的complete binary tree</p><p>本题利用小顶堆来实现</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    class mycomparison&#123;        public:        bool operator()(const pair&lt;int,int&gt;&amp; lhs, const pair&lt;int,int&gt;&amp; rhs)            &#123;                return lhs.second &gt; rhs.second;            &#125;    &#125;;        vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k)    &#123;        unordered_map&lt;int, int&gt; map;        for(int i&#x3D;0;i  &lt; nums.size();i++)        &#123;            map[nums[i]]++;        &#125;        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; ,mycomparison&gt; que;        for(unordered_map&lt;int, int&gt;::iterator it&#x3D;map.begin();it!&#x3D;map.end();it++)        &#123;            que.push(*it);            if(que.size()&gt;k)                que.pop();        &#125;        vector&lt;int&gt; result(k);        for(int i&#x3D;k-1;i&gt;&#x3D;0;i--)        &#123;            result[i] &#x3D; que.top().first;            que.pop()        &#125;                return result;            &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><p>匹配左括号时，右括号先入栈，只需要比较当前元素和栈顶相不相等</p><h4 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h4><p>将字符串顺序放到一个栈中，如果相同的话栈就弹出</p><h4 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h4><p>相邻字符串的消除问题</p><h4 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h4><p>队列没有必要维护窗口里的所有元素，只需要维护可能成为窗口里最大值的元素，同时保证队列里的元素数值时由大到小的</p><p>设计单调队列时，pop和push的操作要保持以下原则：</p><ol><li>pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用进行任何操作</li><li>push(value)：如果push的元素value大于入口元素的数值，那么就将队列出口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</li></ol><h4 id="求前K个高频元素"><a href="#求前K个高频元素" class="headerlink" title="求前K个高频元素"></a>求前K个高频元素</h4><p>unordered_map计算频率</p><p>利用priority_queue完成对元素的排序</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题基础—数组</title>
      <link href="/2023/06/25/suan-fa-shua-ti-ji-lu-shu-zu/"/>
      <url>/2023/06/25/suan-fa-shua-ti-ji-lu-shu-zu/</url>
      
        <content type="html"><![CDATA[<h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h3><p><a href="https://leetcode.cn/problems/binary-search/">力扣题目链接</a></p><p>二分法的两种写法：</p><ul><li><p>定义target在左闭右闭的区间里</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int low &#x3D; 0;        int high &#x3D; nums.size() - 1;         while (low &lt;&#x3D; high)         &#123;             int middle &#x3D; low + ((high - low) &#x2F; 2);&#x2F;&#x2F; 防止溢出             if (nums[middle] &gt; target) &#123;                high &#x3D; middle - 1;            &#125; else if (nums[middle] &lt; target) &#123;                left &#x3D; middle + 1;             &#125; else            &#123;                return middle;             &#125;        &#125;                return -1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>定义target在一个左闭右开的区间里</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int low &#x3D; 0;        int high &#x3D; nums.size();         while (low &lt; high) &#123;             int middle &#x3D; low + ((high - low) &gt;&gt; 1);            if (nums[middle] &gt; target) &#123;                high &#x3D; middle;             &#125; else if (nums[middle] &lt; target) &#123;                low &#x3D; middle + 1;             &#125; else &#123;                 return middle;             &#125;        &#125;              return -1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="74-移除元素"><a href="#74-移除元素" class="headerlink" title="74.移除元素"></a>74.移除元素</h3><p><a href="https://leetcode.cn/problems/remove-element/">力扣题目链接</a></p><ul><li><p>暴力求解</p></li><li><p>双指针法：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作</p><p>快指针：寻找新数组的元素，新数组就是不含有目标元素的数组。</p><p>慢指针：指向更新新数组下标的位置。</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><p><strong>双指针法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int slowIndex &#x3D; 0;        for (int fastIndex &#x3D; 0; fastIndex &lt; nums.size(); fastIndex++) &#123;            if (val !&#x3D; nums[fastIndex]) &#123;                nums[slowIndex++] &#x3D; nums[fastIndex];            &#125;        &#125;        return slowIndex;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>相向双指针法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int leftIndex &#x3D; 0;        int rightIndex &#x3D; nums.size() - 1;        while (leftIndex &lt;&#x3D; rightIndex) &#123;            &#x2F;&#x2F; 找左边等于val的元素            while (leftIndex &lt;&#x3D; rightIndex &amp;&amp; nums[leftIndex] !&#x3D; val)&#123;                ++leftIndex;            &#125;            &#x2F;&#x2F; 找右边不等于val的元素            while (leftIndex &lt;&#x3D; rightIndex &amp;&amp; nums[rightIndex] &#x3D;&#x3D; val) &#123;                -- rightIndex;            &#125;            &#x2F;&#x2F; 将右边不等于val的元素覆盖左边等于val的元素            if (leftIndex &lt; rightIndex) &#123;                nums[leftIndex++] &#x3D; nums[rightIndex--];            &#125;        &#125;        return leftIndex;   &#x2F;&#x2F; leftIndex一定指向了最终数组末尾的下一个元素    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">力扣题目链接</a></p><p><strong>双指针法</strong></p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p><p>2</p><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">力扣题目链接</a></p><p><strong>滑动窗口</strong></p><p>不断的调节子序列的起始位置和终止位置，从而得出结果。</p><h3 id="59-螺旋矩阵"><a href="#59-螺旋矩阵" class="headerlink" title="59.螺旋矩阵"></a>59.螺旋矩阵</h3><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">力扣题目链接</a></p><p><strong>四条边要坚持左闭右开或者左开右闭的原则</strong></p><p>完整代码如下</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;        vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0)); &#x2F;&#x2F; 使用vector定义一个二维数组        int startx &#x3D; 0, starty &#x3D; 0; &#x2F;&#x2F; 定义每循环一个圈的起始位置        int loop &#x3D; n &#x2F; 2; &#x2F;&#x2F; 每个圈循环几次，例如n为奇数3，那么loop &#x3D; 1 只是循环一圈，矩阵中间的值需要单独处理        int mid &#x3D; n &#x2F; 2; &#x2F;&#x2F; 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)        int count &#x3D; 1; &#x2F;&#x2F; 用来给矩阵中每一个空格赋值        int offset &#x3D; 1; &#x2F;&#x2F; 需要控制每一条边遍历的长度，每次循环右边界收缩一位        int i,j;        while (loop --) &#123;            i &#x3D; startx;            j &#x3D; starty;            &#x2F;&#x2F; 下面开始的四个for就是模拟转了一圈            &#x2F;&#x2F; 模拟填充上行从左到右(左闭右开)            for (j &#x3D; starty; j &lt; n - offset; j++) &#123;                res[startx][j] &#x3D; count++;            &#125;            &#x2F;&#x2F; 模拟填充右列从上到下(左闭右开)            for (i &#x3D; startx; i &lt; n - offset; i++) &#123;                res[i][j] &#x3D; count++;            &#125;            &#x2F;&#x2F; 模拟填充下行从右到左(左闭右开)            for (; j &gt; starty; j--) &#123;                res[i][j] &#x3D; count++;            &#125;            &#x2F;&#x2F; 模拟填充左列从下到上(左闭右开)            for (; i &gt; startx; i--) &#123;                res[i][j] &#x3D; count++;            &#125;            &#x2F;&#x2F; 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)            startx++;            starty++;            &#x2F;&#x2F; offset 控制每一圈里每一条边遍历的长度            offset +&#x3D; 1;        &#125;        &#x2F;&#x2F; 如果n为奇数的话，需要单独给矩阵最中间的位置赋值        if (n % 2) &#123;            res[mid][mid] &#x3D; count;        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录—字符串</title>
      <link href="/2023/06/25/suan-fa-shua-ti-ji-lu-zi-fu-chuan/"/>
      <url>/2023/06/25/suan-fa-shua-ti-ji-lu-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="算法刷题记录—字符串"><a href="#算法刷题记录—字符串" class="headerlink" title="算法刷题记录—字符串"></a>算法刷题记录—字符串</h1><h3 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h3><p>关键代码：</p><p>去掉多余的空格</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void removeExtraSpaces(string&amp; s)&#123;    int slow&#x3D;0;    for(int i&#x3D;0;i&lt;s.size();++i)    &#123;        if(s[i]!&#x3D;&#39; &#39;)        &#123;            if(slow!&#x3D;0) s[slow++]&#x3D;&#39; &#39;;            while(i&lt;s.size() &amp;&amp; s[i]!&#x3D;&#39; &#39;)                s[slow++] &#x3D; s[i++];        &#125;    &#125;    s.resize(slow);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="剑指offer-58-左旋转字符串"><a href="#剑指offer-58-左旋转字符串" class="headerlink" title="剑指offer 58:左旋转字符串"></a>剑指offer 58:左旋转字符串</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string reverseLeftWords(string s,int n)&#123;    reverse(s.begin(), s.begin()+n);    reverse(s.begin()+n,s.end());    reverse(s.begin(),s.end());    return s;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p><strong>前缀表（prefix table）：记录了模式串与主串（文本串不匹配的时候，模式串应该从哪里开始匹配）</strong></p><p><strong>记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀</strong></p><h4 id="最长公共前后缀"><a href="#最长公共前后缀" class="headerlink" title="最长公共前后缀"></a>最长公共前后缀</h4><p>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</p><p>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</p><p>前缀表要求的就是相同前后缀的长度</p><h4 id="使用next数组来匹配"><a href="#使用next数组来匹配" class="headerlink" title="使用next数组来匹配"></a>使用next数组来匹配</h4><p><strong>初始化</strong></p><p>定义两个指针，j指向前缀末尾位置，i指向后缀末尾位置。</p><p><strong>处理前后缀不相同的情况</strong></p><p>遍历模式串下标j要从1开始</p><p>如果s[i] s[j+1]不相同，也就是 前后缀末尾不相同的情况，要向前回退。</p><p><strong>处理前后缀相同的情况</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(s[i] &#x3D;&#x3D; s[j+1])&#123;    j++:&#125;next[i]&#x3D;j;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>构建next数组的函数代码</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void getNext(int* next,const string&amp; s)&#123;    int j&#x3D;-1;    next[0]&#x3D;j;    for(int i&#x3D;1;i&lt;s.size();i++)&#123;        while(j&gt;&#x3D;0 &amp;&amp; s[i] !&#x3D; s[j+1])&#123;            j &#x3D; next[j];        &#125;        if(s[i] &#x3D;&#x3D; s[j+1])            j++;        next[i]&#x3D;j;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用next数组来匹配</strong></p><p>在文本串s里找是否出现过模式串t</p><p>定义两个下标</p><p>j：指向模式串起始位置（初始值为-1，因为next数组里记录的起始位       置为-1</p><p>i：指向文本串起始位置</p><p>i从0开始，遍历文本串</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i&#x3D;0;i&lt;s.size();i++)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>s[i]与t[j+1]进行比较</p><p><strong>不相同：j从next数组里寻找下一个匹配的位置</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while(j &gt;&#x3D; 0 &amp;&amp; s[i] !&#x3D; t[j+1])&#123;    j &#x3D; next[j];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>相同：i，j同时向后移动</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(s[i] &#x3D;&#x3D; t[j+1])&#123;    j++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>如果j指向了模式串t的末尾，说明已经完全匹配</strong></p><p><strong>完全匹配后，要找出文本串中模式串出现的第一个位置，所以返回</strong></p><p><strong>当前在文本串匹配模式串的位置i 减去 模式串的长度</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(j &#x3D;&#x3D; (t.size() - 1))&#123;return (i - t.size() + 1)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="前缀表统一减一代码实现"><a href="#前缀表统一减一代码实现" class="headerlink" title="前缀表统一减一代码实现"></a>前缀表统一减一代码实现</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    void getnext(int *next, const string &amp;s)&#123;        int j&#x3D;-1;        next[0]&#x3D;j;        for(int i&#x3D;1;i&lt;s.size();i++)        &#123;            while(j&gt;&#x3D;0&amp;&amp;s[i]!&#x3D;s[j+1])&#123;&#x2F;&#x2F;前后缀不同的情况                j&#x3D;next[j];&#x2F;&#x2F;回退            &#125;            if(s[i]&#x3D;&#x3D;s[j+1])&#123;&#x2F;&#x2F;前后缀相同                j++;            &#125;            next[i]&#x3D;j;&#x2F;&#x2F;j此时为前缀的长度，赋给next[i]        &#125;    &#125;        int strStr(string haystack, string needle)&#123;        if(neddle.size() &#x3D;&#x3D; 0)        &#123;            return 0;        &#125;        int next[needle,size()];        getnext(next,needle);        int j&#x3D;-1;        for(int i&#x3D;0;i&lt;haystack.size();i++)&#x2F;&#x2F;i从0开始        &#123;            while(j&gt;&#x3D;0&amp;&amp;haystack[i]!&#x3D;needle[j+1])&#x2F;&#x2F;不匹配            &#123;                j&#x3D;next[j];            &#125;            if(haystack[i] &#x3D;&#x3D; needle[j+1])&#x2F;&#x2F;匹配，同时移动            &#123;                j++;            &#125;            if(j&#x3D;&#x3D;(needle.size()-1))&#x2F;&#x2F;出现模式串            &#123;                return (i-needle.size()+1);            &#125;        &#125;        return -1;    &#125;        &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="459-重复的字符串"><a href="#459-重复的字符串" class="headerlink" title="459.重复的字符串"></a>459.重复的字符串</h3><h4 id="移动匹配"><a href="#移动匹配" class="headerlink" title="移动匹配"></a>移动匹配</h4><p>如果字符串由重复的子串组成，则s+s中必定出现一个s</p><p>其中需要用到find库函数</p><p>下面是使用方法</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20215137.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123; public:         bool repeatedSubstringPattern(string s) &#123;                 string t&#x3D;s+s;                 t.erase(t.begin());                 t.erase(t.end()-1);                        if(t.find(s)!&#x3D;std::string::npos)                     return true;                  return false;         &#125; &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="KMP解法"><a href="#KMP解法" class="headerlink" title="KMP解法"></a>KMP解法</h4><p>当一个字符串由重复子串组成，最长相等前后缀不包含的字串就是最小重复子串</p><p>假设字符串s使用多个重复字串组成，重复出现的子字符串长度是x</p><p>所以s由n*x组成</p><p>因为字符串的最长相同前后缀长度一定是不包含s本身</p><p>所以最长相同前后缀长度必然是m*x</p><p>且n-m&#x3D;1</p><p>如果nx%(n-m)x&#x3D;0</p><p>就可以判定由重复出现的字符串</p><p>如果len%(len-(next[len-1]+1))&#x3D;&#x3D;0</p><p>说明数组长度可以被（数组长度-最长相等前后缀长度）整除</p><p><strong>数组长度减去最长相同前后缀的长度相当于是一个周期的长度</strong></p><p>前缀表统一减一的代码实现</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    void getNext(int* next,string&amp; s)    &#123;        next[0]&#x3D;-1;        int j&#x3D;-1;        for(int i&#x3D;1;i&lt;s.size();i++)        &#123;            while(j&gt;&#x3D;0 &amp;&amp; s[i]!&#x3D;s[j+1])            &#123;                j&#x3D;next[j];            &#125;            if(s[i]&#x3D;&#x3D;s[j+1])            &#123;                j++;            &#125;            next[i]&#x3D;j;   bool repeatSubstringPattern(string s)   &#123;       if(s.size()&#x3D;&#x3D;0)       &#123;           return false;       &#125;       int next[s.size()-1];       int len&#x3D;s.size()-1;       getNext(next,s);       if(next[len-1]!&#x3D;-1 &amp;&amp; len%(len-(next[len-1]+1)&#x3D;&#x3D;0)          &#123;              return true;          &#125;          return false;   &#125;                        &#125;               &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录—双指针法</title>
      <link href="/2023/06/25/suan-fa-shua-ti-ji-lu-shuang-zhi-zhen-fa/"/>
      <url>/2023/06/25/suan-fa-shua-ti-ji-lu-shuang-zhi-zhen-fa/</url>
      
        <content type="html"><![CDATA[<p><strong>本文只给出代码过程，具体分析见对应类别的文章</strong></p><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int removeElement(vector&lt;int&gt;&amp; nums,int val)&#123;    int slow&#x3D;0;    for(int fast&#x3D;0;fast&lt;nums.size();fast++)    &#123;        if(val!&#x3D;nums[fast])            nums[slow++]&#x3D;nums[fast];    &#125;    return slow;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void reverseString(vector&lt;char&gt;&amp; s)&#123;    for(int i&#x3D;0,j&#x3D;s.size()-1;i&lt;s.size()&#x2F;2;i++,j--)    &#123;        swap(s[i],s[j]);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="剑指offer05-替换空格"><a href="#剑指offer05-替换空格" class="headerlink" title="剑指offer05.替换空格"></a>剑指offer05.替换空格</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string replaceSpace(string s)&#123;    int count&#x3D;0;    int oldsize&#x3D;s.size();    for(int i&#x3D;0;i&lt;s.size();i++)    &#123;        if(s[i]&#x3D;&#x3D;&#39; &#39;)            count++;    &#125;    s.resize(s.size()+count*2);    int newsize&#x3D;s.size();    for(int i&#x3D;newsize-1,j&#x3D;oldsize-1;j&lt;i;i--,j--)    &#123;        if(s[j]!&#x3D;&#39; &#39;)            s[i]&#x3D;s[j];        else&#123;            s[i]&#x3D;&#39;0&#39;;            s[i-1]&#x3D;&#39;2&#39;;            s[i-2]&#x3D;&#39;%&#39;;            i-&#x3D;2;        &#125;    &#125;    return s;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="206-翻转链表"><a href="#206-翻转链表" class="headerlink" title="206.翻转链表"></a>206.翻转链表</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode* reverseList(ListNode* head)&#123;    ListNode* temp;    ListNode* cur&#x3D;head;    ListNode* pre&#x3D;NULL;    while(cur)    &#123;        temp&#x3D;cur-&gt;next;        cur-&gt;next&#x3D;pre;        pre&#x3D;cur;        cur&#x3D;temp;    &#125;    return pre;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="19-删除链表倒数第N个结点"><a href="#19-删除链表倒数第N个结点" class="headerlink" title="19.删除链表倒数第N个结点"></a>19.删除链表倒数第N个结点</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ListNode* removeNthFromEnd(ListNode* head,int n)&#123;    ListNode* dummyhead &#x3D; new ListNode(0);    dummyhead-&gt;next&#x3D;head;    ListNode* slow&#x3D;dummyhead;    ListNode* fast&#x3D;dummyhead;    while(n-- &amp;&amp; fast!&#x3D;null)    &#123;        fast&#x3D;fast-&gt;next;    &#125;    fast&#x3D;fast-&gt;next;    while(fast!&#x3D;null)    &#123;        fast&#x3D;fast-&gt;next;        slow&#x3D;slow-&gt;next;            &#125;    slow-&gt;next&#x3D;slow-&gt;next-&gt;next;        return dummyhead-&gt;next;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题02-07-链表相交"><a href="#面试题02-07-链表相交" class="headerlink" title="面试题02.07.链表相交"></a>面试题02.07.链表相交</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    ListNode* curA &#x3D; headA;    ListNode* curB &#x3D; headB;    int lenA &#x3D; 0,lenB &#x3D; 0;    while(curA!&#x3D;null)&#123;        lenA++;        curA&#x3D;curA-&gt;next;    &#125;    while(curB!&#x3D;null)&#123;        lenB++;        curB&#x3D;curB-&gt;next;    &#125;    curA&#x3D;headA; curB&#x3D;headB;        if(lenB&gt;lenA)&#123;        swap(lenA,lenB);        swap(curA,curB);    &#125;    int gap &#x3D; lenA-lenB;    while(gap--)&#123;        curA&#x3D;curA-&gt;next;    &#125;    while(curA!&#x3D;null)&#123;        if(curA &#x3D;&#x3D; curB)            return curA;    &#125;    curA&#x3D;curA-&gt;next;    curB&#x3D;curB-&gt;next;        return null;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="142-环形链表Ⅱ"><a href="#142-环形链表Ⅱ" class="headerlink" title="142.环形链表Ⅱ"></a>142.环形链表Ⅱ</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    ListNode* fast &#x3D; head;    ListNode* slow &#x3D; head;    while(fast!&#x3D;null &amp;&amp; fast-&gt;next!+null)&#123;        slow&#x3D;slow-&gt;next;        fast&#x3D;fast-&gt;next-&gt;next;    &#125;    if(slow &#x3D;&#x3D; fast)&#123;        ListNode* index1 &#x3D; fast;        ListNode* index2 &#x3D; slow;        while(index1!&#x3D;index2)&#123;            index1 &#x3D; index1-&gt;next;            index2 &#x3D; index2-&gt;next;                        &#125;        return index2;    &#125;    return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="0015-三数之和"><a href="#0015-三数之和" class="headerlink" title="0015.三数之和"></a>0015.三数之和</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums)&#123;        vector&lt;vector&lt;int&gt;&gt; result;        sort(nums.begin(),nums.end());                for(int i&#x3D;0;i&lt;nums.size();i++)        &#123;            if(nums[i]&gt;0)                return result;            if(i&gt;0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i-1])                continue;            int left&#x3D;i+1;            int right&#x3D;nums.size()-1;            while(right&gt;left)&#123;                if(numns[i]+nums[left]+nums[right]&gt;0)                    right--;                else if(nums[i]+nums[left]+nums[right]&lt;0)                    left++;                else&#123;                    result.push_back(vector&lt;int&gt;&#123;nums[i],nums[left],nums[right]&#125;);                    while(right&gt;left &amp;&amp; nums[right] &#x3D;&#x3D; nums[right-1]) right--;                    while(right&gt;left &amp;&amp; nums[left] &#x3D;&#x3D; nums[left-1]) left++;                    right--;                    left++;                &#125;            &#125;        &#125;                            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录—二叉树</title>
      <link href="/2023/06/25/suan-fa-shua-ti-ji-lu-er-cha-shu/"/>
      <url>/2023/06/25/suan-fa-shua-ti-ji-lu-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="二叉树理论基础"><a href="#二叉树理论基础" class="headerlink" title="二叉树理论基础"></a>二叉树理论基础</h3><h4 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h4><p>满二叉树：深度为k，有2^k-1个节点</p><p>完全二叉树：除最底层节点可能没填满外，其余每层节点数都达到最大值</p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>二叉搜索树是一个有序树</p><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值</p><p>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</p><p>它的左右子树也分别为二叉排序树</p><h4 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h4><p>AVL树</p><p>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</p><p>c++中map、set、multimap、multiset的底层实现都是平衡二叉搜索树</p><h4 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h4><p>二叉树既可以链式存储，也可以顺序存储</p><p>链式存储方式就用指针，顺序存储的方式就是用数组</p><p>遍历数组存储的二叉树：左孩子是i * 2+1，右孩子是i * 2+2</p><h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h4><p>1.深度优先遍历</p><p>前序遍历（递归法，迭代法）</p><p>中序遍历（递归法，迭代法）</p><p>后序遍历（递归法，迭代法）</p><p>2.广度优先遍历</p><p>层次遍历（迭代法）</p><h4 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h4><p>链式存储</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct TreeNode&#123;    int val;    TreeNode *left;    TreeNode *right;    TreeNode(int x) : val(x),left(NULL),right(NULL)&#123;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;前序遍历class Solution&#123;public:    void traverval(TreeNode* cur, vector&lt;int&gt;&amp; vec)    &#123;        if(cur &#x3D;&#x3D; NULL) return;        vec.push_back(cur-&gt;val);        traverval(cur-&gt;left, vec);        traverval(cur-&gt;right, vec);    &#125;    vector&lt;int&gt; preorderTraverval(TreeNode* root)    &#123;        vector&lt;int&gt; result;        traverval(root, result);        return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;中序遍历void traverval(TreeNode* cur, vector&lt;int&gt;&amp; vec)     &#123;             if(cur &#x3D;&#x3D; NULL) return;                      traverval(cur-&gt;left, vec);     vec.push_back(cur-&gt;val);    traverval(cur-&gt;right, vec);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;后序遍历void traverval(TreeNode* cur, vector&lt;int&gt;&amp; vec)     &#123;             if(cur &#x3D;&#x3D; NULL) return;                      traverval(cur-&gt;left, vec);     traverval(cur-&gt;right, vec);    vec.push_back(cur-&gt;val);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    vector&lt;int&gt; preorderTraverval(TreeNode* root)    &#123;        stack&lt;TreeNode*&gt; st;        vector&lt;int&gt; result;        if(root &#x3D;&#x3D; NULL) return result;        st.push(root);        while(!st.empty)        &#123;            TreeNode* node &#x3D; st.top();            st.pop();            result.push_back(node-&gt;val);            if(node-&gt;right) st.push-&gt;back(node-&gt;right);            if(node-&gt;left) st.push_back(node-&gt;left);        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p><strong>借助指针访问结点，借助栈处理元素</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    vector&lt;int&gt; inorderTraverval(TreeNode* root)    &#123;        vector&lt;int&gt; result;        stack&lt;int&gt; st;        TreeNode* cur &#x3D; root;        while(cur !&#x3D; NULL || !st.empty())        &#123;            if(cur !&#x3D; NULL)            &#123;                st.push(cur);                cur &#x3D; cur-&gt;left;            &#125;            else&#123;                cur &#x3D; st.top();                st.pop();                result.push_back(cur-&gt;val);                cur &#x3D; cur-&gt;right;            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    vector postorderTraverval(TreeNode* root)    &#123;        vector&lt;int&gt; result;        stack&lt;int&gt; st;        if(root &#x3D;&#x3D; NULL) return result;       st.push(root);        while(!st.empty())        &#123;            TreeNode* node &#x3D; st.top();            st.pop();            result.push_back(node-&gt;val);            if(node-&gt;left) st.push_back(node-&gt;val);            if(node-&gt;right) st.push_back(node-&gt;val);        &#125;        reverese(result.begin(), result.end());        return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树的统一迭代法"><a href="#二叉树的统一迭代法" class="headerlink" title="二叉树的统一迭代法"></a>二叉树的统一迭代法</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    vector&lt;int&gt; inorderTraverval(TreeNode* root)    &#123;        vector&lt;int&gt; result;        stack&lt;TreeNode*&gt; st;        if(root &#x3D;&#x3D; NULL) return result;        st.push(root);        while(!st.empty())        &#123;            TreeNode* node &#x3D; st.top();            if(node !&#x3D; NULL)            &#123;                st.pop();                if(node-&gt;right) st.push(node-&gt;right);&#x2F;&#x2F;右结点入栈                                st.push(node);&#x2F;&#x2F;下一个要访问的结点入栈                st.push(NULL);                                if(node-&gt;left) st.push(node-&gt;left);&#x2F;&#x2F;左结点入栈                                            &#125;            else&#123; &#x2F;&#x2F;当遇到空结点时                st.pop(); &#x2F;&#x2F;弹出空结点                node &#x3D; st.pop(); &#x2F;&#x2F;保存当前结点                st.pop();                result.push_back(node-&gt;val); &#x2F;&#x2F;空结点后的结点值加入结果集            &#125;            return result;        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前序遍历和后序遍历仅需改变三行代码的顺序即可实现</p><h3 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h3><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root)    &#123;        queue&lt;TreeNode*&gt; que;        vector&lt;vector&lt;int&gt;&gt; result;        if(node &#x3D;&#x3D; NULL) return result;        que.push(root);        while(!que.empty())        &#123;            int size &#x3D; que.size(); &#x2F;&#x2F;使用固定大小的size            vector&lt;int&gt; vec;            for(int i&#x3D;0;i &lt; size;i++)            &#123;                TreeNode* node &#x3D; que.front();                que.pop();                vec.push_back(node-&gt;val);                if(node-&gt;left) que.push(node-&gt;left);                if(node-&gt;right) que.push(node-&gt;right);            &#125;            result.push_back(vec);        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;递归法class Solution&#123;public:    void order(TreeNode* cur, vector&lt;int&gt;&lt;int&gt;&amp; result, int depth)    &#123;        if(cur &#x3D;&#x3D; NULL) return;        if(result.size()&#x3D;&#x3D;depth) result.push_back(vector&lt;int&gt;());        result[depth].push_back(cur-&gt;val);        order(cur-&gt;left, result, depth+1);        order(cur-&gt;right, result, depth+1);    &#125;    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root)    &#123;        vector&lt;vector&lt;int&gt;&gt; result;        int depth &#x3D; 0;        order(root, result, depth);        return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="107-二叉树的层次遍历II"><a href="#107-二叉树的层次遍历II" class="headerlink" title="107.二叉树的层次遍历II"></a>107.二叉树的层次遍历II</h3><p> 在层次遍历的基础上将result反转</p><h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199.二叉树的右视图"></a>199.二叉树的右视图</h3><p>当每层遍历到结尾时，将结点的值放入结果集中</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    vector&lt;int&gt; rightsideView(TreeNode* root)    &#123;        queue&lt;TreeNode*&gt; que;        vector&lt;int&gt; result;        if(root &#x3D;&#x3D; NULL) return result;        que.push(root);        while(!que.empty())        &#123;            int size &#x3D; que.size();            for(int i&#x3D;0;i &lt; size;i++)            &#123;                TreeNode* node &#x3D; que.front();                que.pop();                if(i &#x3D;&#x3D; size - 1) result.push_back(node-&gt;val);                if(node-&gt;left) que.push(node-&gt;left);                if(node-&gt;right) que.push(node-&gt;right);            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637.二叉树的层平均值"></a>637.二叉树的层平均值</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    vector&lt;double&gt; averageOfLevel(TreeNode* root)    &#123;        queue&lt;TreeNode*&gt; que;        vector&lt;double&gt; result;        if(root &#x3D;&#x3D; NULL) return result;        que.push(root);        while(!que.empty())        &#123;            int size &#x3D; que.size();            double sum &#x3D; 0;            for(int i&#x3D;0;i&lt;size;i++)            &#123;                TreeNode* node &#x3D; que.front();                que.pop();                sum +&#x3D; node-&gt;val;                if(node-&gt;left) que.push(node-&gt;left);                if(node-&gt;right) que.push(node-&gt;right);            &#125;            result.push_back(sum&#x2F;size);        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429.N叉树的层序遍历"></a>429.N叉树的层序遍历</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root)    &#123;        queue&lt;Node*&gt; que;        vector&lt;vector&lt;int&gt;&gt; result;        if(root !&#x3D; NULL)( que.push(root);        while(!que.empty())                         &#123;                             int size &#x3D; que.size();                             vector&lt;int&gt; vec;                             for(int i&#x3D;0;i&lt;size;i++)                             &#123;                                 Node* node &#x3D; que.front();                                 que.pop();                                 vec.push_back(node-&gt;val);                                 for(int i&#x3D;0;i&lt;node-&gt;children.size();i++)                                 &#123;                                     if(node-&gt;childrem[i]) que.push(node-&gt;children[i]);                                 &#125;                                                              &#125;                             result.push_back(vec);                         &#125;                         return result;    &#125;                         &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515.在每个树行中找最大值"></a>515.在每个树行中找最大值</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    vector&lt;int&gt; largestValue(TreeNode* root)    &#123;        vector&lt;int&gt; result;        queue&lt;int&gt; que;        int maxx &#x3D; INT_MIN;        if(root !&#x3D; NULL) que.push(root);        while(!que.empty())        &#123;            int size &#x3D; que.size();            for(int i&#x3D;0;i &lt; size;i++)            &#123;                TreeNode* node &#x3D; que.front();                que.pop();                max &#x3D; mode-&gt;val &gt; max ? max : val;                if(node-&gt;right) que.push(node-&gt;right);                if(node-&gt;left) que.push(node-&gt;left);                            &#125;            result.push_back(max);        &#125;        return result;            &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116.填充每个节点的下一个右侧节点指针"></a>116.填充每个节点的下一个右侧节点指针</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    Node* connect(Node* root)    &#123;        queue&lt;Node*&gt; que;        if(root !&#x3D; NULL) que.push(root);        Node* nodepre;        Node* node;        while(!que.empty())        &#123;            int size &#x3D; que.size();            for(int i&#x3D;0;i &lt; size;i++)            &#123;                if(i &#x3D;&#x3D; 0)                &#123;                    nodepre &#x3D; que.front();                    que.pop();                    node &#x3D; nodepre;                &#125;                else                &#123;                    node &#x3D; que.front();                    que.pop();                    nodepre-&gt;next &#x3D; node;                    nodepre &#x3D; nodepre-&gt;next;                &#125;                if(node-&gt;right) que.push(node-&gt;right);                if(node-&gt;left) que.push(node-&gt;left);            &#125;            nodepre-&gt;next &#x3D; NULL;        &#125;        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="117-填充每个节点的下一个右侧节点指针Ⅱ"><a href="#117-填充每个节点的下一个右侧节点指针Ⅱ" class="headerlink" title="117.填充每个节点的下一个右侧节点指针Ⅱ"></a>117.填充每个节点的下一个右侧节点指针Ⅱ</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    Node* connect(Node* root) &#123;        queue&lt;Node*&gt; que;        if (root !&#x3D; NULL) que.push(root);        while (!que.empty()) &#123;            int size &#x3D; que.size();                       Node* nodePre;            Node* node;            for (int i &#x3D; 0; i &lt; size; i++) &#123;                if (i &#x3D;&#x3D; 0) &#123;                    nodePre &#x3D; que.front(); &#x2F;&#x2F; 取出一层的头结点                    que.pop();                    node &#x3D; nodePre;                &#125; else &#123;                    node &#x3D; que.front();                    que.pop();                    nodePre-&gt;next &#x3D; node; &#x2F;&#x2F; 本层前一个节点next指向本节点                    nodePre &#x3D; nodePre-&gt;next;                &#125;                if (node-&gt;left) que.push(node-&gt;left);                if (node-&gt;right) que.push(node-&gt;right);            &#125;            nodePre-&gt;next &#x3D; NULL; &#x2F;&#x2F; 本层最后一个节点指向NULL        &#125;        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="104-二叉树最大深度"><a href="#104-二叉树最大深度" class="headerlink" title="104.二叉树最大深度"></a>104.二叉树最大深度</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    int maxDepth(TreeNode* root)    &#123;        queue&lt;TreeNode*&gt; que;        int depth &#x3D; 0;        if(root !&#x3D; NULL) que.push(root);        while(!que.empty())        &#123;            int size &#x3D; que.size();            depth++;            for(int i&#x3D;0;i &lt; size;i++)            &#123;                TreeNode* node &#x3D; que.front();                que.pop();                if(node-&gt;right) que.push(node-&gt;right);                if(node-&gt;left) que.push(node-&gt;left);            &#125;                    &#125;        return depth;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int minDepth(TreeNode* root) &#123;        queue&lt;TreeNode*&gt; que;        int depth &#x3D; 0;        if(root !&#x3D; NULL) que.push(root);        while(!que.empty())        &#123;            int size &#x3D; que.size();            depth++;            for(int i&#x3D;0;i &lt; size;i++)            &#123;                TreeNode* node &#x3D; que.front();                que.pop();                if(!node-&gt;right &amp;&amp; !node-&gt;left) return depth;                if(node-&gt;right) que.push(node-&gt;right);                if(node-&gt;left) que.push(node-&gt;left);            &#125;        &#125;        return depth;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="226-反转二叉树"><a href="#226-反转二叉树" class="headerlink" title="226.反转二叉树"></a>226.反转二叉树</h3><p><strong>递归法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    TreeNode* invertTree(TreeNode* root)&#123;        if(root &#x3D;&#x3D; NULL) return root;        swap(root-&gt;left, root-&gt;right);        invertTree(root-&gt;right);        invertTree(root-&gt;left);        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>迭代法</strong></p><p><strong>深度优先遍历</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    TreeNode* invertTree(TreeNode* root)    &#123;        if(root &#x3D;&#x3D; NULL) return root;        stack&lt;TreeNode*&gt; st;        st.push(root);        while(!st.empty())        &#123;            TreeNode* node &#x3D; st.top();            st.pop();            swap(node-&gt;left, node-&gt;right);            if(node-&gt;right) st.push(node-&gt;right);            if(node-&gt;left) st.push(node-&gt;left);                    &#125;        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>广度优先遍历</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    TreeNode* invertTree(TreeNode* root)    &#123;        queue&lt;TreeNode*&gt; que;        if(root !&#x3D; NULL) que.push(root);        while(!que.empty())        &#123;            int size &#x3D; que.size();            for(int i&#x3D;0;i &lt; size;i++)            &#123;                TreeNode* node &#x3D; que.front();                que.pop();                swap(node-&gt;left, node-&gt;right);                if(node-&gt;left) que.push(node-&gt;left);                if(node-&gt;right) que.push(node-&gt;right);            &#125;        &#125;        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h3><p>递归法</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution&#123;public:    bool compare(TreeNode* left, TreeNode* right)    &#123;        if(left !&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL) return false;        else if(left &#x3D;&#x3D; NULL &amp;&amp; right !&#x3D; NULL) return false;        else if(left &#x3D;&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL) return true;        else if(left-&gt;val !&#x3D; right-&gt;val) return false;                bool outside &#x3D; compare(left-&gt;left, right-&gt;right);        bool inside &#x3D; compare(left-&gt;right, right-&gt;left);        bool isSame &#x3D; outside &amp;&amp; inside;        return isSame;    &#125;    bool isSysmmetric(TreeNode* root)    &#123;        if(root &#x3D;&#x3D; NULL) return true;        return compare(root-&gt;left, root-&gt;right);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录-哈希表</title>
      <link href="/2023/06/25/suan-fa-shua-ti-ji-lu-ha-xi-biao/"/>
      <url>/2023/06/25/suan-fa-shua-ti-ji-lu-ha-xi-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="算法刷题记录-哈希表"><a href="#算法刷题记录-哈希表" class="headerlink" title="算法刷题记录-哈希表"></a>算法刷题记录-哈希表</h1><h3 id="哈希表理论基础"><a href="#哈希表理论基础" class="headerlink" title="哈希表理论基础"></a>哈希表理论基础</h3><p><strong>哈希函数 hash function</strong><br>$$<br>index &#x3D; hashFunction(name)<br>$$</p><p>$$<br>hashFunction &#x3D; hashCode(name)%tablesize<br>$$</p><p><strong>哈希碰撞的通常解决方法</strong>：</p><p><strong>拉链法和线性探测法</strong></p><h4 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h4><ul><li><p>数组</p></li><li><p>set</p></li><li><p>map</p></li></ul><p>unordered_set&#x2F;unordered_map底层实现为哈希表，set&#x2F;map和multiset&#x2F;multimap底层实现是红黑树，key值是有序的，只能删除和增加。</p><p>要使用集合解决哈希问题时，优先使用unordered_set，因为它的查询增删效率最优。</p><p>如果需要集合是有序的 ，那么就用set。</p><p>如果不仅要求有序还要有重复数据的话，那么就用multiset.</p><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><p><a href="https://leetcode.cn/problems/valid-anagram/">力扣题目链接</a></p><p>利用s[i]-‘a’来确定字母在数组中的位置。</p><h3 id="1002-查找常用字符"><a href="#1002-查找常用字符" class="headerlink" title="1002.查找常用字符"></a>1002.查找常用字符</h3><p><a href="https://leetcode.cn/problems/find-common-characters/">力扣题目链接</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;string&gt; commonChars(vector&lt;string&gt;&amp; A)&#123;    vector&lt;string&gt; result;    if(A.size()&#x3D;&#x3D;0) return result;    int hash[26]&#x3D;&#123;0&#125;;    for(int i&#x3D;0;i&lt;A[0].size();i++)&#123;        hash[A[0][i]-&#39;a&#39;]++;    &#125;    int hashOtherStr[26]&#x3D;&#123;0&#125;;    for(int i&#x3D;1;i&lt;A.size(),i++)&#123;        memset(hashOtherStr,0,26*sizeof(int));        for(int j&#x3D;0;j&lt;A[i].size();j++)&#123;            hashOtherStr[A[i][j]-&#39;a&#39;]++;        &#125;        for(int k&#x3D;0;k&lt;26;k++)&#123;            hash[k]&#x3D;min(hash[k],hashOtherStr[k]);        &#125;    &#125;    for(int i&#x3D;0;i&lt;26;i++)&#123;        while(hash[i]!&#x3D;0)&#123;            string s(1,i+&#39;a&#39;);            result.push_back(s);            hash[i]--;        &#125;    &#125;    return result;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349.两个数组的交集"></a>349.两个数组的交集</h3><p>使用unordered_set</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1,vector&lt;int&gt;&amp; nums2)&#123;    unordered_set result;    unordered_set nums(nums1.begin(),nums1.end())        for(int num:nums2)&#123;            if(nums.find(num)!&#x3D;nums.end())            &#123;                result.insert(num);            &#125;        &#125;    return vector&lt;int&gt;(result.begin(),result.end());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202.快乐数"></a>202.快乐数</h3><p>当我们要快速判断一个元素是否出现在集合中时，可以考虑哈希法。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int getsum(int n)&#123;    int sum&#x3D;0;    while(n)&#123;        sum+&#x3D;(n%10)*(n%10);        n&#x2F;&#x3D;10;    &#125;&#125;bool ishappy(int n)&#123;    unordered_set&lt;int&gt; set;    while(1)&#123;        int sum &#x3D; getsum(n);        if(sum&#x3D;&#x3D;1) return true;        if(set.find(sum)!&#x3D;set.end())&#123;            return false;        &#125;else&#123;            set.insert(sum);        &#125;        n&#x3D;sum;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::unordered_map map;for(int i&#x3D;0;i&lt;nums.size(),i++)&#123;    auto iter&#x3D;map.find(target&#x3D;nums[i]);    if(iter!&#x3D;map.end())    &#123;        return &#123;iter-&gt;second,i&#125;;    &#125;    map.insert(pair&lt;int,int&gt;(nums[i],i));&#125;return &#123;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="454-四数相加Ⅱ"><a href="#454-四数相加Ⅱ" class="headerlink" title="454.四数相加Ⅱ"></a>454.四数相加Ⅱ</h3><p>首先定义一个unordered_map，key放ab两数之和，value放出现次数。</p><p>遍历AB两数组，统计两数组元素之和和出现的次数。</p><p>遍历CD数组，找到如果0-(c+d)在map中出现过的话，统计次数。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int foursumcount(vector&lt;int&gt;&amp;A ,vector&lt;int&gt;&amp;B, vector&lt;int&gt;&amp;C ,vector&lt;int&gt;&amp;D)&#123;    unordered_map&lt;int,int&gt; map;    for(int a:A)    &#123;        for(int b:B)        &#123;            map[a+b]++;        &#125;                &#125;    int count&#x3D;0;    for(int c:C)    &#123;        for(int d:D)        &#123;            if(map.find(0-(c+d))!&#x3D;map.end())            &#123;                count+&#x3D;map[0-(c+d)];            &#125;                    &#125;    &#125;    return count;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool canConstruct(string ransomNote, string magazine)&#123;    int record[26]&#x3D;&#123;0&#125;;    if(ransomNote.size()&gt;magazine.size())        return false;    for(int i&#x3D;0;i&lt;magazine.size();i++)    &#123;        record[magazine[i]-&#39;a&#39;]++;    &#125;    for(int j&#x3D;0;j&lt;ransomNote.size();j++)    &#123;        record[ransomNote[j]-&#39;a&#39;]--;        if(record[ransomNote[j]-&#39;a&#39;]&lt;0)            return false;    &#125;    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums)&#123;    vector&lt;vector&lt;int&gt;&gt; result;    sort(nums.begin(),nums.end());    for(int i&#x3D;0;i&lt;nums.size();i++)    &#123;        if(nums[i]&gt;0) break;        if(i&gt;0 &amp;&amp; nums[i]&#x3D;&#x3D;nums[i-1]) contunue;        unordered_set&lt;int&gt; set;        for(int j&#x3D;i+1;j&lt;nums.size();j++)&#123;            if(j&gt;i+2&amp;&amp;nums[j]&#x3D;&#x3D;nums[j-1]&amp;&amp;nums[j-1]&#x3D;&#x3D;nums[j-2])                contunue;            int c&#x3D;0-(nums[i]+nums[j]);            if(set.find(c)!&#x3D;set.end())&#123;                result.push_back(&#123;nums[i],nums[j],c&#125;);                set.erese(c);            &#125;else&#123;                set.insert(nums[j]);            &#125;        &#125;    &#125;    return result;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>双指针法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums)&#123;    vector&lt;vector&lt;int&gt;&gt; result;    sort(nums.begin(),nums.end());    for(int i&#x3D;0;i&lt;nums.size();i++)    &#123;        if(nums[i]&gt;0&amp;&amp;i&#x3D;0) return result;        if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1]) continue;            &#125;    int left&#x3D;i+1;    int right&#x3D;nums.size()-1;    while(right&gt;left)    &#123;        if(nums[i]+nums[left]+nums[right]&gt;0) right--;        else if(nums[i]+nums[left]+nums[right]&lt;0) left++;        else&#123;            result.push_back(vector&lt;int&gt;&#123;nums[i],nums[left],nums[right]&#125;);            whlie(right&gt;left &amp;&amp; nums[right]&#x3D;&#x3D;nums[right-1]) right--;            whlie(right&gt;left &amp;&amp; nums[left]&#x3D;&#x3D;nums[left++]) left++;                        right--;            left++;                    &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题记录-动态规划</title>
      <link href="/2023/06/25/suan-fa-shua-ti-ji-lu-dong-tai-gui-hua/"/>
      <url>/2023/06/25/suan-fa-shua-ti-ji-lu-dong-tai-gui-hua/</url>
      
        <content type="html"><![CDATA[<h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><h4 id="什么是动态规划（Dynamic-Programming）"><a href="#什么是动态规划（Dynamic-Programming）" class="headerlink" title="什么是动态规划（Dynamic Programming）"></a>什么是动态规划（Dynamic Programming）</h4><p>动态规划用于解决有很多子问题的问题</p><p>动态规划中每一个状态一定是由上一个状态推导出来的</p><h4 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h4><p>1.确定dp数组以及下标的含义</p><p>2.确定递推公式</p><p>3.dp数组如何初始化</p><p>4.确定遍历顺序</p><p>5.举例推导dp数组</p><h3 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509.斐波那契数"></a>509.斐波那契数</h3><p><strong>动态规划</strong></p><p>1.确定dp数组以及下标的含义</p><p>dp[i]的定义是：第i个数的斐波那契数值是dp[i]</p><p>2.确定递推公式</p><p><strong>状态转移方程 dp[i] &#x3D; dp[i-1] + dp[i-2]</strong></p><p>3.dp数组如何初始化</p><p>本题初始化条件 dp[0]&#x3D;0, dp[1]&#x3D;1</p><p>4.确定遍历顺序</p><p>dp[i]依赖dp[i-1], dp[i-2]</p><p>那么遍历的顺序一定是从前向后遍历的</p><p>5.举例推导dp数组</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int fib(int n)&#123;    if(n&lt;&#x3D;1) return n;    vector&lt;int&gt; dp(n+1);    dp[0]&#x3D;0; dp[1]&#x3D;1;    for(int i&#x3D;1;i&lt;&#x3D;n;i++)    &#123;        dp[i] &#x3D; dp[i-1]+dp[i-2];    &#125;    return dp[n];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h3><p>1.确定dp数组以及下标的含义</p><p>dp[i]:爬到第i层楼梯由dp[i]种方法</p><p>2.确定递推公式</p><p>若要上到第i阶台阶，最后一步一定是从第i-1阶或第i-2阶上到第i阶</p><p>那么可知</p><p>递推公式为dp[i] &#x3D; dp[i-1] dp[i-2]</p><p>3.dp数组如何初始化</p><p>dp[1] &#x3D; 1</p><p>dp[2] &#x3D; 2</p><p>4.确定遍历顺序</p><p>从前向后</p><p>5.举例推导dp数组</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int climbStairs(int n)&#123;    if(n &lt;&#x3D; 1) return n;    vector&lt;int&gt; dp(n+1);    dp[1] &#x3D; 1;    dp[2] &#x3D; 2;    for(int i&#x3D;3;i&lt;&#x3D;n;i++)    &#123;        dp[i] &#x3D; dp[i-1] - dp[i-2];    &#125;    return dp[n];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746.使用最小花费爬楼梯"></a>746.使用最小花费爬楼梯</h3><p>1.确定dp数组以及下标的含义</p><p>到达第i台阶所花费最少体力为dp[i]</p><p>2.确定递推公式</p><p>dp[i] &#x3D; min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])</p><p>3.dp数组初始化</p><p>dp[0] &#x3D; 0</p><p>dp[1] &#x3D; 0</p><p>4.确定遍历顺序</p><p>5.举例推导dp数组</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int minCostClimbingStairs(vecror&lt;int&gt;&amp; cost)&#123;    vector&lt;int&gt; dp(cost,size());    dp[0] &#x3D; 0;    dp[1] &#x3D; 0;    for(int i&#x3D;2;i&lt;cost.size();i++)    &#123;        dp[i] &#x3D; min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]);    &#125;    return dp[cost.size()];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h3><p>1.确定dp数组以及下标含义</p><p>从（0，0）出发，到（i，j）的路径数</p><p>2.确定递推公式</p><p>dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]</p><p>3.dp数组初始化</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i&#x3D;0;i&lt;m;i++) dp[i][0] &#x3D; 1;for(int j&#x3D;0;j&lt;n;j++) dp[0][j] &#x3D; 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>4.确定遍历顺序</p><p>从左至右一层一层遍历</p><p>5.举例推导</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int uniquePath(int m, int n)&#123;    vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n, 0));    for(int i&#x3D;0;i&lt;m;i++) dp[i][0] &#x3D; 1;    for(int j&#x3D;0;j&lt;n;j++) dp[0][j] &#x3D; 1;    for(int i&#x3D;1;i&lt;m;i++)    &#123;        for(int j&#x3D;1;j&lt;n;j++)        &#123;            dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];        &#125;        return dp[m-1][n-1];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="63-不同路径Ⅱ"><a href="#63-不同路径Ⅱ" class="headerlink" title="63.不同路径Ⅱ"></a>63.不同路径Ⅱ</h3><p>1.确定dp数组以及下标含义</p><p>含义与上一题相同</p><p>2.确定递推公式</p><p>如果有障碍，路径数应为0</p><p>3.dp数组初始化</p><p>与上一题类似，障碍前的路径数都为1，障碍后的都为0</p><p>4.确定遍历顺序</p><p>从左到右一层一层遍历</p><p>5.举例推导dp数组</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid)&#123;    int m &#x3D; obstacleGrid.size();    int n &#x3D; obstacleGrid[0].size();    if (obstacleGrid[m - 1][n - 1] &#x3D;&#x3D; 1 || obstacleGrid[0][0] &#x3D;&#x3D; 1) &#x2F;&#x2F;如果在起点或终点出现了障碍，直接返回0                return 0;        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n,0));    for(int i&#x3D;0;i&lt;m &amp;&amp; obstacleGrid[i][0]&#x3D;&#x3D;0;i++) dp[i][0] &#x3D; 1;    for(int j&#x3D;0lj&lt;n &amp;&amp; obstacleGrid[0][j]&#x3D;&#x3D;0;j++) dp[0][j] &#x3D; 1;    for(int i&#x3D;1;i&lt;m;i++)    &#123;        for(int j&#x3D;1;j&lt;n;j++)        &#123;            if(obstacleGrid[i][j]&#x3D;&#x3D;1) contine;            dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];        &#125;    &#125;    return dp[m-1][n-1];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343.整数拆分"></a>343.整数拆分</h3><ol><li></li></ol><p>2.确定递推公式</p><p>从1遍历j，有两种渠道得到dp[i]</p><p>一个是j*(i-j)直接相乘</p><p>一个是j*dp[i-j],相当于拆分(i-j)</p><p>3.dp初始化</p><p>dp[2] &#x3D; 1</p><p>4.确定遍历顺序</p><p>从前向后</p><p>5.举例推导</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int integerBreak(int n)&#123;    vector&lt;int&gt; dp(n+1);    dp[2] &#x3D; 1;    for(int i&#x3D;3;i&lt;&#x3D;n;i++)    &#123;        for(int j&#x3D;1;j&lt;&#x3D;i&#x2F;2;j++)        &#123;            dp[i]&#x3D;max(dp[i],max((i-j)*j, dp[i-j]*j));&#125;    &#125;    return dp[n];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="01背包理论基础"><a href="#01背包理论基础" class="headerlink" title="01背包理论基础"></a>01背包理论基础</h3><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p>有n件物品和一个最多能背重量为w的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。每件物品只能使用一次，求解将哪些物品装入背包里价值总和最大。</p><h4 id="二维dp数组01背包"><a href="#二维dp数组01背包" class="headerlink" title="二维dp数组01背包"></a>二维dp数组01背包</h4><p>1.确定dp数组以及下标含义</p><p><strong>dp[i] [j]表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong></p><p>2.确定递推公式</p><p>可以有两个方向推出dp[i] [j]</p><p><strong>不放物品i：</strong>由dp[i-1] [j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i] [j]就是dp[i-1] [j]。</p><p><strong>放物品i：</strong>由dp[i-1] [j-weight[i]]推出，**dp[i-1] [j-weight[i]]<strong>为背包容量为</strong>j-weight[i]<strong>的时候不放物品i的最大价值，那么</strong>dp[i-1] [j-weight[i]+value[i]]**，就是背包放物品i得到的最大价值。</p><p>所以递推公式为</p><p><strong>dp[i] [j] &#x3D; max(dp[i-1] [j], dp[i-1] [j-weight[i]]+value[i])</strong></p><p>3.dp数组如何初始化</p><p>背包容量j为0的话，即dp[i] [0]，无论选取哪些物品，背包价值总和一定为0</p><p>当i为零时</p><p>j&lt;weight[0]时，dp[0] [j]应该是0</p><p>当j &gt;&#x3D; weight[0]时，dp[0] [j]应该是value[0]</p><p>4.确定遍历顺序</p><p>先遍历物品或者先遍历背包都可以</p><p>先遍历物品的代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i&#x3D;1;i&lt;weight.size();i++)&#123;    for(int j&#x3D;0;j &lt;&#x3D; bagweight;j++)    &#123;        if(j&lt;weight)            dp[i][j] &#x3D; dp[i-1][j];                else            dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i]);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先遍历背包的代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int j&#x3D;0;j &lt;&#x3D; bagweight;j++)&#123;    for(int i&#x3D;1;i &lt; weight.size();i++)    &#123;        if(j &lt; weight[i])            dp[i][j] &#x3D; dp[i-1][j];        else            dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i]);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完整代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void bag01()&#123;    vector&lt;int&gt; weight &#x3D; &#123;1,3,4&#125;;    vector&lt;int&gt; value &#x3D; &#123;15,20,30&#125;;    int bagweight &#x3D;  4;        vector&lt;vector&lt;int&gt;&gt; dp(weight.size(), vector&lt;int&gt;(bagweight + 1, 0));        for(int j &#x3D; weight[0];j &lt;&#x3D; bagweight;j++)    &#123;        dp[0][j] &#x3D; value[0];    &#125;        for(int i&#x3D;1;i&lt;weight.size();i++)    &#123;        for(int j&#x3D;0;j&lt;&#x3D;bagweight;j++)        &#123;         if(j &lt; weight[i])                   dp[i][j] &#x3D; dp[i-1][j];            else                dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i]);        &#125;    &#125;    cout&lt;&lt;dp[weight.size() - 1][bagweight]&lt;&lt;endl;&#125;int main()&#123;    bag01();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="01背包理论基础（滚动数组）"><a href="#01背包理论基础（滚动数组）" class="headerlink" title="01背包理论基础（滚动数组）"></a>01背包理论基础（滚动数组）</h3><h4 id="一维dp数组（滚动数组）"><a href="#一维dp数组（滚动数组）" class="headerlink" title="一维dp数组（滚动数组）"></a>一维dp数组（滚动数组）</h4><p> 如果把dp[i-1]那一层拷贝到dp[i]上，表达式可以是：dp[i] [j] &#x3D; max(dp[i] [j], dp[i] [j - weight[i]] + value[i])</p><p>可以直接改为一个一维数组</p><p>1.确定dp数组的定义 </p><p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p><p>2.一维数组的递推公式</p><p>dp[j]为容量为j的背包所背的最大价值</p><p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值</p><p>dp[j - weight[i]] + value[i]表示容量为j - 物品i重量的背包 + 物品i的价值</p><p>即 容量为j的背包，放入了物品i了之后的价值即：dp[j]</p><p>此时，dp[j]有两个选择，</p><p>一个是 不放物品i，值取自己，相当于dp[i-1] [j]</p><p>一个是 放入物品i，值取dp[j - weight[i]] + value[i]</p><p>递推公式为</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.一维dp数组如何初始化</p><p>dp[0] &#x3D; 0</p><p>dp数组在推导的时候一定是取价值最大的数，要比题目给的价值小，这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖</p><p>4.一维dp数组遍历顺序</p><p><strong>一维dp遍历背包应该从大到小遍历（倒序遍历）</strong></p><p>在二维数组中，右下角的值依赖上一层左上角的值，因此需要保证左边的值仍是上一层的，从右向左覆盖</p><p><strong>倒序遍历保证物品i只被放入一次</strong></p><p><strong>必须先遍历物品再遍历背包容量</strong></p><p>如果背包遍历放在上一层，那么每个dp[j]就只会放入一个物品</p><p>5.举例推导</p><p>完整代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void bag01_Onedimensional()&#123;    vector&lt;int&gt; weight &#x3D; &#123;1,3,4&#125;;    vector&lt;int&gt; value - &#123;15,20,30&#125;;    int bagweight &#x3D; 4;        vector&lt;int&gt; dp(bagweight +1,0);    for(int i&#x3D;0;i &lt; weight.size();i++)    &#123;        for(int j&#x3D;bagweight;j &gt;&#x3D; weight[i];j--)        &#123;            dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);        &#125;    &#125;    cout&lt;&lt;dp[bagweight]&lt;&lt;endl;&#125;int main()&#123;    baag01_Onedimensional();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言（第三版）王爽—第四章</title>
      <link href="/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-di-si-zhang/"/>
      <url>/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-di-si-zhang/</url>
      
        <content type="html"><![CDATA[<h1 id="4-3编辑源程序"><a href="#4-3编辑源程序" class="headerlink" title="4.3编辑源程序"></a>4.3编辑源程序</h1><p>（1）进入DOS，运行edit</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20190805.png"></p><p>（2）在edit中编辑程序</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20191012.png"></p><p>（3）将程序保存为c:\1.asm后退出edit</p><h1 id="4-4编译"><a href="#4-4编译" class="headerlink" title="4.4编译"></a>4.4编译</h1><p><strong>（1）进入DOS，c:\masm，运行masm.exe</strong></p><p>默认文件扩展名为ASM，如果源程序不是以asm为扩展名，就要输入它的全名</p><p>输入文件名时还要指明路径</p><p><strong>（2）输入源程序文件名后，系统提示输入目标文件名</strong></p><p>默认目标文件名与源程序名相同</p><p>也可指定目标文件所在的目录</p><p><strong>（3）忽略列表文件和交叉引用文件的生成</strong></p><p><strong>（4）对源程序的编译结束</strong></p><p>最后两行提示我们无警告和必须要改正的错误</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20191453.png"></p><p>编译过程中，我们提供了一个输入，即源程序文件。</p><p>最多可得到三个输出文件：目标文件(.obj)，列表文件(.lst)，交叉引用文件(.crf)</p><h1 id="4-5连接"><a href="#4-5连接" class="headerlink" title="4.5连接"></a>4.5连接</h1><p>  对源程序进行编译得到目标文件后，我们需要对目标文件进行连接，从而得到可执行文件</p><p>（1）进入DOS，运行link</p><p>（2）输入目标文件名</p><p>（3）忽略可执行文件名，忽略映像生成文件</p><p>（4）连接程序提示输入库文件的名称，这里直接忽略</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20192525.png"></p><p><strong>连接的作用</strong></p><p>（1）连接多个源程序</p><p>（2）连接库文件和目标文件</p><h1 id="4-6以简化的方式进行编译和连接"><a href="#4-6以简化的方式进行编译和连接" class="headerlink" title="4.6以简化的方式进行编译和连接"></a>4.6以简化的方式进行编译和连接</h1><p><strong>简化的编译：</strong></p><p>masm + 源程序文件的路径和文件名，并在结尾加上分号</p><p>过程中自动忽略中间文件的生成</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20193339.png" alt="简化编译"></p><p><strong>简化的连接：</strong></p><p>link + 目标文件的路径和文件名，并在结尾加上分号</p><p>过程中自动忽略中间文件的生成</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20193554.png" alt="简化连接"></p><h1 id="4-9程序执行过程的跟踪"><a href="#4-9程序执行过程的跟踪" class="headerlink" title="4.9程序执行过程的跟踪"></a>4.9程序执行过程的跟踪</h1><p>输入debug 1.exe跟踪程序的执行</p><p>使用R命令查看各个寄存器的设置情况</p><p>cx中存放的是程序的长度</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20200013.png" alt="debug的过程"></p><p><strong>DOS系统中.exe文件的加载</strong></p><p>找到一段起始地址SA:1000</p><p>在这段内存的前256个字节中，创建一个程序段前缀(PSP)</p><p>从这段内存区的256字节处开始，将程序装入，地址为SA+10H:0</p><p>将段地址存入ds中，初始化其它相关寄存器后，设置CS:IP指向程序的入口</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言（第三版）王爽—实验4</title>
      <link href="/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-si/"/>
      <url>/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-si/</url>
      
        <content type="html"><![CDATA[<h1 id="BX-和loop的使用"><a href="#BX-和loop的使用" class="headerlink" title="[BX]和loop的使用"></a>[BX]和loop的使用</h1><h3 id="（1）编程，向内存0-2000-23F依次传送数据063-3FH"><a href="#（1）编程，向内存0-2000-23F依次传送数据063-3FH" class="headerlink" title="（1）编程，向内存0:2000:23F依次传送数据063(3FH)"></a>（1）编程，向内存0:200<del>0:23F依次传送数据0</del>63(3FH)</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-17%20161753.png" alt="源程序"></p><p>编译后查看寄存器存储情况</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-17%20162152.png"></p><h3 id="（2）编程，向内存0-2000-23F依次传送数据063-3FH-，程序中只能使用9条指令，包括mov-ax-4c00h-int-21h"><a href="#（2）编程，向内存0-2000-23F依次传送数据063-3FH-，程序中只能使用9条指令，包括mov-ax-4c00h-int-21h" class="headerlink" title="（2）编程，向内存0:2000:23F依次传送数据063(3FH)，程序中只能使用9条指令，包括mov ax,4c00h,int 21h"></a>（2）编程，向内存0:200<del>0:23F依次传送数据0</del>63(3FH)，程序中只能使用9条指令，包括mov ax,4c00h,int 21h</h3><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-17%20162633.png" alt="源程序"></p><h3 id="（3）补全程序，调试程序（程序略），跟踪运行结果"><a href="#（3）补全程序，调试程序（程序略），跟踪运行结果" class="headerlink" title="（3）补全程序，调试程序（程序略），跟踪运行结果"></a>（3）补全程序，调试程序（程序略），跟踪运行结果</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-wu/"/>
      <url>/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-wu/</url>
      
        <content type="html"><![CDATA[<ol><li>将下面的程序编译、连接，用debug加载、跟踪，然后回答问题</li></ol><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20153046.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20153158.png"></p><p>debug加载跟踪</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20152805.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20152909.png"></p><p>（1）CPU执行程序，程序返回前，data段中的数据为多少？</p><p>不变</p><p>（2）CPU执行程序，程序返回前，cs &#x3D; ？、ss &#x3D; ？、ds &#x3D; ？</p><p>cs &#x3D; 076C，ss &#x3D; 076B，ds &#x3D; 076A</p><p>（3）设程序加载后，code段的段地址为X，则data段的段地址为？，stack段的段地址为？</p><p>data段的段地址为X-2，stack段的段地址为X-1</p><ol start="2"><li>将下面的程序编译、连接，用debug加载、跟踪，然后回答问题</li></ol><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20161312.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20161408.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20161833.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20161924.png"></p><p>（1）CPU执行程序，程序返回前，data段中的数据为多少</p><p>不变</p><p>（2）CPU执行程序，程序返回前，cs &#x3D; ？、ss &#x3D; ？、ds &#x3D; ？</p><p>cs &#x3D; 076C，ss &#x3D; 076B，ds &#x3D; 076A</p><p>（3）设程序加载后，code段的段地址为X，则data段的段地址为？，stack的段地址为？</p><p>data段的段地址为X-2，stack段的段地址为X-1</p><p>（4）对于如下定义的段：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">name segment...name ends<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果段中的数据占N个字节，则程序加载后，该段实际占有的空间为？</p><p>如果N小于16，那么实际占用16个字节；如果N大于16，那么实际占用（N&#x2F;16的取整+1）*16个字节。</p><ol start="3"><li>将下面的程序编译、连接，用debug加载、跟踪，然后回答问题<img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20162859.png"></li></ol><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20162941.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20163133.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20163234.png"></p><p>（1）CPU执行程序，程序返回前，data段中的数据为多少</p><p>不变</p><p>（2）CPU执行程序，程序返回前，cs &#x3D; ？、ss &#x3D; ？、ds &#x3D; ？</p><p>（3）设程序加载后，code段的段地址为X，则data段的段地址为？，stack的段地址为？</p><p>data段的段地址为X2，stack段的段地址为</p><ol start="4"><li>如果将1、2、3题中的最后一条伪指令end start改为end（也就是说，不指明程序的入口），则哪个程序仍然可以正确执行？请说明原因</li></ol><p>程序3可以正确执行</p><p>当将最后一条伪指令改为end时，程序将从第一条代码来执行，而程序1、2中开头的代码段是数据段，可能将数据段解释为其他的指令造成混乱</p><ol start="4"><li>程序如下，编写code段中的代码，将a段，b段中的数据依次相加，将结果存到c段中</li></ol><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20164627.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20164710.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20164924.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20165011.png"></p><ol start="4"><li>程序如下，编写code段中的代码，用push指令将a段中的前8个字型数据，逆序存储到b段中</li></ol><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20170816.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20170848.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20170952.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-20%20171024.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言（第三版）王爽—实验二</title>
      <link href="/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-er/"/>
      <url>/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-er/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="debug的使用"><a href="#debug的使用" class="headerlink" title="debug的使用"></a>debug的使用</h2><p><strong>关于D命令</strong></p><p>debug在执行如d 段地址：偏移地址这种D命令时，将段地址送入ds中比较方便</p><p><strong>在E,A,U命令中使用段寄存器</strong></p><p>debug的T命令在执行修改寄存器SS的指令时，下一条指令也紧接着被执行</p><h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><p>(1)使用debug将程序段写入内存中，并逐条执行</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_211335.png" alt="输入指令"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言（第三版）王爽—实验三</title>
      <link href="/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-san/"/>
      <url>/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-san/</url>
      
        <content type="html"><![CDATA[<h1 id="实验3-编程、编译、连接"><a href="#实验3-编程、编译、连接" class="headerlink" title="实验3 编程、编译、连接"></a>实验3 编程、编译、连接</h1><p>（1）将书中给出的程序保存为t1.asm文件，将其生成可执行文件t1.exe</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20203934.png" alt="在edit中输入程序"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20204305.png" alt="编译t1.asm文件"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20204454.png" alt="连接目标文件，生成可执行文件"></p><p>（2）用debug跟踪t1.exe的执行过程，写出每一步执行后，相关寄存器中的内容和栈顶的内容</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20204616.png" alt="查看各个寄存器的设置情况"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20204725.png" alt="分别执行每一条指令"></p><p><strong>执行至int 21H时，用p指令结束程序</strong></p><p><strong>显示”program terminated normally”表示程序已正常执行完毕</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20204818.png" alt="所有指令执行完毕"></p><p>（3）PSP的头两个字节是CD20，用debug加载t1.exe，查看PSP的内容</p><p>利用r命令查看寄存器内容</p><p>查看075a</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-13%20205248.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言（第三版）王爽——实验一</title>
      <link href="/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-yi/"/>
      <url>/2023/06/25/hui-bian-yu-yan-di-san-ban-wang-shuang-shi-yan-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="查看CPU和内存，用机器指令和汇编指令编程"><a href="#查看CPU和内存，用机器指令和汇编指令编程" class="headerlink" title="查看CPU和内存，用机器指令和汇编指令编程"></a>查看CPU和内存，用机器指令和汇编指令编程</h1><h2 id="debug的使用"><a href="#debug的使用" class="headerlink" title="debug的使用"></a>debug的使用</h2><h3 id="安装DOSBOX进行实验"><a href="#安装DOSBOX进行实验" class="headerlink" title="安装DOSBOX进行实验"></a>安装DOSBOX进行实验</h3><p><strong>R命令查看改变CPU寄存器内容</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_193445.png" alt="DOSBOX界面"></p><p>在所有寄存器的下方，debug还列出了CS:IP所指向的内存单元处所存放的机器码，并将它翻译为机器指令。</p><p>此处CS:IP所指向的内存单元为073F:0100.此处存放的及机器码为 0000 ，对应的汇编指令为 ADD [BX+SI],AL。</p><p>还可以利用R指令修改寄存器中的内容</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_194422.png" alt="使用R命令修改AX中的内容"></p><p><strong>D命令查看内存中的内容</strong></p><p>d 段地址：偏移地址</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_195008.png" alt="D命令查看内存1000:0处的内容"></p><p>debug将列出从指定内存单元往后128个内存单元的内容（1000:0~1000:F）</p><p>也可以指定查看的范围 d 段地址:起始偏移地址 结尾偏移地址</p><p><strong>用D命令改写内存内容</strong></p><p>e 起始地址 数据 数据 数据 数据…</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_200320.png" alt="用E指令修改1000：0开始的4个单元的内容"></p><p>也可以采用提问的方式来逐个的修改内存的内容</p><p><strong>用E命令向内存中写入机器码，用U命令查看内存中机器码的含义，用T命令执行内存中的机器码</strong></p><p>写入机器码</p><p>mov ax,0001</p><p>mov cx,0002</p><p>add ax,cx</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_202323.png" alt="将机器码写入内存"></p><p>使用U命令翻译</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_202645.png" alt="用U命令将内存单元中的内容翻译为汇编指令显示"></p><p>简单的使用T命令可以执行CS:IP指向的指令</p><p>若要用T命令控制CPU执行某个指令，必须先让CS:IP指向该指令</p><p>可用R命令修改CS:IP中的内容，使CS:IP指向指定的内容</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_203550.png" alt="修改CS:IP指向的内容"></p><p>再使用T命令执行指令</p><p>注意，指令执行后，AX中的内容被改写为1，IP改变为IP+3，CS:IP指向下一条指令</p><p><strong>A命令以汇编指令的形式在内存中写入机器指令</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_204150.png" alt="用A命令向从1000：0开始的内存单元中写入指令"></p><h3 id="本次实验中需要用到的命令"><a href="#本次实验中需要用到的命令" class="headerlink" title="本次实验中需要用到的命令"></a>本次实验中需要用到的命令</h3><p>查看修改CPU寄存器的内容：R命令</p><p>查看内存中的内容：D命令</p><p>修改内存中的内容：E命令（可以写入数据指令）</p><p>将内存中的内容解释为机器指令和对应的汇编指令：U命令</p><p>执行CS:IP指向的内存单元处的指令：T命令</p><p>以汇编指令的形式向内存中写入指令：A命令</p><h3 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h3><p>（1）使用debug，将下面的程序写入内存，逐条执行，观察每条指令(此处指令省略)执行后CPU中相关寄存器中内容的变化。</p><p>提示：可用E命令和A命令以两种方式将指令写入内存</p><p>（2）将下面3条指令写入从2000：0开始的内存单元中，利用这3条指令计算2的8次方。</p><p>mov ax,1</p><p>add ax,ax</p><p>jmp 2000:0003</p><p>（3）查看内存中的内容</p><p>（4）向内存从B8100H开始的单元中填写数据</p><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p>（1）使用debug，将下面的程序写入内存，逐条执行，观察每条指令(此处指令省略)执行后CPU中相关寄存器中内容的变化。</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_205601.png" alt="写入内存"></p><p>（2）将下面3条指令写入从2000：0开始的内存单元中，利用这3条指令计算2的8次方。</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_210154.png" alt="用A命令写入指令"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230304_211335.png"></p><p>执行八次即可得到2的8次方</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字节前端初阶训练营—计算机网络概论</title>
      <link href="/2023/06/25/zi-jie-qian-duan-chu-jie-xun-lian-ying-ji-suan-ji-wang-luo-gai-lun/"/>
      <url>/2023/06/25/zi-jie-qian-duan-chu-jie-xun-lian-ying-ji-suan-ji-wang-luo-gai-lun/</url>
      
        <content type="html"><![CDATA[<h1 id="01-简介"><a href="#01-简介" class="headerlink" title="01.简介"></a>01.简介</h1><h3 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h3><p><strong>自底向上</strong></p><p>由简单到复杂</p><p>由局部到整体</p><p><strong>自顶向下</strong></p><p>由复杂到简单</p><p>将复杂的系统问题模块化处理</p><h1 id="02-通过蟹堡王案例来理解计算机网络系统"><a href="#02-通过蟹堡王案例来理解计算机网络系统" class="headerlink" title="02.通过蟹堡王案例来理解计算机网络系统"></a>02.通过蟹堡王案例来理解计算机网络系统</h1><p>蟹老板要管理遍布全国的蟹堡王分店需要很多基础设施，其中比较重要的一项为通信。</p><p>为了开通外卖服务，扩大服务范围，蟹堡王需要建立专属于蟹堡王的通信网络。</p><p>蟹堡王的服务模式与现实中的计算机网络系统有许多相近之处</p><ul><li><p>比奇堡外卖</p></li><li><p>北京和上海分店</p></li><li><p>全国分店和通信网络</p></li><li><p><strong>蟹堡王顾客：客户端</strong></p></li><li><p><strong>蟹堡王分店：服务端</strong></p></li><li><p><strong>小区转发点和蟹堡王城市转发分店：路由器</strong></p></li><li><p><strong>转发表格网络协议</strong></p></li></ul><h1 id="03-计算机网络基础"><a href="#03-计算机网络基础" class="headerlink" title="03.计算机网络基础"></a>03.计算机网络基础</h1><p><strong>网络组成部分</strong></p><ul><li><p>主机：客户端和服务端</p></li><li><p>路由器</p></li><li><p>网络协议</p></li></ul><p><strong>网络结构：网络的网络</strong></p><ul><li><p>比奇堡和小区网络：本地网络</p></li><li><p>北京和上海分店+比奇堡：三个本地网络节点的网络</p></li><li><p>全国通信网络：本地网络的网络</p></li></ul><p>以上三种网络可以称为区域网络，城域网，广域网</p><blockquote><p>区域网络（Local area network，简称LAN）是连接住宅、学校、实验室、大学校园或办公大楼等有限区域内计算机的计算机网络。</p><p>城域网又称都会网络，指大型的计算机网络，是介于LAN和WAN之间能传输语音与资料的公用网络，这些网络通常涵盖一个大学校园或一座城市。 一些常用于城市区网的技术包含：异步传输模式（ATM）、光纤分布数据接口（FDDI）、千兆乙太网。</p><p>广域网（英语：Wide Area Network，缩写为WAN），又称外网、公网。 是连接不同地区局域网或城域网计算机通信的远程网。 通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个地区、城市和国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。 广域网并不等同于互联网。</p></blockquote><p><strong>信息交换的方式一般有两种：电路交换&amp;分组交换</strong></p><blockquote><p>电路交换（Circuit Switching）是相对于封包交换（或称分组交换）的一个概念。 电路交换要求必须首先在通信双方之间建立连接通道。 在连接建立成功之后，双方的通信活动才能开始。 通信双方需要传递的信息都是通过已经建立好的连接来进行传递的，而且这个连接也将一直被维持到双方的通信结束。</p><p>分组交换（Packet switching）是一种相对于电路交换的通信范例，分组（又称消息、或消息碎片）在节点间单独路由，不需要在传输前先建立通信路径。 分组交换是数据通信中一种新的且重要的概念，现在是世界上互联网通讯、数据和语音通信中最重要的基础。</p></blockquote><p><strong>网络分层</strong></p><p>计算机网络分为五层</p><p>从低到高为</p><p>物理层 链路层 网络层 运输层 应用层</p><p>每一层都有各自的职责，并对自身层级的内容进行分装，这些内容对于上一层几乎是黑盒的</p><p>类比于现实中的例子</p><ul><li><p>快递员不关心包裹内容</p></li><li><p>卡车司机不关心车厢里拉的是什么</p></li><li><p>高速公路不关心开的什么车</p></li></ul><p><strong>协议</strong></p><p>协议的存在依赖于连接</p><p>协议定义了在两个或多个通信实体之间交换的<strong>报文格式和顺序</strong>，以及报文发送和&#x2F;或接受一条报文或其他事件所采取的动作</p><p><strong>标头(header)和载荷(payload)</strong></p><blockquote><p>HTTP 标头（header）允许客户端和服务器通过 HTTP 请求（request）或者响应（response）传递附加信息。一个 HTTP 标头由它的名称（不区分大小写）后跟随一个冒号（:），冒号后跟随它具体的值。该值之前的空格 (en-US)会被忽略。  </p></blockquote><p><strong>报文的组成：链路层头部+IP协议头部+TCP头部+HTTP头部+HTTP正文</strong></p><p><strong>http协议</strong></p><p>在http&#x2F;1.1中，头部和载荷通过两个换行符和两个回车符进行分割(\r\n\r\n)</p><p><strong>TCP协议</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20214828.png"></p><p>TCP协议中，最前面的2个字节是源端口号，往后的2个字节是目标端口号</p><p>接下来的8个字节分别是序列号（4字节）、ACK号（4字节）</p><p>TCP中头部和载荷的分割依靠图中Data offset部分（13~14字节）</p><p>在HTTP协议中，需要对ASCII码进行解析，得到二进制数据，发现有连续的换行符和回车符即为头部与载荷的分割</p><p><strong>小结</strong></p><ul><li><p>网络组成部分：由主机、路由器、交换机组成</p></li><li><p>网络结构：网络的网络</p></li><li><p>信息交换方式：电路交换和分组交换</p></li><li><p>网络分层：分清职责，物理层、链路层、网络层、运输层和应用层</p></li><li><p>网络协议：标头和载荷</p></li></ul><h1 id="04-Web中的网络"><a href="#04-Web中的网络" class="headerlink" title="04.Web中的网络"></a>04.Web中的网络</h1><p><strong>HTTP协议</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20220157.png"></p><p>在这个示例中，红色的是请求，蓝色的是响应</p><p><strong>HTTP请求</strong></p><ul><li>第一行：GET &#x2F; HTTP&#x2F;1.1</li></ul><p>这三项分别代表请求的方法、资源路径、HTTP版本</p><ul><li>其他几行：头部</li></ul><p>每一行代表一个头部，头部的名称和头部的值用冒号分割</p><p>头部名称不区分大小写</p><ul><li>正文与头部间隔一行（此示例中没有头部）</li></ul><p><strong>HTTP响应</strong></p><ul><li>第一行：HTTP&#x2F;1.1 200 OK</li></ul><p>状态行</p><p>这三项分别代表HTTP版本、状态码、状态信息（可以自定义）</p><ul><li><p>其他几行：头部（与HTTP请求类似）</p></li><li><p>正文与头部间隔一行</p></li></ul><p><strong>HTTP连接模型（请求响应模型）</strong></p><p>当客户端发起第一个请求后，需要等待服务端发送第一个的完整响应，客户端才可以发出第二个请求</p><p>缺点：无法进行多路复用</p><p>Short-lived connections（HTTP&#x2F;1.0）：</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20221026.png"></p><p>Persistent connection（HTTP&#x2F;1.1）:</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20221457.png"></p><p>HTTP Pipeling:</p><p>允许客户端发送多个请求，服务器按顺序响应</p><p>但对于解决队头堵塞几乎没有帮助</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20221617.png"></p><p>为解决队头堵塞问题，最常用的方案是同时建立多个HTTP连接，将请求分散在多个HTTP连接上</p><p>浏览器一般会限制HTTP连接的数量，通常是6个</p><p><strong>HTTP1.1：无法多路复用</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">body<span class="token punctuation">&#123;</span>    <span class="token literal-property property">color</span><span class="token operator">:</span> red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果按行交错发送，客户端收到的内容将会是</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">body<span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token literal-property property">color</span><span class="token operator">:</span> red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>无法判断流中的哪一行都是属于哪个请求，因此无法实现多路复用</p><p><strong>HTTP2：帧</strong></p><p>将多个HTTP请求拆分到帧中，每个帧可以携带来自不同HTTP请求的数据（此处的帧和链路层的帧并非同一种，只是原理类似）</p><p>可以标识哪个数据包来自哪个请求，进而实现多路复用</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">request=style.css<span class="token punctuation">,</span> content=<span class="token string">'body&#123;'</span>request=main.js<span class="token punctuation">,</span> content-<span class="token string">'console.log('</span>hello world<span class="token string">')'</span>request=style.css<span class="token punctuation">,</span> content=<span class="token string">' color: red;'</span>request=style.css<span class="token punctuation">,</span> content=<span class="token string">'&#125;'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>HTTP帧的结构</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20222953.png"></p><p>最开始的3个字节：帧的长度</p><p>第4个字节：帧的类型</p><p>第5个字节：当前帧的状态</p><p>第6个字节：第1位是保留位，后面的31位代表这个帧所属流的ID</p><p>后面为帧的载荷</p><p><strong>HTTP2：帧带来的额外好处</strong></p><ul><li><p>调整响应传输的优先级</p></li><li><p>头部压缩</p></li><li><p>Server Push</p></li></ul><p><strong>HTTP 2：队头堵塞，但是在TCP上</strong></p><p>由于TCP对上层数据缺乏必要的信息（包1不影响包0、2、3），导致队头堵塞</p><p>这个问题很难再已有的TCP协议上解决</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20224128.png"></p><p><strong>HTTP 2：3RTT启动</strong></p><p>TCP连接建立需要一个RTT</p><p>TLS连接建立需要两个RTT</p><p>效率很低</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20224317.png"></p><p><strong>HTTP 3：QUIC</strong></p><p>QUIC将TLS作为自身的一部分，吸取HTTP 2中流的概念</p><p>同时引入新的机制，实现首次1 RTT，后续连接0 RTT的特性</p><ul><li><p>Quick UDP Internet Connection</p></li><li><p>现存网络设备对TCP和UDP支持已经僵化</p></li><li><p>UDP不靠谱但是QUIC靠谱</p></li><li><p>QUIC可以为除HTTP协议以外的应用层协议提供支持</p></li></ul><p><strong>HTTP 3：QUIC-1 RTT</strong></p><p>QUIC实现首次1 RTT，后续连接0 RTT的过程</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20224949.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20225129.png"></p><p><strong>除HTTP外，还有很多因素会影响浏览器的性能</strong></p><p><strong>CDN：你无法突破的物理极限</strong></p><p>超远距离因素无法克服</p><p>流量越大，花销越大</p><p>服务器承载网络流量有限</p><p>CDN可以承担内容分发的任务</p><p><strong>CDN：DNS劫持</strong></p><ul><li><p>域名解析一般由网站自己处理</p></li><li><p>要加速的域名则重定向到CDN厂商的域名解析服务处理</p></li><li><p>CDN厂商根据来源确定最近的CDN服务器的IP</p></li><li><p>用户直接访问最近的CDN服务器</p></li></ul><p><strong>CDN：如何选择CDN服务器</strong></p><p>一种比较简单的策略是，根据DNS查询来源IP的地理位置，确定最近的CDN服务器</p><p>但这并不是最好的策略</p><p><strong>CDN：拉策略和推策略</strong></p><blockquote><p>CDN 加速策略有两种方式，分别是<strong>「推模式」和「拉模式」</strong>。   </p><p> 大部分 CDN 加速策略采用的是「拉模式」，当用户就近访问的 CDN 节点没有缓存请求的数据时，CDN 会主动从源服务器下载数据，并更新到这个 CDN 节点的缓存中。    </p><p>可以看出，拉模式属于被动缓存的方式，与之相反的 「推模式」就属于主动缓存的方式。   </p><p> 如果想要把资源在还没有用户访问前缓存到 CDN 节点，则可以采用「推模式」，这种方式也叫 CDN 预热。   </p><p> 通过 CDN 服务提供的 API 接口，把需要预热的资源地址和需要预热的区域等信息提交上去，CDN 收到后，就会触发这些区域的 CDN 节点进行回源来实现资源预热。</p></blockquote><p>CDN可以从物理层面解决HTTP无法解决的问题，进而提升web应用的性能</p><p><strong>WebSocket</strong></p><p>WebSocket有以下特点：</p><ul><li><p>有状态的持久连接</p></li><li><p>服务端可以主动推送消息</p></li><li><p>发送消息延迟比HTTP低</p></li></ul><p>使用websocket协议需要在HTTP协议的基础上，双方进行协商</p><p><strong>WebSocket：示例</strong></p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">//服务端代码const</span> <span class="token punctuation">&#123;</span> WebSocketServer <span class="token punctuation">&#125;</span> = <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'ws'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token selector">const wss = new WebSocketServer(</span><span class="token punctuation">&#123;</span> <span class="token property">port</span><span class="token punctuation">:</span> 8080<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token selector">wss.on('connection', function connection(ws)</span> <span class="token punctuation">&#123;</span>    <span class="token selector">//有新连接时监听来自客户端的消息    ws.on('message', function message(data)</span> <span class="token punctuation">&#123;</span>        //打印收到的消息，再把消息原封不动地发回客户端        console.<span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'received: %s'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>        ws.<span class="token function">send</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css" data-language="css"><code class="language-css">//客户端代码const WebSocket = <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'ws'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>const ws = new <span class="token function">WebSocket</span><span class="token punctuation">(</span><span class="token string">'ws://localhost:8080'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token selector">ws.on('open', function open()</span> <span class="token punctuation">&#123;</span>    //当连接建立时，向服务器端发送一条消息    ws.<span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'something'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token selector">ws.on('message', function message(data)</span> <span class="token punctuation">&#123;</span>    //当收到来自服务器端的消息时，打印出来    console.<span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'received: %s'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>升级HTTP为WebSocket</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20233020.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20233056.png"></p><p><strong>WebSocket：发送消息</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20233231.png"></p><p><strong>小结</strong></p><ul><li><p>HTTP1、2、3的演进历史</p></li><li><p>CDN解决了HTTP协议以外的问题</p></li><li><p>WebSocket从HTTP协议升级而来</p></li></ul><h1 id="05-网络安全"><a href="#05-网络安全" class="headerlink" title="05.网络安全"></a>05.网络安全</h1><p><strong>网络安全：三要素</strong></p><ul><li><p>机密性</p></li><li><p>完整性</p></li><li><p>身份验证</p></li></ul><p><strong>网络安全：对称加密和非对称加密</strong></p><ul><li><p>对称加密：加密、解密用同样的密钥</p></li><li><p>非对称加密：加密、解密使用不同的密钥（公钥和私钥），而且公钥加密只能用私钥解密、私钥加密只能用公钥解密</p></li></ul><p><strong>网络安全：密码散列函数（哈希函数）</strong></p><ul><li><p>输入：任意长度的内容</p></li><li><p>输出：固定长度的哈希值</p></li><li><p>性质：找到两个不同输入使之经过密码散列函数后有相同的哈希值，在计算上是不可能的</p></li></ul><p><strong>网络安全：机密性</strong></p><ul><li><p>加密需要加密算法和密钥等信息（秘密信息）</p></li><li><p>网络是明文的，不安全</p></li></ul><p><strong>网络安全：完整性和身份验证</strong></p><p>完整性和身份验证相关联</p><p><strong>网络安全：如何实现机密性</strong></p><p>想要通过明文通信交换秘密信息，通信双方需要先有秘密信息</p><p><strong>网络安全：如何实现完整性</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20234140.png"><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20234149.png"></p><p><strong>网络安全：如何实现身份验证</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-13%20234252.png"></p><p>（未完待续）</p><p>让我先把当天的笔记发上去，有时间补上后面的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字节前端初阶训练营—shell脚本和编程</title>
      <link href="/2023/06/25/zi-jie-qian-duan-chu-jie-xun-lian-ying-shell-jiao-ben-he-bian-cheng/"/>
      <url>/2023/06/25/zi-jie-qian-duan-chu-jie-xun-lian-ying-shell-jiao-ben-he-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="01-课程介绍"><a href="#01-课程介绍" class="headerlink" title="01.课程介绍"></a>01.课程介绍</h1><p>学习shell的价值：</p><p>1.linux服务器的基本操作和管理</p><p>2.前端Node.js服务的进程管理、问题排查、资源监控等运维操作</p><p>3.使用shell编写TCE、SCM、Docker脚本完成服务编译和部署</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字节前端初阶训练营—Linux基础</title>
      <link href="/2023/06/25/zi-jie-qian-duan-chu-jie-xun-lian-ying-linux-ji-chu/"/>
      <url>/2023/06/25/zi-jie-qian-duan-chu-jie-xun-lian-ying-linux-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="01-计算机硬件"><a href="#01-计算机硬件" class="headerlink" title="01.计算机硬件"></a>01.计算机硬件</h1><p>计算机由五大基本单元组成</p><ul><li><p>控制器</p></li><li><p>运算器</p></li><li><p>存储器单元</p></li><li><p>输入单元</p></li><li><p>输出单元</p></li></ul><h1 id="02-操作系统"><a href="#02-操作系统" class="headerlink" title="02.操作系统"></a>02.操作系统</h1><p><strong>操作系统（Operating System，OS）</strong></p><p>管理和控制计算机系统中的硬件和软件资源，用于在用户与系统硬件之间传递信息</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20160350.png"></p><p>目前主流的操作系统有MacOS、Linux、Windows、安卓、HarmonyOS</p><p><strong>操作系统启动流程</strong></p><p>操作系统启动共有两种模式</p><ol><li>基于BIOS引导操作系统启动的传动模式</li><li>基于UEFI引导操作系统启动的主流模式</li></ol><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20160807.png"></p><p>BIOS和UEFI是固化在主板上的一段程序，当计算机开机时能够自动运行这段程序</p><p>当这段程序被启动以后，首先进行初始化等一系列的动作，找到并运行Bootloader（操作系统引导程序），通过Bootloader运行OS</p><p>UEFI优化了BIOS的自检流程，提高了启动速度</p><blockquote><p>BIOS（英文：Basic Input&#x2F;Output System），即基本输入输出系统，亦称为ROM BIOS、System BIOS、PC BIOS，是在通电启动阶段执行硬件初始化，以及为操作系统提供运行时服务的固件。BIOS最早随着CP&#x2F;M操作系统的推出在1975年出现。BIOS预安装在个人电脑的主板上，是个人电脑启动时加载的第一个软件。许多BIOS程序都只能在特定电脑型号或特定主板型号上执行。早年，BIOS存储于ROM芯片上；现在的BIOS多存储于闪存芯片上，这方便了BIOS的更新。</p><p>统一可扩展固件接口（英语：Unified Extensible Firmware Interface，缩写UEFI）是一种个人电脑系统规格，用来定义操作系统与系统固件之间的软件界面，作为BIOS的替代方案。可扩展固件接口负责加电自检（POST）、联系操作系统以及提供连接操作系统与硬件的接口。</p></blockquote><h1 id="03-Linux系统概览"><a href="#03-Linux系统概览" class="headerlink" title="03.Linux系统概览"></a>03.Linux系统概览</h1><p><strong>Linux发展简史</strong></p><p>1969年，Unix诞生于贝尔实验室</p><p>1984年，贝尔实验室将Unix商业化</p><p>1984年，Tanenbaum开发Mnix操作系统用于教学开发并开放源码</p><p>1984年，Richard M.Stallman发起自由软件（FSF）与GNU项目，起草GPL（通用公共许可）协议</p><p>1991年，Linus Torvalds受Mnix影响实现初版的Linux内核</p><p>1992年，Linux内核以GPL协议发行V1.0</p><p><strong>Linux版本</strong></p><ul><li>内核版本</li><li>发行版本</li></ul><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20162018.png"></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20162130.png"></p><p><strong>查看Linux系统内核版本</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">uname</span> <span class="token parameter variable">-a</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /proc/version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /etc/os-release<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>Linux应用领域</strong></p><ul><li>IT服务器（操作系统、虚拟化和云计算）</li><li>嵌入式和智能设备</li><li>个人办公桌面</li><li>学术研究和软件开发</li></ul><p><strong>Linux基本组成</strong></p><ul><li>内核</li><li>shell（命令解释器）</li><li>文件系统</li><li>应用程序</li></ul><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20162725.png"></p><p><strong>Linux体系结构</strong></p><p>Linux系统分为用户空间和内核空间</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20162837.png"></p><ul><li>内核是硬件与软件之间的中间层</li><li>内核是一个资源管理程序</li><li>内核提供一组面向系统的命令</li></ul><h1 id="03-Linux系统结构——进程管理"><a href="#03-Linux系统结构——进程管理" class="headerlink" title="03.Linux系统结构——进程管理"></a>03.Linux系统结构——进程管理</h1><p><strong>进程管理</strong></p><ul><li>进程是正在执行的一个程序或命令</li><li>进程有自己的地址空间</li><li>一个CPU核同一时间只能运行一个进程</li><li>进程由它的进程ID（PID）和它父进程的进程ID（PPID）唯一识别</li></ul><p><strong>查看进程信息</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#查看启动的nginx进程</span><span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#查看某个进程</span><span class="token function">top</span> <span class="token parameter variable">-p</span> <span class="token number">93824</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#关闭指定的进程</span><span class="token function">kill</span> <span class="token number">93824</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#全部进程动态实时视图</span><span class="token function">top</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>进程调度</strong></p><p>进程调度是指操作系统按某种策略或规则选择进程占用CPU进行运行的过程</p><ul><li>R：可执行状态</li><li>S：可中断的睡眠状态</li><li>D：不可中断的睡眠状态</li><li>T：暂停状态或跟踪状态</li><li>Z：退出状态，进程成为僵尸进程</li><li>X：退出状态，进程即将被销毁</li></ul><p><strong>进程调度的原则</strong></p><ul><li>一个CPU核同一时间只能运行一个进程</li><li>每个进程有近乎相等的执行时间</li><li>对于逻辑CPU而言进程调度使用轮询的方式进行，当轮询完成则回到第一个进程反复</li><li>进程执行消耗时间和进程量成正比</li></ul><p><strong>进程的系统调用</strong></p><p>内核空间：系统内核运行的控件</p><p>用户空间：应用程序运行的空间</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20201132.png"></p><p>当任务切换到内核态，应用程序便有权限和底层的硬件平台进行交互</p><h1 id="04-Linux系统结构——文件系统"><a href="#04-Linux系统结构——文件系统" class="headerlink" title="04.Linux系统结构——文件系统"></a>04.Linux系统结构——文件系统</h1><p><strong>文件系统</strong></p><p>文件系统是操作系统中负责管理持久数据的子系统，负责把用户的文件存到磁盘赢家那中，持久化的保存文件</p><p>Linux中，文件可以是普通文件、目录、设备、套接字</p><p>Linux中一切皆文件</p><p>Linux文件系统是采用树状的目录结构</p><p>最上层的是&#x2F;（根）目录</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20201758.png"></p><p><strong>虚拟文件系统（VFS）</strong></p><p>对应用层提供一个标准的文件<strong>操作接口</strong></p><p>对文件系统提供一个标准的文件<strong>接入接口</strong></p><p>VFS抹平不同文件之间的差异</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20202041.png"></p><p><strong>查看文件系统类型</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#df命令报告文件系统磁盘空间利用率</span><span class="token function">df</span> <span class="token parameter variable">-T</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># mount命令是挂载文件系统用的，不带任何参数运行，会打印包含文件系统类型在内的磁盘分区的信息</span><span class="token function">mount</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>文件基本操作</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> <span class="token comment">#查看文件夹下的内容</span><span class="token function">mkdir</span> demo <span class="token comment">#创建文件夹</span><span class="token function">mv</span> demo /home <span class="token comment">#移动demo文件夹到 /home</span><span class="token function">rm</span> <span class="token parameter variable">-r</span> demo <span class="token comment">#删除demo文件夹</span><span class="token function">touch</span> file.txt <span class="token comment">#创建空文件</span><span class="token function">cp</span> file.txt file_bak.txt <span class="token comment">#复制文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>文件读取流程</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20202622.png"></p><h1 id="05-Linux系统结构——用户权限"><a href="#05-Linux系统结构——用户权限" class="headerlink" title="05.Linux系统结构——用户权限"></a>05.Linux系统结构——用户权限</h1><p><strong>用户账户</strong></p><ul><li>用户账户</li></ul><p>普通用户账户：在系统中进行普通作业</p><p>超级用户账户：在系统中对普通用户和整个系统进行管理</p><ul><li>组账户</li></ul><p>标准组：可以容纳多个用户</p><p>私有组：只有用户自己</p><p><strong>查看用户信息</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#查看当前登录用户信息</span>w<span class="token comment">#查看当前用户所属的组</span><span class="token function">groups</span><span class="token comment">#查看用户的uid信息</span><span class="token function">id</span> *** <span class="token comment">#用户名</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>文件权限</strong></p><p>所有者：文件的所有者</p><p>所在组：文件的所有者所在的组</p><p>其他人：除文件所有者及所在组外的其他人</p><p>每个用户对于文件都有不同的权限，包括读（R）、写（W）、执行（X）</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20203530.png"></p><p><strong>用户权限操作</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20203705.png"></p><h1 id="06-Linux软件包"><a href="#06-Linux软件包" class="headerlink" title="06.Linux软件包"></a>06.Linux软件包</h1><ul><li>软件包</li></ul><p>通常是一个应用程序，可以是一个GUI应用程序、命令行工具或（其他软件程序需要的）软件库</p><ul><li>软件包管理</li></ul><p>底层工具：主要用来处理安装和删除软件包文件等任务，DPKG，RPM</p><p>上层工具：主要用于数据的搜索任务和依赖解析任务，APT，YUM，DNF</p><p><strong>软件包管理工具</strong></p><p>RPM（Red Hat Package Manager），为Red hat操作系统的包管理系统</p><p>DPKG（Debian Package），为Debian操作系统的包管理系统</p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20204327.png"></p><p><strong>Debian APT常用命令</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20204512.png"></p><p><strong>Debian配置软件源</strong></p><p><img src="https://my-blog-realhuameng.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-14%20204630.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/06/25/hello-world/"/>
      <url>/2023/06/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
